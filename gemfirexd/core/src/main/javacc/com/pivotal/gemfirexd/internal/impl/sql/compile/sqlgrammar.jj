options
{
	STATIC = false;
	LOOKAHEAD = 1;
	DEBUG_PARSER = false;
	DEBUG_LOOKAHEAD = false;
	DEBUG_TOKEN_MANAGER = false;
	ERROR_REPORTING = true;
	USER_TOKEN_MANAGER = false;
	USER_CHAR_STREAM = true;
	COMMON_TOKEN_ACTION = true;
	CACHE_TOKENS = true;
	UNICODE_INPUT = true;
}

PARSER_BEGIN(SQLParser)

/*

   Derby - File com.pivotal.gemfirexd.internal.impl.sql.compile.sqlgrammar.jj

   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to you under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

*/
/*
 * Fixes and additions for GemFireXD extensions, and to work with
 * GemFireXD distributed data platform.
 *
 * Portions Copyright (c) 2010-2015 Pivotal Software, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License. You
 * may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License. See accompanying
 * LICENSE file.
 */

package com.pivotal.gemfirexd.internal.impl.sql.compile;

import com.pivotal.gemfirexd.internal.iapi.sql.Statement;
import com.pivotal.gemfirexd.internal.iapi.sql.StatementType;

/* aggregates */
import com.pivotal.gemfirexd.internal.impl.sql.compile.CountAggregateDefinition;
import com.pivotal.gemfirexd.internal.impl.sql.compile.MaxMinAggregateDefinition;
import com.pivotal.gemfirexd.internal.impl.sql.compile.SumAvgAggregateDefinition;

import com.pivotal.gemfirexd.internal.impl.sql.compile.AggregateNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.BinaryOperatorNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.CallStatementNode;
import	com.pivotal.gemfirexd.internal.impl.sql.compile.CharConstantNode;
import	com.pivotal.gemfirexd.internal.impl.sql.compile.CastNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.ColumnDefinitionNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.ColumnReference;
import com.pivotal.gemfirexd.internal.impl.sql.compile.CursorNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.FromBaseTable;
import com.pivotal.gemfirexd.internal.impl.sql.compile.FromList;
import com.pivotal.gemfirexd.internal.impl.sql.compile.FromSubquery;
import com.pivotal.gemfirexd.internal.impl.sql.compile.FromTable;
import com.pivotal.gemfirexd.internal.impl.sql.compile.GroupByList;
import com.pivotal.gemfirexd.internal.impl.sql.compile.HasNodeVisitor;
import com.pivotal.gemfirexd.internal.impl.sql.compile.JavaToSQLValueNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.JoinNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.MethodCallNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.QueryTreeNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.ReplaceAggregatesWithCRVisitor;
import com.pivotal.gemfirexd.internal.impl.sql.compile.ResultColumnList;
import com.pivotal.gemfirexd.internal.impl.sql.compile.ResultColumn;
import com.pivotal.gemfirexd.internal.impl.sql.compile.OrderByList;
import com.pivotal.gemfirexd.internal.impl.sql.compile.OrderByColumn;
import com.pivotal.gemfirexd.internal.impl.sql.compile.ResultSetNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.SelectNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.SubqueryNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.TableName;
import com.pivotal.gemfirexd.internal.impl.sql.compile.TernaryOperatorNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.ParameterNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.PrivilegeNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.ConstraintDefinitionNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.DMLModStatementNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.RoutineDesignator;
import com.pivotal.gemfirexd.internal.impl.sql.compile.StatementNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.TableElementList;
import com.pivotal.gemfirexd.internal.impl.sql.compile.TableElementNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.TableOperatorNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.TablePrivilegesNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.TransactionStatementNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.TriggerReferencingStruct;
import com.pivotal.gemfirexd.internal.impl.sql.compile.UnionNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.IntersectOrExceptNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.UnaryOperatorNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.UntypedNullConstantNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.UpdateNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.UserTypeConstantNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.ValueNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.ValueNodeList;
import com.pivotal.gemfirexd.internal.impl.sql.compile.GroupByColumn;
import com.pivotal.gemfirexd.internal.impl.sql.compile.CurrentDatetimeOperatorNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.DDLStatementNode;
import com.pivotal.gemfirexd.internal.impl.sql.compile.AlterTableNode;

import com.pivotal.gemfirexd.internal.impl.sql.compile.ParseException;
import com.pivotal.gemfirexd.internal.impl.sql.compile.Token;
import com.pivotal.gemfirexd.internal.impl.sql.compile.TokenMgrError;
import com.pivotal.gemfirexd.internal.impl.sql.compile.SQLParserConstants;
import com.pivotal.gemfirexd.internal.impl.sql.compile.CharStream;
import com.pivotal.gemfirexd.internal.impl.sql.execute.TablePrivilegeInfo;
import com.pivotal.gemfirexd.internal.iapi.sql.dictionary.DataDictionary;
import com.pivotal.gemfirexd.internal.iapi.sql.dictionary.TableDescriptor;
import com.pivotal.gemfirexd.internal.iapi.sql.dictionary.TriggerDescriptor;
import com.pivotal.gemfirexd.internal.iapi.sql.dictionary.ViewDescriptor;
import com.pivotal.gemfirexd.internal.iapi.sql.dictionary.SchemaDescriptor;

import com.pivotal.gemfirexd.internal.iapi.sql.conn.Authorizer;
import com.pivotal.gemfirexd.internal.iapi.sql.execute.ConstantAction;
import com.pivotal.gemfirexd.internal.iapi.sql.execute.ExecutionContext;
import com.pivotal.gemfirexd.internal.impl.sql.execute.xplain.XPLAINUtil;

import com.pivotal.gemfirexd.internal.iapi.types.DataTypeDescriptor;
import com.pivotal.gemfirexd.internal.iapi.types.TypeId;
import com.pivotal.gemfirexd.internal.iapi.sql.compile.TypeCompiler;
import com.pivotal.gemfirexd.internal.iapi.sql.conn.LanguageConnectionContext;

import com.pivotal.gemfirexd.internal.iapi.types.DateTimeDataValue;
import com.pivotal.gemfirexd.internal.iapi.types.DataTypeDescriptor;
import com.pivotal.gemfirexd.internal.iapi.types.DataTypeUtilities;
import com.pivotal.gemfirexd.internal.iapi.types.StringDataValue;
import com.pivotal.gemfirexd.internal.iapi.types.DataValueDescriptor;
import com.pivotal.gemfirexd.internal.iapi.sql.compile.TypeCompilerFactory;

import com.pivotal.gemfirexd.internal.iapi.error.StandardException;

import com.pivotal.gemfirexd.internal.iapi.reference.Property;
import com.pivotal.gemfirexd.internal.iapi.reference.SQLState;
import com.pivotal.gemfirexd.internal.iapi.reference.JDBC30Translation;
import com.pivotal.gemfirexd.internal.iapi.reference.JDBC40Translation;
import com.pivotal.gemfirexd.internal.iapi.reference.Limits;

import com.pivotal.gemfirexd.internal.iapi.sql.compile.CompilerContext;
import com.pivotal.gemfirexd.internal.iapi.sql.compile.C_NodeTypes;

import com.pivotal.gemfirexd.internal.iapi.services.context.ContextManager;

import com.pivotal.gemfirexd.internal.iapi.sql.compile.NodeFactory;

import com.pivotal.gemfirexd.internal.iapi.services.sanity.SanityManager;

import com.pivotal.gemfirexd.internal.catalog.AliasInfo;
import com.pivotal.gemfirexd.internal.catalog.TypeDescriptor;
import com.pivotal.gemfirexd.internal.catalog.types.RoutineAliasInfo;

import com.pivotal.gemfirexd.internal.iapi.services.io.FormatableProperties;
//import com.pivotal.gemfirexd.internal.iapi.services.io.StoredFormatIds;
import com.pivotal.gemfirexd.internal.shared.common.StoredFormatIds;
import com.pivotal.gemfirexd.internal.iapi.util.ReuseFactory;
import com.pivotal.gemfirexd.internal.iapi.services.io.FormatableBitSet;
import com.pivotal.gemfirexd.internal.iapi.util.StringUtil;
import com.pivotal.gemfirexd.internal.engine.store.GemFireStore;

import java.sql.Types;
import java.util.List;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.StringTokenizer;
import java.util.Vector;
import java.lang.Character;
import java.lang.UnsupportedOperationException;

// GemStone changes BEGIN
import java.io.File;
import java.math.BigDecimal;
import java.util.ArrayDeque;
import java.util.Iterator;


import com.gemstone.gemfire.cache.AttributesFactory;
import com.gemstone.gemfire.cache.ExpirationAttributes;
import com.gemstone.gemfire.cache.EvictionAction;
import com.gemstone.gemfire.cache.EvictionAttributes;
import com.gemstone.gemfire.cache.PartitionAttributesFactory;
import com.gemstone.gemfire.cache.DataPolicy;

import com.gemstone.gemfire.cache.ExpirationAction;
import com.gemstone.gemfire.cache.PartitionAttributes;
import com.gemstone.gemfire.cache.PartitionResolver;
import com.gemstone.gemfire.cache.Region;
import com.gemstone.gemfire.cache.RegionAttributes;
import com.gemstone.gemfire.cache.Scope;
import com.gemstone.gemfire.cache.util.ObjectSizer;
import com.gemstone.gemfire.distributed.internal.DistributionConfig;
import com.gemstone.gemfire.internal.ClassPathLoader;
import com.gemstone.gemfire.internal.i18n.LocalizedStrings;

import com.pivotal.gemfirexd.Constants;
import com.gemstone.gemfire.internal.cache.InternalPartitionResolver;
import com.pivotal.gemfirexd.internal.engine.Misc;
import com.pivotal.gemfirexd.internal.engine.GfxdConstants;
import com.pivotal.gemfirexd.internal.engine.ddl.EvictionTableAttribute;
import com.pivotal.gemfirexd.internal.engine.ddl.InitSizeTableAttribute;
import com.pivotal.gemfirexd.internal.engine.ddl.ServerGroupsTableAttribute;
import com.pivotal.gemfirexd.internal.engine.ddl.GfxdEvictionCriteria;
import com.pivotal.gemfirexd.internal.engine.ddl.GfxdAttributesMutator;
import com.pivotal.gemfirexd.internal.engine.ddl.resolver.GfxdPartitionResolver;
import com.pivotal.gemfirexd.internal.engine.ddl.resolver.GfxdRangePartitionResolver;
import com.pivotal.gemfirexd.internal.engine.ddl.resolver.GfxdPartitionByExpressionResolver;
import com.pivotal.gemfirexd.internal.engine.ddl.resolver.GfxdListPartitionResolver;
import com.pivotal.gemfirexd.internal.engine.distributed.utils.GemFireXDUtils;
import com.pivotal.gemfirexd.internal.impl.sql.compile.ConstantNode;
import com.pivotal.gemfirexd.internal.engine.sql.compile.DistributionDefinitionNode;
import com.pivotal.gemfirexd.internal.engine.sql.compile.ParameterizedConstantNode;
import com.pivotal.gemfirexd.internal.engine.sql.catalog.DistributionDescriptor;
import com.pivotal.gemfirexd.internal.engine.procedure.coordinate.DistributedProcedureCallNode;
import com.pivotal.gemfirexd.internal.engine.procedure.coordinate.ProcedureProcessorNode;
import com.pivotal.gemfirexd.internal.impl.jdbc.Util;
import com.pivotal.gemfirexd.internal.engine.store.ServerGroupUtils;
import com.gemstone.gemfire.internal.snappy.CallbackFactoryProvider;
import com.gemstone.gemfire.internal.snappy.StoreCallbacks;

// GemStone changes END

public class SQLParser
{
	private static final String[] SAVEPOINT_CLAUSE_NAMES = {"UNIQUE", "ON ROLLBACK RETAIN LOCKS", "ON ROLLBACK RETAIN CURSORS"};
	private static final String[] ROUTINE_CLAUSE_NAMES =
		{null, "SPECIFIC", "RESULT SET", "LANGUAGE", "EXTERNAL NAME", "PARAMETER STYLE", "SQL", "ON NULL INPUT"};
	/**
	   Clauses required for Java routines. Numbers correspond
	   to offsets in ROUTINE_CLAUSE_NAMES.
	   3 - "LANGUAGE"
	   4 - "EXTERNAL NAME"
	   5 - "PARAMETER STYLE"
	*/
	private static final int[] JAVA_ROUTINE_CLAUSES = {3,4,5};
	private static final String[] TEMPORARY_TABLE_CLAUSE_NAMES = {"NOT LOGGED", "ON COMMIT", "ON ROLLBACK"};
	/* The default length of a char or bit if the length is omitted */
	private static final int	DEFAULT_STRING_COLUMN_LENGTH = 1;

	// Defines for ON or USING clauses
	private static final int	ON_OR_USING_CLAUSE_SIZE = 2;
	private static final int	ON_CLAUSE = 0;
	private static final int	USING_CLAUSE = 1;

	// Defines for optional table clauses
	private static final int	OPTIONAL_TABLE_CLAUSES_SIZE = 3;
	private static final int	OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES = 0;
	private static final int	OPTIONAL_TABLE_CLAUSES_DERIVED_RCL = 1;
	private static final int	OPTIONAL_TABLE_CLAUSES_CORRELATION_NAME = 2;

	// Define for UTF8 max
	private static final int	MAX_UTF8_LENGTH = 65535;

    // Constants for set operator types
    private static final int NO_SET_OP = 0;
    private static final int UNION_OP = 1;
    private static final int UNION_ALL_OP = 2;
    private static final int EXCEPT_OP = 3;
    private static final int EXCEPT_ALL_OP = 4;
    private static final int INTERSECT_OP = 5;
    private static final int INTERSECT_ALL_OP = 6;

	private Object[]					paramDefaults;
	private String						statementSQLText;
	private NodeFactory					nodeFactory;
	private ContextManager				cm;
	private CompilerContext				compilerContext;

	/* The number of the next ? parameter */
	private int			parameterNumber;

	/* The list of ? parameters */
	private Vector<ValueNode>  parameterList;

	/* Remember if the last identifier or keyword was a
	 * delimited identifier.  This is used for remembering
	 * if the xxx in SERIALIZE(xxx) was a delimited identifier
	 * because we need to know whether or not we can convert
	 * xxx to upper case if we try to resolve it as a class
	 * alias at bind time.
	 */
	private Boolean lastTokenDelimitedIdentifier = Boolean.FALSE;
	private Boolean	nextToLastTokenDelimitedIdentifier = Boolean.FALSE;


	/*
	** Remember the last token we got that was an identifier
	*/	
	private Token	lastIdentifierToken;
	private Token	nextToLastIdentifierToken;

	static final String SINGLEQUOTES = "\'\'";
	static final String DOUBLEQUOTES = "\"\"";
	static final String DOUBLEBACKTICK = "``";

// GemStone changes BEGIN
    static final String DEFAULT_INDEX_TYPE = GfxdConstants.LOCAL_SORTEDMAP_INDEX_TYPE; //   "BTREE";
    private boolean isPartitionOrColocateWithDefined = false;
    private boolean gfxdSubactivationNeeded = false;
    private ArrayDeque<List<Integer>> subqueryParamCount = null;
    private ArrayDeque<List<ConstantNode>> subqueryParams = null;
    /* The number of the next constant in DML */
    private int         constantNumber = 0;
    String prevDiskStore = null;
    String prevHDFSStore = null;
    String prevPersistenceModeSet = null;
    private Token lookAhead;
    private int expirationFlag = 0;    // 1, 2, 3, 4 depending on expiration choice (non-repeating but not mutually exclusive)
    private int evictionChoice = 0;    // 0 for no eviction, 1 for some eviction clause (clauses are mutually exclusive)
// GemStone Changes END

	//the following 2 booleans are used to make sure only null or not null is
	//defined for a column while creating a table or altering a table. Defining
	//both at the same time will be an error case.
	//Also used to check if NULL is specified twice or NOT NULL specified twice
        boolean explicitNotNull = false;
        boolean explicitNull = false;

	//this vector keeps a list of explicitly nullable columns, so that if they
	//get used in the table level primary key constraint, it will result in an
	//exception.	
        Vector explicitlyNullableColumnsList = new Vector();
        

	final void setCompilerContext(CompilerContext cc) {
		this.compilerContext = cc;
		this.cm = cc.getContextManager();
	}
// GemStone changes BEGIN

    // Helper function to add a key/value to a Map object but
    // throw exception if key already set
    // Used to disallow multiple uses of same keyword/value setting
    final void addToMapAllowOnce(Map map, Object key, Object value) throws StandardException
    {
      if (map.put(key, value) != null)
	  {
	     // TODO : LANG_DUPLICATE_PROPERTY is not exactly correct, should make
	     // new SQLCODE as grammar does not explicitly disallow multiple uses
	     // of optional unordered key/value pairs
		 throw StandardException.newException(SQLState.LANG_DUPLICATE_PROPERTY, key);
	  }
	}
				
	final void setGfxdSubactivationFlag(boolean flag) {
		this.gfxdSubactivationNeeded = flag;
	}

	final void setGFAttributes(Properties properties,
	                           AttributesFactory afact,
	                           PartitionAttributesFactory pafact,
	                           DistributionDefinitionNode distributionNode,
	                           boolean[] repPartPersFlags,
	                           boolean isQueryExpressionCase,
	                           TableName tableName,
	                           ServerGroupsTableAttribute serverGroups,
	                           InitSizeTableAttribute initSize) throws StandardException
	{

	  String concFlag = System.getProperty(GfxdConstants.TEST_FLAG_ENABLE_CONCURRENCY_CHECKS);
	  boolean concChecksFlag = false;
	  // [sjigyasu] If test flag is not provided (or is provided and set to true),
	  // concChecksFlag becomes true and makes concurrency checks enabled for persistent partitioned tables.
	  // If test flag is provided and is set to false, concurrency checks flag is NOT set to true for
	  // partitioned tables.
	  concChecksFlag = (concFlag == null) || (concFlag != null && (Boolean.valueOf(concFlag) == Boolean.TRUE)); 
	  
	  if (repPartPersFlags[0] && repPartPersFlags[1])
	  {
	    throw StandardException.newException(SQLState.LANG_INVALID_TABLE_TYPE_DEFINITION);	    
	  }
	  
	  if ((!repPartPersFlags[5] && repPartPersFlags[6])) {
	    throw StandardException
	      .newException(SQLState.EVICTION_BY_CRITERIA_NOT_SUPPORTED_WITH_NON_HDFS_TABLE);
	  }
      if ((repPartPersFlags[4] && repPartPersFlags[5])) {
        throw StandardException
          .newException(SQLState.LRU_EVICTION_NOT_SUPPORTED_FOR_HDFS_TABLE);  
      }
          
	  RegionAttributes attrs;
	  distributionNode.setPersistence(false);
	  //TODO:ASIF: TEST HOOK CODE , NEEDS TO BE REMOVED AFTER QA IS OK WITH IT 
 	  boolean testFlagOffHeap = Boolean.getBoolean("gemfirexd.TEST_FLAG_OFFHEAP_ENABLE");
 	  String offHeapMemorySize = System.getProperty("gemfire."+DistributionConfig.OFF_HEAP_MEMORY_SIZE_NAME);
 	  if(offHeapMemorySize == null || offHeapMemorySize.trim().equals("")) {
 	    offHeapMemorySize = Misc.getGemFireCache().getDistributedSystem().getConfig().getOffHeapMemorySize();
 	  }
	  if ( !(GfxdConstants.SYS_TABLENAME_STRING.equals(tableName.getTableName()) || tableName.getTableName().startsWith("SYS") 
	   || !testFlagOffHeap  || (offHeapMemorySize == null  || offHeapMemorySize.trim().equals("")) )) {
         afact.setEnableOffHeapMemory(true);  
      }

      // set LRU_HEAP eviction for custom EVICTION BY CRITERIA
      if (repPartPersFlags[6] && repPartPersFlags[2]) {
        afact.setEvictionAttributes(EvictionAttributes.createLRUHeapAttributes(
            ObjectSizer.DEFAULT, EvictionAction.OVERFLOW_TO_DISK));
      }

	  //////////////////////////////////////////////
	  final LanguageConnectionContext lcc = getLanguageConnectionContext();
	  if (lcc.isDefaultPersistent() && !repPartPersFlags[2]) {
	    repPartPersFlags[2] = true;
	    if (Misc.isSnappyHiveMetaTable(lcc.getDefaultSchema().getSchemaName()) &&
	        lcc.isPersistMetaStoreInDataDictionary()) {
	      afact.setDiskStoreName(GfxdConstants.GFXD_DD_DISKSTORE_NAME);
	    } else {
	      afact.setDiskStoreName(GfxdConstants.GFXD_DEFAULT_DISKSTORE_NAME);
	    }
	  }

	  if (repPartPersFlags[1] && repPartPersFlags[2]) {
	    afact.setDataPolicy(DataPolicy.PERSISTENT_PARTITION);
	    distributionNode.setPersistence(true);
	    // [sjigyasu] Create versioned region entries for persistent partitioned tables
            if (concChecksFlag && !repPartPersFlags[7]) {
              afact.setConcurrencyChecksEnabled(true);
           }
	  }
        if (repPartPersFlags[0]) {
          if (repPartPersFlags[2]) {
            // Catch the exception from Gemfire data policy code if
            // This region was already set to PARTITIONED by use of clauses in CREATE TABLE DDL.
            try {
              afact.setDataPolicy(DataPolicy.PERSISTENT_REPLICATE);
            }
            catch (IllegalArgumentException e)
            {
              throw StandardException.newException(SQLState.LANG_INVALID_TABLE_TYPE_DEFINITION);
            }
            distributionNode.setPersistence(true);
	    }
          else {
            // Catch the exception from Gemfire data policy code if
            // This region was already set to PARTITIONED by use of clauses in CREATE TABLE DDL.
            try {
              afact.setDataPolicy(DataPolicy.REPLICATE);
            }
            catch (IllegalArgumentException e)
            {
              throw StandardException.newException(SQLState.LANG_INVALID_TABLE_TYPE_DEFINITION);
            }
	    }
	    afact.setScope(Scope.DISTRIBUTED_ACK);
	    attrs = getAttributesFromFactory(afact);
	  }
	  //LOCAL clause in create table
	  else if (repPartPersFlags[3]) {
          afact.setDataPolicy(DataPolicy.NORMAL);
          afact.setScope(Scope.LOCAL);
          attrs = getAttributesFromFactory(afact);
	  }
	  // No explicit policy defined. The table can be replicated or
	  // partitioned depending on system/boot property.
	  else if (!Misc.getMemStore().isTableDefaultPartitioned()
	           && (pafact == null || pafact.create()
	               .getPartitionResolver() == null)) {
	    // See if persistence is enabled.
	    if (repPartPersFlags[2]) {
              // Catch the exception from Gemfire data policy code if
              // This region was already set to PARTITIONED by use of clauses in CREATE TABLE DDL.
              try {
                afact.setDataPolicy(DataPolicy.PERSISTENT_REPLICATE);
              }
              catch (IllegalArgumentException e)
              {
                throw StandardException.newException(SQLState.LANG_INVALID_TABLE_TYPE_DEFINITION);
              }
	      distributionNode.setPersistence(true);
	    }
	    else {
              // Catch the exception from Gemfire data policy code if
              // This region was already set to PARTITIONED by use of clauses in CREATE TABLE DDL.
              try {
                afact.setDataPolicy(DataPolicy.REPLICATE);
              }
              catch (IllegalArgumentException e)
              {
                throw StandardException.newException(SQLState.LANG_INVALID_TABLE_TYPE_DEFINITION);
              }
	    }
	    afact.setScope(Scope.DISTRIBUTED_ACK);
	    attrs = getAttributesFromFactory(afact);
	  }
	  else {
	    //HDFS store is set
	    if (repPartPersFlags[5]) {
	      if (repPartPersFlags[2]) {
			afact.setDataPolicy(DataPolicy.HDFS_PERSISTENT_PARTITION);
			distributionNode.setPersistence(true);
	    	// [sjigyasu] Create versioned region entries for persistent partitioned tables
	    	if (concChecksFlag && !repPartPersFlags[7]) {
      			afact.setConcurrencyChecksEnabled(true);
      		}
	      }
	      else {
			afact.setDataPolicy(DataPolicy.HDFS_PARTITION);
	      }
	    } else {
	      // See if persistence is enabled.
	      if (repPartPersFlags[2]) {
			afact.setDataPolicy(DataPolicy.PERSISTENT_PARTITION);
			distributionNode.setPersistence(true);
		    // [sjigyasu] Create versioned region entries for persistent partitioned tables
		     if (concChecksFlag && !repPartPersFlags[7]) {
    	  		afact.setConcurrencyChecksEnabled(true);
    	  	}
	      }
	    }
	    if (!repPartPersFlags[1]) {
	     // Create a default partitioned table when neither
		 // REPLICATE nor partitioning has been explicitly specified
		 GfxdPartitionByExpressionResolver resolver = new GfxdPartitionByExpressionResolver();
		 TableName colocatedTable =
		   distributionNode.getColocatedTable();
		 if (colocatedTable != null) {
		   resolver.setMasterTable(
		     colocatedTable.getFullTableNameAsRegionPath());
		 }
		 pafact.setPartitionResolver(resolver);
		 afact.setPartitionAttributes(getPartitionAttributesFromFactory(pafact));
		 attrs = getAttributesFromFactory(afact);
	   }
	   else {
		 afact.setPartitionAttributes(getPartitionAttributesFromFactory(pafact));
		 attrs = getAttributesFromFactory(afact);
	   }
	 }


	 properties.put(GfxdConstants.REGION_ATTRIBUTES_KEY, attrs);
	 String encoderClass = distributionNode.getRowEncoderClass();
	 if (encoderClass != null) {
	   properties.put(GfxdConstants.TABLE_ROW_ENCODER_CLASS_KEY, encoderClass);
	 }
	 String schemaName = tableName.getSchemaName();
	 if (schemaName == null || schemaName.length() == 0) {
	   schemaName = getLanguageConnectionContext().
	    getDefaultSchema().getSchemaName();
	 }
	 properties.put(GfxdConstants.PROPERTY_SCHEMA_NAME, schemaName);
	 properties.put(GfxdConstants.PROPERTY_TABLE_NAME,
	 tableName.getTableName());
	 if (serverGroups != null) {
	   distributionNode.setServerGroups(
	   serverGroups.getServerGroupSet());
	 }
	 if (initSize != null) {
	   properties.put(GfxdConstants.REGION_INITSIZE_KEY, initSize);
	 }
	 distributionNode.setTableProperties(properties);
	}
// GemStone changes END
	/**
	  *	Get the NodeFactory for this database.
	  *
	  *	@return	The NodeFactory for this database.
	  * @exception StandardException		Thrown on error
	  */
	private	final NodeFactory	getNodeFactory()	throws StandardException
	{
		if ( nodeFactory == null )
		{
			nodeFactory = getCompilerContext().getNodeFactory();
		}

		return	nodeFactory;
	}

	private final CompilerContext getCompilerContext()
	{		
		return compilerContext;			
	}

	private DataTypeDescriptor getDataTypeServices(int type, int precision, int scale,
			int length)
        throws StandardException
	{
		return new DataTypeDescriptor(
					TypeId.getBuiltInTypeId(type),
					precision,
					scale,
					true, /* assume nullable for now, change it if not nullable */
					length
				);
	}

	private DataTypeDescriptor getJavaClassDataTypeDescriptor(TableName typeName) 
        throws StandardException
	{
		return new DataTypeDescriptor
            (
                TypeId.getUserDefinedTypeId( typeName.getSchemaName(), typeName.getTableName(), null ),
                true
            );
	}
	private LanguageConnectionContext getLanguageConnectionContext()
	{
		return (LanguageConnectionContext) getContextManager().getContext(
										LanguageConnectionContext.CONTEXT_ID);
	}

	/**
		Utility method for checking that the underlying database has been
		upgraded to the required level to use this functionality. Used to
		disallow SQL statements that would leave on-disk formats that would
		not be understood by a engine that matches the current upgrade level
		of the database. Throws an exception if the database is not a the required level.
		<P>
		Typically used for CREATE statements at the parser level. Called usually just
		before the node is created, or can be called in just a partial syntax fragment
		
		@param version Data Dictionary major version (DataDictionary.DD_ constant)
		@param feature SQL Feature name, for error text.
	*/
	private void checkVersion(int version, String feature) throws StandardException
	{
		getLanguageConnectionContext().getDataDictionary().checkVersion(
				version, feature);
	}

    /**
		Utility method for checking that the underlying database uses SQL standard
		permission checking (GRANT/REVOKE).

		@param command "GRANT", "REVOKE", "CREATE/DROP/SET ROLE" or CURRENT_ROLE
    */
	private void checkSqlStandardAccess( String command) throws StandardException
	{
		if( getLanguageConnectionContext().usesSqlAuthorization())
			return;

		throw StandardException.newException(SQLState.LANG_GRANT_REVOKE_WITH_LEGACY_ACCESS,
											command,
											com.pivotal.gemfirexd.Property.SQL_AUTHORIZATION,
											"TRUE");
	}


	/**
		Check that the current mode supports internal extensions.

		@param feature Description of feature for exception.

		@exception StandardException current mode does not support statement
	*/
	private void checkInternalFeature(String feature) throws StandardException
	{
		CompilerContext cc = getCompilerContext();
		if ((cc.getReliability() & CompilerContext.INTERNAL_SQL_ILLEGAL) != 0)
			throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, feature);
	}

	/**
	 * check if the type length is ok for the given type.
	 */
	private void checkTypeLimits(int type, int length)
		throws StandardException
	{	
	boolean valid = true;

		
	switch (type) {
		case Types.BINARY:
		case Types.CHAR:
			if (length  > Limits.DB2_CHAR_MAXWIDTH)
				valid = false;
			break;
			
		case Types.VARBINARY:
		case Types.VARCHAR:
			if (length  > Limits.DB2_VARCHAR_MAXWIDTH)
				valid = false;

			break;
		default:
			break;
	}
	if (!valid)  // If these limits are too big 
		{
			// Do not construct an illegal DTD just to report this error
			// Make a string on the fly which describes the data type
			String errString = Util.typeName(type) + "(" + length + ")";

            throw StandardException.newException(SQLState.LANG_DB2_LENGTH_PRECISION_SCALE_VIOLATION, errString);
		}	
	}
	
	

	// Get the current ContextManager
	private final ContextManager getContextManager()
	{
		return cm;
	}

	/*
	** Compress 2 adjacent (single or double) quotes into a single (s or d) quote when
	** found in the middle of a String.
	** NOTE:  """" or '''' will be compressed into "" or ''.
	** 		  This function assumes that the leading and trailing quote from a
	** 		  string or delimited identifier have already been removed.
	*/
	private static String compressQuotes(String source, String quotes)
	{
        String  result = source;
        int     index;
    
        /* Find the first occurrence of adjacent quotes. */
        //GemStone changes BEGIN
        /*originally 
         * now that token.image in UCode_CharStream.GetImage(..) trims off first and last 
         * characters of a string (quotes enclosing string), need to adjust here accordingly.
         * index = result.indexOf(quotes, 1);
         */
        index = result.indexOf(quotes);
        
        /* Replace each occurrence with a single quote and begin the
         * search for the next occurrence from where we left off.
         */
        while (index != -1 && index != source.length())
        {
            //GemStone changes BEGIN
            /*originally 
             * result = result.substring(0, index + 1) + result.substring(index + 2);
             */
             result = result.substring(0, index) + result.substring(index + 1);
            //GemStone changes END
            
             index = result.indexOf(quotes, index + 1);
        }

        return result;
	}
	
	private static void verifyImageLength(String image) throws StandardException
		{
		// beetle 2758.  For right now throw an error for literals > 64K
		if (image.length() > MAX_UTF8_LENGTH)
			{
	   	       throw StandardException.newException(SQLState.LANG_INVALID_LITERAL_LENGTH);
			}	
		}

	/*
	** Converts a delimited id to a canonical form.
	** Post process delimited identifiers to eliminate leading and
	** trailing " and convert all occurrences of "" to ".
	*/
	private static String normalizeDelimitedID(String str, boolean backTickDelim)
	{
		str = compressQuotes(str, backTickDelim ? DOUBLEBACKTICK : DOUBLEQUOTES);
		// All identifiers are case-insensitive in snappy-store.
		// Case-sensitivity only depends on Spark session setting during query execution
		// and not for storage and will be determined by Spark-side catalog if required.
		return Misc.getMemStoreBooting().isSnappyStore()
			? StringUtil.SQLToUpperCase(str) : str;
	}

	private static boolean isDATETIME(int val)
	{
		if (val == DATE || val == TIME || val == TIMESTAMP)
			return true;
		else
			return false;
	}

	/*
	 * Generate a multiplicative operator node, if necessary.
	 *
	 * If there are two operands, generate the multiplicative operator
	 * that corresponds to the multiplicativeOperator parameter.  If there
	 * is no left operand, just return the right operand.
	 *
	 * @param leftOperand	The left operand, null if no operator
	 * @param rightOperand	The right operand
	 * @param multiplicativeOperator	An identifier from BinaryOperatorNode
	 *									telling what operator to generate.
	 *
	 * @return	The multiplicative operator, or the right operand if there is
	 *			no operator.
	 *
	 * @exception StandardException		Thrown on error
	 */

	ValueNode multOp(ValueNode leftOperand,
							ValueNode rightOperand,
							int multiplicativeOperator)
					throws StandardException
	{
		if (leftOperand == null)
		{
			return rightOperand;
		}

		switch (multiplicativeOperator)
		{
		  case BinaryOperatorNode.TIMES:
			return (ValueNode) nodeFactory.getNode(
									C_NodeTypes.BINARY_TIMES_OPERATOR_NODE,
									leftOperand,
									rightOperand, 
									getContextManager());

		  case BinaryOperatorNode.DIVIDE:
			return (ValueNode) nodeFactory.getNode(
									C_NodeTypes.BINARY_DIVIDE_OPERATOR_NODE,
									leftOperand,
									rightOperand,
									getContextManager());
		  case BinaryOperatorNode.CONCATENATE:
			return (ValueNode) nodeFactory.getNode(
									C_NodeTypes.CONCATENATION_OPERATOR_NODE,
									leftOperand,
									rightOperand,
									getContextManager());

		  default:
			if (SanityManager.DEBUG)
			SanityManager.THROWASSERT("Unexpected multiplicative operator " + 
										multiplicativeOperator);
			return null;
		}
	}

	/**
	 * Set up and like the parameters to the descriptors.
	 * Set all the ParameterNodes to point to the array of
	 * parameter descriptors.
	 * 
	 *	@exception	StandardException
	 */
	 private void setUpAndLinkParameters()
			throws StandardException
	 {
        CompilerContext cc = getCompilerContext();
		cc.setParameterList(parameterList);
		/* Link the untyped parameters to the array of parameter descriptors */
		
		DataTypeDescriptor[] descriptors = cc.getParameterTypes();
		List<TypeCompiler> origTCs = cc.getOriginalParameterTypeCompilers();
		TypeCompilerFactory tcf = cc.getTypeCompilerFactory();
      
		ParameterNode				newNode;
		ParameterNode				oldNode;
		int							paramCount;

		/*
		** Iterate through the list of untyped parameter nodes, set each one
		** to point to the array of parameter descriptors.
		*/
		paramCount = -1;
		int plSize = parameterList.size();
		for (int index = 0; index < plSize; index++)
		{
			paramCount++;

			//GemStone changes BEGIN
			/*(original code) 
			newNode = (ParameterNode) parameterList.elementAt(index);
			newNode.setDescriptors(descriptors );*/
                        Object o = parameterList.elementAt(index);
                        if(o instanceof ParameterizedConstantNode) {
                        ParameterizedConstantNode pcn = (ParameterizedConstantNode)o;
                          pcn.setDescriptors(descriptors);                          
                          origTCs.set(pcn.getConstantNumber(), tcf.getTypeCompiler(pcn.getTypeServices().getTypeId()));
                          
                        }
                        else {
                          // don't allow Parameters in a statement.
                          if (!cc.isPreparedStatement()) {
                            throw StandardException.newException(
                              SQLState.LANG_MISSING_PARMS,
                              index + 1, this.statementSQLText);
                          }
                          
                          assert (o instanceof ParameterNode);
                          ((ParameterNode) o).setDescriptors(descriptors);
                        }
			//GemStone changes END
		}
	}

	/**
	 *  Initializes the list of unnamed parameters, i.e., "?" parameters
	 *
	 *	Usually, this routine just gets an empty list for the unnamed parameters.
	 *
	 *
	 */
	void	initUnnamedParameterList()
	{
		parameterList = new Vector<ValueNode>();
	}

	/**
	 * Makes a new unnamed ParameterNode and chains it onto parameterList.
	 *
	 *	@return	new unnamed parameter.
	 *
	 *	@exception	StandardException
	 */
	ParameterNode	makeParameterNode(  )
					throws StandardException
	{
		ParameterNode	parm;
		DataValueDescriptor sdv = null;

		if ((paramDefaults != null) && (parameterNumber < paramDefaults.length))
		{
			sdv = (DataValueDescriptor) paramDefaults[parameterNumber];
		}
//		GemStone changes begin
		Integer paramInteger = ReuseFactory.getInteger(parameterNumber);

		parm = (ParameterNode) nodeFactory.getNode(
								C_NodeTypes.PARAMETER_NODE,
								paramInteger,
								sdv,
								getContextManager());


                if(this.subqueryParamCount != null && !this.subqueryParamCount.isEmpty())
                {
                  // List<Integer> params = this.subqueryParamCount.peek();
                   //params.add(paramInteger);
                   //Bug 42697
                  Iterator<List<Integer>> itr = this.subqueryParamCount.iterator();
                  while( itr.hasNext()) {                   
                    itr.next().add(paramInteger);
                  }
                  
                }
                
//		GemStone changes end
		parameterNumber++;
		parameterList.addElement(parm);
		getCompilerContext().addDynamicTokenToList(getToken(0));
		return parm;
	}

	/**
	 * Looks up an unnamed parameter given its parameter number.
	 *
	 *	@param	paramNumber		Number of parameter in unnamed
	 *							parameter list.
	 *
	 *	@return	corresponding unnamed parameter.
	 *
	 */
	ParameterNode	lookupUnnamedParameter( int paramNumber )
	{
		ParameterNode		unnamedParameter;

		unnamedParameter = (ParameterNode) parameterList.elementAt( paramNumber );
		return unnamedParameter;
	}

	/**
	 * Translate a String containing a number into the appropriate type
	 * of Numeric node.
	 *
	 * @exception StandardException		Thrown on error
	 */
	NumericConstantNode getNumericNode(String num, boolean intsOnly)
        throws StandardException
	{
		ContextManager cm = getContextManager();

		// first, see if it might be an integer
		try
		{
			return (NumericConstantNode) nodeFactory.getNode(
										C_NodeTypes.INT_CONSTANT_NODE,
// GemStone changes BEGIN
										// changed to use Integer.valueOf()
										Integer.valueOf(num),
// GemStone changes END
										cm);
		}
		catch (NumberFormatException nfe)
		{
			// we catch because we want to continue on below
		}

		// next, see if it might be a long
		try
		{
			return (NumericConstantNode) nodeFactory.getNode(
										C_NodeTypes.LONGINT_CONSTANT_NODE,
// GemStone changes BEGIN
										// changed to use Long.valueOf()
										Long.valueOf(num),
// GemStone changes END
										cm);
		}
		catch (NumberFormatException nfe)
		{
		        if (intsOnly) {
		                throw nfe;
		            }
		            // else we want to continue on below
		}

		return (NumericConstantNode) nodeFactory.getNode(
									C_NodeTypes.DECIMAL_CONSTANT_NODE,
									num,
									cm);
	}
	/**
	 * Determine whether the current token represents one of
	 * the built-in aliases.
	 *
	 * @return	TRUE iff the current token names a built-in alias
	 */
	private boolean isBuiltInAlias()
	{
		boolean retval = false;

		switch (token.kind)
		{
		  case UCASE:
		  case LCASE:
		  case SQRT:
		  case LOCATE:
		  case ABS:
		  case ABSVAL:
		  case SUBSTR:
		  case MOD:
			retval = true;
			break;

		  default:
			retval = false;
			break;
		}


		return retval;
	}


	/**
	 * Determine whether the next sequence of tokens represents one of
	 * the common (built-in) datatypes.
	 *
	 * @param checkFollowingToken true if additonal token for NATIONAL
	 *        or LONG should be checked
	 * @return	TRUE iff the next set of tokens names a common datatype
	 */
	boolean commonDatatypeName(boolean checkFollowingToken)
	{
	    return commonDatatypeName(1, checkFollowingToken);
	}

	/**
	 * Determine whether the next sequence of tokens represents 
	 * a datatype (could be a common datatype or a schema qualified UDT name).
	 *
	 * @return	TRUE iff the next set of tokens names a datatype
	 */
	boolean dataTypeCheck(int start)
	{
        if ( commonDatatypeName( start, false ) ) { return true; }

        boolean retval = true;

		switch (getToken(start).kind)
		{
		  case COMMA:
		  case LEFT_PAREN:
		  case RIGHT_PAREN:
			retval = false;
            break;
        }

        return retval;
    }

	/**
	 * Determine whether a sequence of tokens represents one of
	 * the common (built-in) datatypes.
	 *
	 * @param checkFollowingToken true if additonal token for NATIONAL
	 *        or LONG should be checked
	 * @param start starting token index of the sequence
	 * @return	TRUE iff the next set of tokens names a common datatype
	 */
	boolean commonDatatypeName(int start, boolean checkFollowingToken)
	{
		boolean retval = false;

		switch (getToken(start).kind)
		{
		  case CHARACTER:
		  case CHAR:
		  case VARCHAR:
		  case NVARCHAR:
		  case NCHAR:
		  case BIT:
		  case NUMERIC:
		  case DECIMAL:
		  case DEC:
		  case INTEGER:
		  case INT:
		  case SMALLINT:
		  case SHORT:
		  case BYTE:
		  case TINYINT:
		  case LONGINT:
		  case FLOAT:
		  case REAL:
		  case DATE:
		  case TIME:
		  case TIMESTAMP:
		  case BOOLEAN:
		  case DOUBLE:
		  case BLOB:
		  case CLOB:
		  case CLOB_STRING:
		  case JSON:
		  case NCLOB:
		  case BINARY: // LARGE OBJECT
		  case XML:
			retval = true;
			break;

		  case LONG:
			if (checkFollowingToken == true)
			{
				switch (getToken(start+1).kind)
				{
				  case VARCHAR:
				  case NVARCHAR:
				  case BINARY:
				  case VARBINARY:
				  case BIT:
					retval = true;
					break;
				  default:
				    retval = true;
				    break;
				}
				break;
			}
			else
			{
				retval = true;
				break;
			}

		  case NATIONAL:
			if (checkFollowingToken == true)
			{
				switch (getToken(start+1).kind)
				{
				  case CHAR:
				  case CHARACTER:
					retval = true;
					break;
				}
				break;
			}
			else
			{
				retval = true;
				break;
			}
		}

		return retval;
	}

	/**
	 * Get a DELETE node given the pieces.
	 *
	 *
	 *	@exception	StandardException
	 */
	 private StatementNode getDeleteNode(FromTable fromTable,
										 TableName tableName,
										 ValueNode whereClause)
		throws StandardException
	{
		FromList   fromList = (FromList) nodeFactory.getNode(
								C_NodeTypes.FROM_LIST,
								getContextManager());

		fromList.addFromTable(fromTable);

		SelectNode resultSet = (SelectNode) nodeFactory.getNode(
										C_NodeTypes.SELECT_NODE,
										null,
										null, 	/* AGGREGATE list */
										fromList, /* FROM list */
					  					whereClause, /* WHERE clause */
										null, /* GROUP BY list */
										null, /* having clause */
                                        Boolean.valueOf(true), /* Dml op */
										getContextManager());

		StatementNode retval =
			(StatementNode) nodeFactory.getNode(
							C_NodeTypes.DELETE_NODE,
							tableName,
							resultSet,
							getContextManager());

		setUpAndLinkParameters();

		return retval;
	}

	/**
	 * Get an UPDATE node given the pieces.
	 *
	 *
	 *	@exception	StandardException
	 */
	 private StatementNode getUpdateNode(FromTable fromTable,
										 TableName tableName,
										 ResultColumnList setClause,
										 ValueNode whereClause)
		throws StandardException
	{
		FromList   fromList = (FromList) nodeFactory.getNode(
								C_NodeTypes.FROM_LIST,
								getContextManager());

		fromList.addFromTable(fromTable);

		SelectNode resultSet = (SelectNode) nodeFactory.getNode(
										C_NodeTypes.SELECT_NODE,
										setClause,
										null, 	/* AGGREGATE list */
										fromList, /* FROM list */
					  					whereClause, /* WHERE clause */
										null, /* GROUP BY list */
										null, /* having clause */
										Boolean.valueOf(true), /* Dml op */
										getContextManager());

		StatementNode retval =
			(StatementNode) nodeFactory.getNode(
							C_NodeTypes.UPDATE_NODE,
							tableName,
							resultSet,
							getContextManager());

		setUpAndLinkParameters();

		return retval;
	}

    /**
     * Generate a trim operator node
     * @param trimSpec one of Leading, Trailing or Both.
     * @param trimChar the character to trim. Can be null in which case it defaults
     * to ' '.
     * @param trimSource expression to be trimmed.
     */
    private ValueNode getTrimOperatorNode(Integer trimSpec, ValueNode trimChar,
        ValueNode trimSource, ContextManager cm) throws StandardException
    {
        if (trimChar == null)
        {
        	trimChar = (CharConstantNode) nodeFactory.getNode(
							C_NodeTypes.CHAR_CONSTANT_NODE,
							" ",
							getContextManager());
        }
        return (ValueNode) nodeFactory.getNode(
							C_NodeTypes.TRIM_OPERATOR_NODE,
							trimSource, // receiver
							trimChar,   // leftOperand.
							null,
							ReuseFactory.getInteger(TernaryOperatorNode.TRIM),
							trimSpec,
							cm == null ? getContextManager() : cm);
    }

    private boolean ansiTrimSpecFollows()
    {
        return (getToken(2).kind == LEADING || getToken(2).kind == TRAILING
                || getToken(2).kind == BOTH);
    }
    
	/**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of a remainingPredicate() rule.
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			remainingPredicate()
	 */
	private boolean remainingPredicateFollows()
	{
		boolean retval = false;

		switch (getToken(1).kind)
		{
		  case EQUALS_OPERATOR:
		  case NOT_EQUALS_OPERATOR:
		  case NOT_EQUALS_OPERATOR2: // !=
		  case LESS_THAN_OPERATOR:
		  case GREATER_THAN_OPERATOR:
		  case LESS_THAN_OR_EQUALS_OPERATOR:
		  case GREATER_THAN_OR_EQUALS_OPERATOR:
		  case IN:
		  case LIKE:
		  case BETWEEN:
		  	retval = true;
			break;

		  case NOT:
		  	switch (getToken(2).kind)
			{
			  case IN:
			  case LIKE:
			  case BETWEEN:
			  	retval = true;
			}
			break;
		}

		return retval;
	}


	/**
	 * Determine whether the next token is a DROP
	 *
	 * @return	TRUE iff the next token is DROP
	 */
	private boolean dropFollows()
	{
		if (getToken(1).kind == DROP)
		{ return true; }
		else { return false; }
	}

	/**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of a escapedValueFunction().
	 *
	 * We check only for the punctuation here, because identifiers are
	 * very hard to check for in semantic lookahead.
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			escapedValueFunction()
	 */
	private boolean escapedValueFunctionFollows()
	{
		if (getToken(1).kind != LEFT_BRACE)
		{
			return false;
		}

		return getToken(2).kind == FN;
	}
	

    /**
       List of JDBC escape functions that map directly onto
       a function in the SYSFUN schema.
    */
	private static final String[] ESCAPED_SYSFUN_FUNCTIONS =
        {"ACOS", "ASIN", "ATAN", "COS", "SIN", "TAN", "PI",
         "DEGREES", "RADIANS", "EXP", "LOG", "LOG10", "CEILING", "FLOOR",
         "SIGN", "RAND", "COT", "DSID" };
       
    /**
       Convert a JDBC escaped function name to a function
       name in the SYSFUN schema. Returns null if no such
       function exists.
    */  
	private String getEscapedSYSFUN(String name)
	{
	    name = StringUtil.SQLToUpperCase(name);
	    
	    for (int i = 0; i < ESCAPED_SYSFUN_FUNCTIONS.length; i++)
	    {
	        if (ESCAPED_SYSFUN_FUNCTIONS[i].equals(name))
	            return name;
	    }
	    return null;
	}

	/**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of a columnInvocation() rule.  columnInvocations start with
	 * [ [ id . ] id . ] id . id (
	 *
	 * We check only for the punctuation here, because identifiers are
	 * very hard to check for in semantic lookahead.
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			columnInvocation()
	 */
	private boolean columnMethodInvocationFollows()
	{
		int tokKind;

		// First token must not be a built-in function name that can be
		// followed immediately by a PERIOD. There are only a few of
		// these - most built-in functions have a LEFT_PAREN following
		// the function name.

		// if we run out of token, it's probably a syntax error,  
		// in fact
		tokKind = getToken(1).kind;
		if ( tokKind == EOF ) { return false; }                
		
		// disambiguate from named parameter reference
		if ( getToken(1).image.charAt(0) == '?' ) { return false; }

		if (tokKind == CURRENT_DATE ||
			tokKind == CURRENT_TIME ||
			tokKind == CURRENT_TIMESTAMP ||
			tokKind == CURRENT && (isDATETIME(getToken(2).kind)) )
		{
			return false;
		}

		// Second token must be a PERIOD
		if (getToken(2).kind != PERIOD)
		{
			return false;
		}

		// We have established that we start with " id . "
		tokKind = getToken(4).kind;
		if (tokKind == LEFT_PAREN)
		{
			// id.id(
			return true;
		}

		// Not id.id(, so 4th token must be PERIOD
		if (tokKind != PERIOD)
		{
			return false;
		}

		tokKind = getToken(6).kind;
		if (tokKind == LEFT_PAREN)
		{
			// id.id.id(
			return true;
		}

		// Not id.id.id(, so 6th token must be PERIOD
		if (tokKind != PERIOD)
		{
			return false;
		}

		tokKind = getToken(8).kind;
		if (tokKind == LEFT_PAREN)
		{
			// id.id.id.id(
			return true;
		}

		return false;
	}

	/**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of an aggregateNode()() rule.  aggregateNodes() start with one
	 * of the built-in aggregate names, or with an identifier followed
	 * by "( DISTINCT". A non-distinct user-defined aggregate invocation
	 * is treated as a staticMethodInvocationAlias() by the parser,
	 * and the binding phase figures out what it really is by looking
	 * at the data dictionary.
	 *
	 * We check only for the punctuation here, because identifiers are
	 * very hard to check for in semantic lookahead.
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			aggregateNode()
	 */
	private boolean aggregateFollows()
	{
		boolean retval = false;

		switch (getToken(1).kind)
		{
		  case MAX:
		  case AVG:
		  case MIN:
		  case SUM:
			// This is a built-in aggregate
			retval = true;
			break;

		  case COUNT:
			// COUNT is not a reserved word
			// This may eclipse use of COUNT as a function or a procedure that is probably what we want
		  	if (getToken(2).kind == LEFT_PAREN)
				retval = true;
		  default:
			// Not a built-in aggregate - assume the first token is an
			// identifier, and see whether it is followed by " ( DISTINCT "
		  	if (getToken(2).kind == LEFT_PAREN && getToken(3).kind == DISTINCT)
				retval = true;
			break;
		}

		return retval;
	}

	/**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of a miscBuiltins().
	 *
	 * We check only for the punctuation here, because identifiers are
	 * very hard to check for in semantic lookahead.
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			aggregateNode()
	 */
	private boolean miscBuiltinFollows()
	{
		boolean retval = false;
		int tokKind = getToken(1).kind;
		
		if (getToken(0).kind == CALL) 
			retval = true;

		switch (tokKind)
		{
		  case GET_CURRENT_CONNECTION:
		  case CURRENT_DATE:
		  case CURRENT_TIME:
		  case CURRENT_TIMESTAMP:
		  	retval = true;
			break;

		  case CURRENT:
			if (isDATETIME(getToken(2).kind)) 
		  		retval = true;
			break;
	
		  case CAST:
		  case LEFT_PAREN:
		  	retval = false;
			break;

		  default:
		    if (getToken(2).kind == LEFT_PAREN)
				retval = true;
			break;
		}

		return retval;
	}

	/**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of a subquery. A subquery can begin with an arbitrary number of
	 * left parentheses, followed by either SELECT or VALUES.
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			subquery.
	 */
	private boolean subqueryFollows()
	{
		int tokKind;
		boolean retval = false;

		for (int i = 1; true; i++)
		{
			tokKind = getToken(i).kind;
			if (tokKind == LEFT_PAREN)
			{
				// A subquery can start with an arbitrary number of left
				// parentheses.
				continue;
			}
			else if (tokKind == SELECT || tokKind == VALUES)
			{
				// If the first token we find after all the left parentheses
				// is SELECT or VALUES, it's a subquery.
				retval = true;
				break;
			}
			else
			{
				// If the first token we find after all the left parentheses
				// is neither SELECT nor VALUES, it's not a subquery.
				break;
			}
		}
        
		return retval;
	}

    /**
     * Determine if we are seeing an offsetClause or the identifier OFFSET
     * (Derby does not make it a reserved word).  "n" must be an integer
     * literal or a dynamic parameter specification.
     *
     * @return true if it is an offsetClause.
     */
    private boolean seeingOffsetClause()
    {
        int nesting = 0;

        // Token number, i == 1: OFFSET
        int i = 2;

        int tokKind = getToken(i).kind;

        // check for integer literal or ? followed by ROW(S)
        if (tokKind == PLUS_SIGN ||
            tokKind == MINUS_SIGN) {

            tokKind = getToken(++i).kind;

            // GemStone changes BEGIN
            /*(original code) if (tokKind == EXACT_NUMERIC) {*/
            if (tokKind == EXACT_NUMERIC || tokKind == QUESTION_MARK) {
            // GemStone changes END

                tokKind = getToken(++i).kind;

                return (tokKind == ROW ||
                        tokKind == ROWS);
            }
        // GemStone changes BEGIN
        /*(original code) } else if (tokKind == EXACT_NUMERIC) {*/
        } else if (tokKind == EXACT_NUMERIC || tokKind == QUESTION_MARK) {
        // GemStone changes END

            tokKind = getToken(++i).kind;

            return (tokKind == ROW ||
                    tokKind == ROWS);
        }

        return false;
    }




	/**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of a rowValueConstructorList. A rowValueConstructorList is a comma-
	 * separated list of expressions enclosed in parentheses. This presents
	 * special problems, because an expression be nested within an
	 * arbitrary number of parentheses. To determine whether a left
	 * parenthesis introduces a rowValueConstructorList or an expression,
	 * we need to find the closing parenthesis, and determine whether
	 * the next token is a comma.
	 *
	 * For example, the following is a rowValueConstructorList:
	 *
	 *		(((1)), 2)
	 *
	 * and the following is just an expression:
	 *
	 *		(((1)))
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			subquery.
	 */
	private boolean rowValueConstructorListFollows()
	{
		int nesting;
		boolean retval = false;

		// A rowValueConstructorList starts with a left parenthesis
		if (getToken(1).kind == LEFT_PAREN)
		{
			// Keep track of the nesting of parens while looking ahead
			nesting = 1;
			for (int i = 2; true; i++)
			{
				int tokKind = getToken(i).kind;

				// Special case for NULL/DEFAULT because they are not allowed in
				// a parenthesized expression, so (null)/(default) must be seen
				// as a rowValueConstructorList with one element.
				if (i == 2 && (tokKind == NULL || tokKind == _DEFAULT))
				{
					retval = true;
					break;
				}

				// There must be a COMMA at nesting level 1 (i.e. outside of
				// the first expression) for it to be a rowValueConstructorList
				if (nesting == 1 && tokKind == COMMA)
				{
					retval = true;
					break;
				}

				// If we run out of tokens before finding the last closing
				// parenthesis, it's not a rowValueConstructorList (it's
				// probably a syntax error, in fact)
				if (tokKind == EOF)
				{
					break;
				}

				// Increase the nesting for each (, and decrease it for each )
				if (tokKind == LEFT_PAREN)
				{
					nesting++;
				}
				else if (tokKind == RIGHT_PAREN)
				{
					nesting--;
				}

				// Don't look any farther than the last closing parenthesis
				if (nesting == 0)
				{
					break;
				}
			}
		}

		return retval;
	}

	/**
	 * Determine whether the next token is the beginning of a propertyList(). 
	 * A properties list is the comment "--gemfirexd-properties" followed by a 
	 * dot-separated list, followed by an =, followed by a value all on that 
	 * comment line. This means that the comment should start with the word
	 * "gemfirexd-properties".
	 *
	 * @return	TRUE iff the next token is gemfirexd-properties 
	 */
	private boolean derbyPropertiesListFollows()
	{
		return 
			getToken(1).kind == GEMFIREXDDASHPROPERTIES;
	}

	/**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of a newInvocation(). A newInvocation() begins with the word "new"
	 * followed by a dot-separated list of identifiers, followed
	 * by a left parenthesis.
	 *
	 * @param startToken	Token to look for new at
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			newInvocation().
	 */
	private boolean newInvocationFollows(int startToken)
	{
		boolean retval = false;

		// newInvocation() starts with the word "new"
		if (getToken(startToken).kind == NEW)
		{
			// Look at every other token. Ignore the identifiers, because
			// they are hard to test for.
			for (int i = 2 + startToken; true; i += 2)
			{
				int tokKind = getToken(i).kind;

				// If we find a left parenthesis without any intervening
				// cruft, we have found a newInvocation()
				if (tokKind == LEFT_PAREN)
				{
					retval = true;
					break;
				}
				else if (tokKind != PERIOD)
				{
					// Anything other than a PERIOD is "cruft"
					break;
				}
			}
		}

		return retval;
	}
	/**
	 * Determine whether the next sequence of tokens is a class name
	 *
	 * @return	TRUE iff the next set of tokens is the java class name
	 */
	boolean javaClassFollows()
	{
		boolean retval = false;

		// Look at every other token. Ignore the identifiers, because
		// they are hard to test for.
		for (int i = 2; true; i += 2)
		{
			int tokKind = getToken(i).kind;

			// If we find a '::' without any intervening
			// cruft, we have found a javaClass
			if (tokKind == DOUBLE_COLON)
			{
				retval = true;
				break;
			}
			else if (tokKind != PERIOD)
			{
				// Anything other than a PERIOD is "cruft"
				break;
			}
		}

		return retval;
	}

	/**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of a FROM newInvocation(). A FROM newInvocation() begins with the words "from new"
	 * followed by a dot-separated list of identifiers, followed
	 * by a left parenthesis.
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			FROM newInvocation().
	 */
	private boolean fromNewInvocationFollows()
	{
		boolean retval = false;

		// FROM newInvocation() starts with the words "from new"
		return (getToken(1).kind == FROM && newInvocationFollows(2));
	}

	/**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of a joinedTableExpression(). A joinedTableExpression() begins
	 * with one of:
	 *
	 *	JOIN
	 *	INNER JOIN
	 *	LEFT OUTER JOIN
	 *	RIGHT OUTER JOIN
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			joinedTableExpression().
	 */
	private boolean joinedTableExpressionFollows()
	{
		boolean retval = false;

		int tokKind1 = getToken(1).kind;
		int tokKind2 = getToken(2).kind;

		if (tokKind1 == JOIN)
		{
			retval = true;
		}
		else if (tokKind1 == INNER && tokKind2 == JOIN)
		{
			retval = true;
		}
		else if ((tokKind1 == LEFT || tokKind1 == RIGHT) && tokKind2 == OUTER)
		{
			if (getToken(3).kind == JOIN)
			{
				retval = true;
			}
		}
		else if ((tokKind1 == LEFT || tokKind1 == RIGHT) && tokKind2 == JOIN)
		{
			retval = true;
		}

		return retval;
	}

	/**
	 * Translate a token for the name of a built-in aggregate to a String
	 * containing an aggregate name.
	 */
	private static String aggName(Token token)
	{
		String	retval = null;

		switch (token.kind)
		{
		  case MAX:
		  	retval = "MAX";
			break;

		  case AVG:
		    retval = "AVG";
			break;

		  case MIN:
		    retval = "MIN";
			break;

		  case SUM:
		    retval = "SUM";
			break;

		  case COUNT:
		    retval = "COUNT";
			break;

		  default:
		  	if (SanityManager.DEBUG)
			{
				SanityManager.THROWASSERT("Unexpected token type in aggName: " +
											token.kind);
			}
			break;
		}

		return retval;
	}

	/**
	 * Translate a token for the name of a built-in aggregate to an
	 * aggregate definition class.
	 */
	private static Class aggClass(Token token)
	{
		Class	retval = null;

		switch (token.kind)
		{
		  case MAX:
		  case MIN:
		  	retval = MaxMinAggregateDefinition.class;
			break;

		  case AVG:
		  case SUM:
		  	retval = SumAvgAggregateDefinition.class;
			break;

		  case COUNT:
		    retval = CountAggregateDefinition.class;
			break;

		  default:
		  	if (SanityManager.DEBUG)
			{
				SanityManager.THROWASSERT("Unexpected token type in aggClass: "
											+ token.kind);
			}
			break;
		}

		return retval;
	}

	/**
	 * Determine whether the next sequence of tokens can be the beginning
	 * of another element in a PROPERTY list. These elements are of the
	 * form:
	 *
	 *		COMMA dot.separated.list = ...
	 *
	 * Look for the COMMA, the dots in the dot-separated list, and the =
	 *
	 * @return	TRUE iff the next set of tokens is the beginning of a
	 *			another element in a PROPERTY list.
	 */
	private boolean anotherPropertyFollows()
	{
		boolean retval = false;

		// Element must start with COMMA
		if (getToken(1).kind == COMMA)
		{
			// Rest of element is dot-separated list with = at end
			int i = 3;
			int tokKind;
			do
			{
				tokKind = getToken(i).kind;

				// If we've found nothing but PERIODs until the EQUALS_OPERATOR
				// it is the beginning of another property list element.
				if (tokKind == EQUALS_OPERATOR)
				{
					retval = true;
					break;
				}

				i += 2;
			} while (tokKind == PERIOD);
		}

		return retval;
	}

	/**
	 * Get one of the several types of create alias nodes.
	 *
	 * @param aliasName	The name of the alias
	 * @param fullStaticMethodName	The full path/method name
	 * @param aliasSpecificInfo	 Information specific to the type of alias being created.
	 * @param aliasType	The type of alias to create
	 * @param delimitedIdentifier	Whether or not to treat the class name
	 *								as a delimited identifier if trying to
	 *								resolve it as a class alias.
	 *
	 * @return	A CreateAliasNode matching the given parameters
	 *
	 * @exception StandardException		Thrown on error
	 */
	StatementNode
	getCreateAliasNode(
		Object aliasName,
		String fullStaticMethodName,
		Object aliasSpecificInfo,
		char aliasType,
		Boolean delimitedIdentifier)
		throws StandardException
	{

		StatementNode aliasNode = (StatementNode) getNodeFactory().getCreateAliasNode
			(
				aliasName,
				fullStaticMethodName,
				aliasSpecificInfo,
				aliasType,
				delimitedIdentifier,
				getContextManager()
			);

		return aliasNode;
	}

	/**
		Create a node for the drop alias/procedure call.
	*/
	StatementNode
	dropAliasNode(Object aliasName, char type
// GemStone changes BEGIN
					,Boolean onlyIfExists
// GemStone changes END
					) throws StandardException
	{

		StatementNode stmt = (StatementNode) nodeFactory.getNode(
								C_NodeTypes.DROP_ALIAS_NODE,
								aliasName,
// GemStone changes BEGIN
								// changed to use valueOf()
								Character.valueOf(type),
								onlyIfExists,
// GemStone changes END
								getContextManager());

		return stmt;
	}

    /**
     * Get a substring node from
     *      - the string
     *      - the start position
     *      - the length
     *      - a boolean values for specifying the kind of substring function
     * @exception StandardException  Thrown on error
     */
    ValueNode getSubstringNode( ValueNode stringValue, ValueNode startPosition, 
                         ValueNode length, Boolean boolVal ) throws StandardException
    {
        return (ValueNode) nodeFactory.getNode(
	    					C_NodeTypes.SUBSTRING_OPERATOR_NODE,
		    				stringValue,
			    			startPosition,
				    		length,
				    		ReuseFactory.getInteger(TernaryOperatorNode.SUBSTRING),
					    	null,
						    getContextManager());
    }

    final public TableName
    qualifiedName(int id_length_limit) throws ParseException, StandardException
    {
	return qualifiedName( C_NodeTypes.TABLE_NAME, id_length_limit);
    }

    private void initStatement( String statementSQLText, Object[] paramDefaults)
        throws StandardException
    {
        /* Do per-statement initialization here */
        parameterNumber = 0;
       this.statementSQLText = statementSQLText;
        this.paramDefaults = paramDefaults;
        nodeFactory = getNodeFactory();
        initUnnamedParameterList();
        this.isPartitionOrColocateWithDefined = false;
        //GemStone changes BEGIN
        this.constantNumber = 0;
        this.prevDiskStore = null;
        this.prevHDFSStore = null;
        this.prevPersistenceModeSet = null;
        this.expirationFlag = 0;    // 1, 2, 3, 4 depending on expiration choice (non-repeating but not mutually exclusive)
        this.evictionChoice = 0;    // 0 for no eviction, 1 for some eviction clause (clauses are mutually exclusive)
        //GemStone changes END
    } // End of initStatement

    private void checkIdentifierLengthLimit( String identifier, int identifier_length_limit) 
        throws StandardException
    {
	if (identifier.length() > identifier_length_limit)
		throw StandardException.newException(SQLState.LANG_IDENTIFIER_TOO_LONG, identifier, String.valueOf(identifier_length_limit));
    }

    private ValueNode getJdbcIntervalNode( int intervalType) throws StandardException
    {
        return (ValueNode) nodeFactory.getNode( C_NodeTypes.INT_CONSTANT_NODE,
                                                ReuseFactory.getInteger( intervalType),
                                                getContextManager());
    }
    
    /**
        Check to see if the required claues have been added
        to a procedure or function defintion.
        
        @param required int array of require clauses
        @param  clauses the array of declared clauses.
    */
    void checkRequiredRoutineClause(int[] required, Object[] clauses)
        throws StandardException
    {
        for (int i = 0; i < required.length; i++)
        {
            int re = required[i];
            if (clauses[re] == null)
            {
                throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR,
				 ROUTINE_CLAUSE_NAMES[re]);
		    }
		}
    }

	boolean isPrivilegeKeywordExceptTrigger(int tokenKind) {
		return (tokenKind == SELECT ||
				tokenKind == DELETE ||
				tokenKind == INSERT ||
				tokenKind == UPDATE ||
				tokenKind == REFERENCES ||
				tokenKind == EXECUTE ||
				tokenKind == ALTER ||
				tokenKind == ALL);
	}
	
	// GemStone changes BEGIN

	/**
	 * Determine whether the next sequence of tokens is a class name
	 *
	 * @return	TRUE iff the next set of tokens is the java class name
	 */
	boolean javaClassFollowsProcedureCall()
	{
		boolean retval = false;

		// Look at every other token. Ignore the identifiers, because
		// they are hard to test for.
		for (int i = 2; true; i += 2)
		{
			int tokKind = getToken(i).kind;

			// If we find a '::' without any intervening
			// cruft, we have found a javaClass
			if (tokKind == DOUBLE_COLON || tokKind == PERIOD || tokKind == DOLLAR)
			{
				retval = true;
				break;
			}
			else
			{
				break;
			}
		}

		return retval;
	}

	private int getIntValue(ValueNode v) throws StandardException {
		Object o = v.getConstantValueAsObject();
		try {
		  int i = Integer.parseInt(o.toString());
		  return i;
		} catch (Exception e) {
			throw StandardException.newException
			  (SQLState.LANG_FORMAT_EXCEPTION, TypeId.INTEGER_NAME, (String)null);
		}
	}

	private long getLongValue(ValueNode v) throws StandardException {
		Object o = v.getConstantValueAsObject();
		try {
		  long l = Long.parseLong(o.toString());
		  return l;
		} catch (Exception e) {
			throw StandardException.newException
			  (SQLState.LANG_FORMAT_EXCEPTION, TypeId.LONGINT_NAME, (String)null);
		}
	}

	private Object infinityDateObj = null;
	private Object infinityTimeObj = null;
	private Object infinityTimestampObj = null;

	//@TODO Neeraj: This needs to be looked into again for a better way of doing this.
	private Object getNullOrDateTypeObj(String betweenNodeType)
	    throws StandardException {
	  if (betweenNodeType.equalsIgnoreCase("date")) {
	    if (this.infinityDateObj == null) {
	      this.infinityDateObj = getLanguageConnectionContext().
	          getDataValueFactory().getDateValue(
	              GfxdConstants.INFINITY_DATE_STR, true);
	    }
	    return this.infinityDateObj;
	  }
	  else if (betweenNodeType.equalsIgnoreCase("time")) {
	    if (this.infinityTimeObj == null) {
	      this.infinityTimeObj = getLanguageConnectionContext().
	          getDataValueFactory().getTimeValue(
	              GfxdConstants.INFINITY_TIME_STR, true);
	    }
	    return this.infinityTimeObj;
	  }
	  else if (betweenNodeType.equalsIgnoreCase("timestamp")) {
	    if (this.infinityTimestampObj == null) {
	      this.infinityTimestampObj = getLanguageConnectionContext().
	          getDataValueFactory().getTimestampValue(
	              GfxdConstants.INFINITY_TIMESTAMP_STR, true);
	    }
	    return this.infinityTimestampObj;
	  }
	  else {
	    return null;
	  }
	}

	private RegionAttributes getAttributesFromFactory(
	    AttributesFactory afact) throws StandardException {
	  try {
	    // set the default capacity for GemFireXD to avoid too many rehashes
	    // during initialization
	    afact.setInitialCapacity(GemFireXDUtils.getDefaultInitialCapacity());
	    //afact.setConcurrencyChecksEnabled(GfxdConstants
	    //    .TABLE_DEFAULT_CONCURRENCY_CHECKS_ENABLED);
	    return afact.create();
	  } catch (IllegalStateException ex) {
	    String msg;
        if(ex.getMessage().contains(LocalizedStrings.HDFSSTORE_IS_USED_IN_NONHDFS_REGION.toLocalizedString())){
          msg = ex.getClass().getName()
              + ": "
              + LocalizedStrings.HDFSSTORE_IS_USED_IN_REPLICATED_TABLE.toLocalizedString();
          throw StandardException.newException(
	        SQLState.HDFS_STORE_NOT_SUPPORTED_FOR_REPLICATE_TABLE, new UnsupportedOperationException(ex), msg);
        }
        throw StandardException.newException(
	        SQLState.LANG_UNEXPECTED_USER_EXCEPTION, ex, ex.toString());
	  }
	}

	private PartitionAttributes getPartitionAttributesFromFactory(
	    PartitionAttributesFactory pafact) throws StandardException {
	  try {
	    return pafact.create();
	  } catch (IllegalStateException ex) {
	    throw StandardException.newException(
	        SQLState.LANG_UNEXPECTED_USER_EXCEPTION, ex, ex.toString());
	  }
	}

	// GemStone changes END
}

PARSER_END(SQLParser)

TOKEN_MGR_DECLS :
{
	void	CommonTokenAction(Token t)
	{
		t.beginOffset = input_stream.getBeginOffset();
		t.endOffset = input_stream.getEndOffset();
	}
	
	int commentNestingDepth = 0;
}

SKIP :
{	/* white space */
	  " "
	| "\t"
	| "\n"
	| "\r"
}

MORE :
{
	"/*" : IN_BRACKETED_COMMENT
}

<IN_BRACKETED_COMMENT> MORE :
{
	"/*" { commentNestingDepth = 1; } : IN_NESTED_BRACKETED_COMMENT
}

<IN_BRACKETED_COMMENT> SKIP :
{
	"*/" : DEFAULT
}

<IN_NESTED_BRACKETED_COMMENT> MORE :
{
	"/*" { commentNestingDepth++; }
}

<IN_NESTED_BRACKETED_COMMENT> MORE :
{
	"*/"
	{ commentNestingDepth--; SwitchTo(commentNestingDepth == 0 ? IN_BRACKETED_COMMENT : IN_NESTED_BRACKETED_COMMENT); }
}

<IN_BRACKETED_COMMENT,IN_NESTED_BRACKETED_COMMENT> MORE :
{
	< ~[] >
}

SKIP :
{	/* comments */
	"--" : IN_COMMENT
}

<IN_COMMENT> SKIP :
{	/* white space */
	  " "
	| "\t"
}

/*
	Check if the comment characters -- are followed by GEMFIREXD-PROPERTIES
	token. 

	If yes, then this comment is providing user-supplied optimizer 
	overrides. There should be keyname=value [,keyname=value] pairs
	after -- GEMFIREXD-PROPERTIES otherwise throw an exception. These
	optimier overrides should be used in correct context only, 
	otherwise, the parser will throw an exception.

	If this comment does not start with DERBY-PROPERTIES, then it is 
	just a regular comment. Skip the comment and move on to the next line.
 */
<IN_COMMENT> MORE [IGNORE_CASE]:
{
// GemStone changes BEGIN
// GemStone changed "DERBY-PROPERTIES" token in comments for
// optimizer hints to "GEMFIREXD-PROPERTIES"
//"D" : LOOKFOR_DE
"G" : LOOKFOR_GE
|
<("\n"|"\r"|"\r\n")?> : DEFAULT
|
//<NOT_D : (~["D"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
<NOT_G : (~["G"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

//<LOOKFOR_DE> MORE [IGNORE_CASE]:
<LOOKFOR_GE> MORE [IGNORE_CASE]:
{
//"E" : LOOKFOR_DER
"E" : LOOKFOR_GEM
|
<("\n"|"\r"|"\r\n")?> : DEFAULT
|
//<NOT_DE : (~["E"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
<NOT_GE : (~["E"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_GEM> MORE [IGNORE_CASE]:
{
"M" : LOOKFOR_GEMF
|
<("\n"|"\r"|"\r\n")?> : DEFAULT
|
<NOT_GEM : (~["M"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_GEMF> MORE [IGNORE_CASE]:
{
"F" : LOOKFOR_GEMFI
|
<("\n"|"\r"|"\r\n")?> : DEFAULT
|
<NOT_GEMF : (~["F"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_GEMFI> MORE [IGNORE_CASE]:
{
"I" : LOOKFOR_GEMFIR
|
<("\n"|"\r"|"\r\n")?> : DEFAULT
|
<NOT_GEMFI : (~["I"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}
// Adding few more tokens to complete GEMFIREXD
<LOOKFOR_GEMFIR> MORE [IGNORE_CASE]:
{
"R" : LOOKFOR_GEMFIRE
|
<("\n"|"\r"|"\r\n")?> : DEFAULT
|
<NOT_GEMFIR : (~["R"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_GEMFIRE> MORE [IGNORE_CASE]:
{
"E" : LOOKFOR_GEMFIREX
|
<("\n"|"\r"|"\r\n")?> : DEFAULT
|
<NOT_GEMFIRE : (~["E"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_GEMFIREX> MORE [IGNORE_CASE]:
{
"X" : LOOKFOR_GEMFIREXD
|
<("\n"|"\r"|"\r\n")?> : DEFAULT
|
<NOT_GEMFIREX : (~["X"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_GEMFIREXD> MORE [IGNORE_CASE]:
{
"D" : LOOKFOR_GEMFIREXDDASH
|
<("\n"|"\r"|"\r\n")?> : DEFAULT
|
<NOT_GEMFIREXD : (~["D"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_GEMFIREXDDASH> MORE [IGNORE_CASE]:
// GemStone changes END
{
"-" : LOOKFOR_DERBYDASHP
|
<("\n"|"\r"|"\r\n")?> : DEFAULT
|
<NOT_DERBYDASH : (~["-"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DERBYDASHP> MORE [IGNORE_CASE]:
{
"P" : LOOKFOR_DERBYDASHPR
|
<("\n"|"\r"|"\r\n")?> : DEFAULT
|
<NOT_DERBYDASHP : (~["P"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DERBYDASHPR> MORE [IGNORE_CASE]:
{
"R" : LOOKFOR_DERBYDASHPRO
|
<("\n"|"\r"|"\r\n")?> : DEFAULT
|
<NOT_DERBYDASHPR : (~["R"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DERBYDASHPRO> MORE [IGNORE_CASE]:
{
"O" : LOOKFOR_DERBYDASHPROP
|
<("\n"|"\r"|"\r\n")?> : DEFAULT
|
<NOT_DERBYDASHPRO : (~["O"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DERBYDASHPROP> MORE [IGNORE_CASE]:
{
"P" : LOOKFOR_DERBYDASHPROPE
|
<("\n"|"\r"|"\r\n")?> : DEFAULT
|
<NOT_DERBYDASHPROP : (~["P"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DERBYDASHPROPE> MORE [IGNORE_CASE]:
{
"E" : LOOKFOR_DERBYDASHPROPER
|
<("\n"|"\r"|"\r\n")?> : DEFAULT
|
<NOT_DERBYDASHPROPE : (~["E"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DERBYDASHPROPER> MORE [IGNORE_CASE]:
{
"R" : LOOKFOR_DERBYDASHPROPERT
|
<("\n"|"\r"|"\r\n")?> : DEFAULT
|
<NOT_DERBYDASHPROPER : (~["R"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DERBYDASHPROPERT> MORE [IGNORE_CASE]:
{
"T" : LOOKFOR_DERBYDASHPROPERTI
|
<("\n"|"\r"|"\r\n")?> : DEFAULT
|
<NOT_DERBYDASHPROPERT : (~["T"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DERBYDASHPROPERTI> MORE [IGNORE_CASE]:
{
"I" : LOOKFOR_DERBYDASHPROPERTIE
|
<("\n"|"\r"|"\r\n")?> : DEFAULT
|
<NOT_DERBYDASHPROPERTI : (~["I"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_DERBYDASHPROPERTIE> MORE [IGNORE_CASE]:
{
"E" : LOOKFOR_GEMFIREXDDASHPROPERTIES
|
<("\n"|"\r"|"\r\n")?> : DEFAULT
|
<NOT_DERBYDASHPROPERTIE : (~["E"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<LOOKFOR_GEMFIREXDDASHPROPERTIES> TOKEN [IGNORE_CASE] :
{	
	<GEMFIREXDDASHPROPERTIES : "GEMFIREXDDASHPROPERTIES"> 
}

//once we find comment starting with -- GEMFIREXD-PROPERTIES, we want to switch 
//from SKIP mode to the TOKEN mode in the parser so the rest of the characters 
//on the comment line can be treated as part of one big token so we can get 
//keyname=value pairs from that token. The reason for treating them as one big
//token is that the existing code in parser allows newline characters between
//individual token but with optimizer overrides, all the properties have to
//be specified on the -- GEMFIREXD-PROPERTIES comment line. 
<LOOKFOR_GEMFIREXDDASHPROPERTIES> TOKEN [IGNORE_CASE]:
{
"S" { matchedToken.kind = GEMFIREXDDASHPROPERTIES; } : PROPERTIES_LIST
}

//We found -- DERBY-PROPERTIE? where ? is a character other than S
//and hence we should the rest of the characters on this line as 
//a regular comment
<LOOKFOR_GEMFIREXDDASHPROPERTIES> SKIP :
{
<("\n"|"\r"|"\r\n")?> : DEFAULT
|
<NOT_PROPERTIES : (~["S","s"])> : IT_IS_NOT_DERBYPROPERTIES_COMMENT
}

<IT_IS_NOT_DERBYPROPERTIES_COMMENT> SKIP :
{
	<SINGLE_LINE_SQLCOMMENT: (~["\n","\r"])* ("\n"|"\r"|"\r\n")?> : DEFAULT
}

//found -- GEMFIREXD-PROPERTIES. Treat rest of the characters on the line
//as one big token and then fetch keyname=value pairs from that token.
<PROPERTIES_LIST> TOKEN :
{
	<CHECK_PROPERTIES: (~["\n","\r"])* ("\n"|"\r"|"\r\n")?> : DEFAULT
}

/*
	This list should contain only and all SQL92 keywords that are reserved.
	Reserved keywords can be used as identifiers in the language only
	as delimited identifiers.
 */
/* NOTE - If you add a keyword, then you must add it to reservedKeyword()
 *	      or nonReservedKeyword() as well!
 */
TOKEN [IGNORE_CASE] :
{	/* SQL92 reserved Keywords */
	<ADD: "add">
|	<ALL: "all">
|	<ALLOCATE: "allocate">
|	<ALTER: "alter">
|	<AND: "and">
|	<ANY: "any">
|	<ARE: "are">
|	<AS: "as">
|	<ASC: "asc">
|	<ASSERTION: "assertion">
|	<AT: "at">
|	<AUTHORIZATION: "authorization">
|	<AVG: "avg">
|	<BEGIN: "begin">
|	<BETWEEN: "between">
|	<BINARY: "binary">
|	<BIT: "bit">
|	<BOTH: "both">
|	<BY: "by">
|	<BYTE: "byte">
|	<CASCADE: "cascade">
|	<CASCADED: "cascaded">
|	<CASE: "case">
|	<CAST: "cast">
|	<CHAR: "char">
|	<CHARACTER: "character">
|	<CHARACTER_LENGTH: "character_length">
|	<CHECK: "check">
|	<CLOSE: "close">
|	<COALESCE: "coalesce">
|	<COLLATE: "collate">
|	<COLLATION: "collation">
|	<COLUMN: "column">
|	<COMMIT: "commit">
|	<CONNECT: "connect">
|	<CONNECTION: "connection">
|	<CONSTRAINT: "constraint">
|	<CONSTRAINTS: "constraints">
|	<CONTINUE: "continue">
|	<CONVERT: "convert">
|	<CORRESPONDING: "corresponding">
|	<COUNT: "count">
|	<CREATE: "create">
|	<CURRENT: "current">
|	<CURRENT_DATE: "current_date">
|	<CURRENT_TIME: "current_time">
|	<CURRENT_TIMESTAMP: "current_timestamp">
|	<CURRENT_USER: "current_user">
|	<CURSOR: "cursor">
|	<D: "d">
|	<DEALLOCATE: "deallocate">
|	<DEC: "dec">
|	<DECIMAL: "decimal">
|	<DECLARE: "declare">
|	<_DEFAULT: "default">
|	<DEFERRABLE: "deferrable">
|	<DEFERRED: "deferred">
|	<DELETE: "delete">
|	<DESC: "desc">
|	<DESCRIBE: "describe">
|	<DIAGNOSTICS: "diagnostics">
|	<DISCONNECT: "disconnect">
|	<DISTINCT: "distinct">
|	<DOUBLE: "double">
|	<DROP: "drop">
|	<ELSE: "else">
|   <EMBED: "embed">
|	<END: "end">
|	<ENDEXEC: "end-exec">
|	<ESCAPE: "escape">
|	<EXCEPT: "except">
|	<EXCEPTION: "exception">
|	<EXEC: "exec">
|	<EXECUTE: "execute">
|	<EXISTS: "exists">
|	<EXTERNAL: "external">
|	<FALSE: "false">
|	<FETCH: "fetch">
|	<FIRST: "first">
|	<FLOAT: "float">
|	<FOR: "for">
|	<FOREIGN: "foreign">
|	<FOUND: "found">
|	<FROM: "from">
|	<FULL: "full">
|	<FUNCTION: "function">
|	<GET: "get">
|	<GLOBAL: "global">
|	<GO: "go">
|	<GOTO: "goto">
|	<GRANT: "grant">
|	<GROUP: "group">
|	<HAVING: "having">
|	<IDENTITY: "identity">
|	<IMMEDIATE: "immediate">
|	<IN: "in">
|	<INDICATOR: "indicator">
|	<INITIALLY: "initially">
|	<INNER: "inner">
|	<INPUT: "input">
|	<INSENSITIVE: "insensitive">
|	<INSERT: "insert">
|	<INT: "int">
|	<INTEGER: "integer">
|	<INTERSECT: "intersect">
|	<INTO: "into">
|	<IS: "is">
|	<ISOLATION: "isolation">
|	<JOIN: "join">
|	<KEY: "key">
|	<LAST: "last">
|	<LEADING: "leading">
|	<LEFT: "left">
|	<LIKE: "like">
|	<LOWER: "lower">
|	<MATCH: "match">
|	<MAX: "max">
|	<MIN: "min">
|	<MODULE: "module">
|	<NATIONAL: "national">
|	<NATURAL: "natural">
|	<NCHAR: "nchar">
|	<NEXT: "next">
|	<NO: "no">
|	<NOT: "not">
|	<NULL: "null">
|	<NULLIF: "nullif">
|	<NUMERIC: "numeric">
|	<OF: "of">
|	<ON: "on">
|	<ONLY: "only">
|	<OPEN: "open">
|	<OPTION: "option">
|	<OR: "or">
|	<ORDER: "order">
|	<OUTER: "outer">
|	<OUTPUT: "output">
|	<OVERLAPS: "overlaps">
|	<PAD: "pad">
|	<PARTIAL: "partial">
|	<PREPARE: "prepare">
|	<PRESERVE: "preserve">
|	<PRIMARY: "primary">
|	<PRIOR: "prior">
|	<PRIVILEGES: "privileges">
|	<PROCEDURE: "procedure">
|	<PUBLIC: "public">
|	<READ: "read">
|	<REAL: "real">
|	<REFERENCES: "references">
|	<RELATIVE: "relative">
|	<RESTRICT: "restrict">
|	<REVOKE: "revoke">
|	<RIGHT: "right">
|	<ROLLBACK: "rollback">
|	<ROWS: "rows">
|	<SCHEMA: "schema">
|	<SCROLL: "scroll">
|	<SELECT: "select">
|	<SESSION_USER: "session_user">
|	<SET: "set">
|	<SHORT: "short">
|	<SMALLINT: "smallint">
|	<SOME: "some">
|	<SPACE: "space">
|	<SQL: "sql">
|	<SQLCODE: "sqlcode">
|	<SQLERROR: "sqlerror">
|	<SQLSTATE: "sqlstate">
|	<SUBSTRING: "substring">
|	<SUM: "sum">
|	<SYSTEM_USER: "system_user">
|	<T: "t">
|	<TABLE: "table">
|	<TEMPORARY: "temporary">
|	<TIMEZONE_HOUR: "timezone_hour">
|	<TIMEZONE_MINUTE: "timezone_minute">
|	<TINYINT: "tinyint">
|	<TO: "to">
|	<TRANSACTION: "transaction">
|	<TRANSLATE: "translate">
|	<TRANSLATION: "translation">
|	<TRAILING: "trailing">
|	<TRIM: "trim">
|	<TRUE: "true">
|	<TS: "ts">
|	<UNION: "union">
|	<UNIQUE: "unique">
|	<UNKNOWN: "unknown">
|	<UPDATE: "update">
|	<UPPER: "upper">
|	<USER: "user">
|	<USING: "using">
|	<VALUE: "value">
|	<VALUES: "values">
|	<VARBINARY: "varbinary">
|	<VARCHAR: "varchar">
|	<VARYING: "varying">
|	<VIEW: "view">
|	<WHENEVER: "whenever">
|	<WHERE: "where">
|	<WITH: "with">
|	<WORK: "work">
|	<WRITE: "write">
}

/*
	This list should contain only and all SQL92 keywords that are non-reserved.
	Non-reserved keywords can be used as identifiers in the language.
	To make that happen, the individual tokens have to be repeated in
	the nonReservedKeyword() rule -- unless there's some other JavaCC shorthand?

	NOTE: I've commented out most of these because we won't be using them
	right away and the grammar is taking forever to process.
 */
/* NOTE - If you add a keyword, then you must add it to reservedKeyword()
 *	      or nonReservedKeyword() as well!
 */
TOKEN [IGNORE_CASE] :
{	/* SQL92 non-reserved Keywords */
    <ABS: "abs">
|    <ABSVAL: "absval">
|	<ACTION: "action">
|	<ALWAYS: "always">
|	<BLOB: "blob">
  |	<C: "c">
  | <CALLED: "called">
|	<CLOB: "clob">
  |	<COBOL: "cobol">
|	<COMMITTED: "committed">
|   <CONCAT: "concat">
|	<CONTAINS: "contains">
|	<DATA: "data">
|	<DATE: "date">
|	<DAY: "day">
|	<DEFINER: "definer">
|   <DYNAMIC: "dynamic">
|	<FORTRAN: "fortran">
|   <GENERATED: "generated">
// mark HOUR as non-reserved (SNAP-1179)
|	<HOUR: "hour">
|	<IDENTITY_VAL_LOCAL: "identity_val_local">
|	<INCREMENT: "increment">
|	<INITIAL: "initial">
|   <INOUT: "inout">
|	<INTERVAL: "interval">
|	<INVOKER: "invoker">
|	<LANGUAGE: "language">
|	<LARGE: "large">
|	<LENGTH: "length">
|	<LEVEL: "level">
|	<LOCKS: "locks">
|	<LOCKSIZE: "locksize">
|	<LOGGED: "logged">
// mark MINUTE as non-reserved (SNAP-1179)
|	<MINUTE: "minute">
|       <MOD: "mod">
|	<MODIFIES: "modifies">
|	<MODIFY: "modify">
|	<MONTH: "month">
|	<_MORE: "more">
|	<MUMPS: "mumps">
|	<NAME: "name">
|	<NCLOB: "nclob">
|	<NULLABLE: "nullable">
|	<NULLS: "nulls">
|	<NUMBER: "number">
|	<OBJECT: "object">
|   <OFFSET: "offset">
|	<PASCAL: "pascal">
|	<PLI: "pli">
|	<PRECISION: "precision">
|	<RELEASE: "release">
|	<REPEATABLE: "repeatable">
|	<RESTART: "restart">
|	<RETURNS: "returns">
|	<ROW: "row">
|	<SAVEPOINT: "savepoint">
|	<SCALE: "scale">
// mark SECOND as non-reserved (SNAP-1179)
|	<SECOND: "second">
|	<SECURITY: "security">
|	<SERIALIZABLE: "serializable">
|	<SQL_TSI_FRAC_SECOND: "sql_tsi_frac_second">
|	<SQL_TSI_SECOND: "sql_tsi_second">
|	<SQL_TSI_MINUTE: "sql_tsi_minute">
|	<SQL_TSI_HOUR: "sql_tsi_hour">
|	<SQL_TSI_DAY: "sql_tsi_day">
|	<SQL_TSI_WEEK: "sql_tsi_week">
|	<SQL_TSI_MONTH: "sql_tsi_month">
|	<SQL_TSI_QUARTER: "sql_tsi_quarter">
|	<SQL_TSI_YEAR: "sql_tsi_year">
|	<START: "start">
|	<STATEMENT: "statement">
|	<SYNONYM: "synonym">
|	<THEN: "then">
|	<TIME: "time">
|	<TIMESTAMP: "timestamp">
|	<TIMESTAMPADD: "timestampadd">
|	<TIMESTAMPDIFF: "timestampdiff">
|	<TRUNCATE: "truncate">
|	<TYPE: "type">
|	<UNCOMMITTED: "uncommitted">
|	<USAGE: "usage">
|	<WHEN: "when">
// GemStone changes BEGIN
// mark YEAR as non-reserved (SNAP-1179)
|	<YEAR: "year">
|	<JSON: "json">
|	<CLOB_STRING: "string">
|	<USE: "use">
// GemStone changes END
}

/*
	The next lists should contain non-SQL92 keywords, and should
	specify whether their keywords are reserved or non-reserved.
	If they are non-reserved, they need to be added to the identifier() rule.

	NOTE: XML, XMLPARSE, XMLSERIALIZE, and XMLEXISTS are considered reserved
	words to comply with the SQL/XML (2003) standard, section 5.1.  Similarly,
	XMLQUERY is a reserved word per SQL/XML (2006).
 */

/* NOTE - If you add a keyword, then you must add it to reservedKeyword()
 *	      or nonReservedKeyword() as well!
 */
TOKEN [IGNORE_CASE] :
{	/* Additional JSQL reserved keywords -- non-SQL92 reserved Keywords */
	<BOOLEAN: "boolean">
|	<CALL: "call">
|	<CURDATE: "curdate">
|	<CURRENT_ROLE: "current_role">
|	<CURTIME: "curtime">
|   <DATABASE: "database">
|	<GET_CURRENT_CONNECTION: "getCurrentConnection">
|	<EXPLAIN: "explain">
|	<LONGINT: "bigint">
|	<LONG: "long">
|	<LTRIM: "ltrim">
|	<NONE: "none">
|	<OVER: "over">
|	<ROLE: "role">
|	<ROW_NUMBER: "row_number">
|	<RTRIM: "rtrim">
|	<SUBSTR:	"substr">
|	<XML:	"xml">
|	<XMLEXISTS:	"xmlexists">
|	<XMLPARSE:	"xmlparse">
|	<XMLQUERY:	"xmlquery">
|	<XMLSERIALIZE:	"xmlserialize">
|	<XMLFRAGMENTS:	"xmlfragments">
}

/* NOTE - If you add a keyword, then you must add it to reservedKeyword()
 *	      or nonReservedKeyword() as well!
 *
 * NOTE: CONTENT, DOCUMENT, STRIP, WHITESPACE and PASSING are considered NON-
 * reserved words to comply with the SQL/XML (2003) standard, section 5.1.
 * Similarly, EMPTY, RETURNING, and SEQUENCE are all considered NON-reserved
 * words per SQL/XML (2006).  PRESERVE is also listed as non-reserved in the
 * SQL/XML spec, but since that word is already reserved, we leave it alone.
 */
TOKEN [IGNORE_CASE] :
{	/* Additional JSQL keywords -- non-SQL92 non-reserved Keywords */
	<AFTER: "after">
|	<BEFORE: "before">
|	<CLASS: "class">
|	<COMPRESS: "compress">
|	<CONTENT: "content">
|   <CS: "cs">
|	<CURSORS: "cursors">
|	<DB2SQL: "db2sql">
|	<DERBY_JDBC_RESULT_SET: "derby_jdbc_result_set">
|       <DIRTY: "dirty">
|	<DOCUMENT: "document">
|	<EACH: "each">
|	<EMPTY: "empty">
|	<EXCLUSIVE: "exclusive">
|	<FN: "fn">
|	<INDEX: "index">
|	<JAVA: "java">
|   <LCASE: "lcase">
|   <LOCATE: "locate">
|	<LOCK: "lock">
|	<MESSAGE_LOCALE: "message_locale">
|	<METHOD: "method">
|	<MODE: "mode">
|	<NEW: "new">
|   <NEW_TABLE: "new_table">
|	<NVARCHAR: "nvarchar"> 
|	<OJ: "oj">
|	<OFF: "off">
|	<OLD: "old">
|   <OLD_TABLE: "old_table">
|   <OUT: "out">
|	<PARAMETER: "parameter">
|	<PASSING: "passing">
|	<PROPERTIES: "properties">
|	<READS: "reads">
|	<REF: "ref">
|	<REFERENCING: "referencing">
|	<RENAME: "rename">
|       <RESET: "reset">
|	<RESULT: "result">
|	<RETAIN: "retain">
|	<RETURNING: "returning">
|   <RR: "rr">
|   <RS: "rs">
|	<SEQUENCE: "sequence">
|	<SEQUENTIAL: "sequential">
|	<SETS: "sets">
|	<SHARE: "share">
|	<SQLID: "sqlid">
|	<SPECIFIC: "specific">
|   <SQRT: "sqrt">
|       <STABILITY: "stability">
|   <STRIP: "strip">
|   <STYLE: "style">
|	<TRIGGER: "trigger">
|   <UCASE: "ucase">
|   <UR: "ur">
|   <WHITESPACE: "whitespace">
// GemStone changes BEGIN
|   <ALIAS: "alias">
|   <ARRAY: "array">
|   <ASYNCHRONOUS: "asynchronous">
|   <BUCKETS: "buckets">
|   <COHORT: "cohort">
|   <COLOCATE: "colocate">
|   <CRITERIA: "criteria">
|   <DECODE: "decode">
|   <DESTROY: "destroy">
|   <DISKDIR: "diskdir">
|   <ENCODER: "encoder">
|   <ENTRY: "entry">
|   <EVICT: "evict">
|   <EVICTACTION: "evictaction">
|   <EVICTION: "eviction">
|   <EXPIRE: "expire">
|   <FREQUENCY: "frequency">
|   <DAYS: "days">
|   <HOURS: "hours">
|   <MINUTES: "minutes">
|   <SECONDS: "seconds">
|   <MILLISECONDS: "milliseconds">
|   <LAST_MODIFIED_DURATION: "last_modified_duration">
|   <LAST_MODIFIED_TIME: "last_modified_time">
|   <LAST_MODIFIED_TIME_MILLIS: "last_modified_time_millis">
|   <ROWID: "rowid">
|   <GROUPS: "groups"> // for server groups
|   <HASH: "hash"> // for CREATE INDEX GLOBAL HASH extension
|   <IDLETIME: "idletime">
|   <IF: "if">
|   <INCOMING: "incoming">
|   <INITSIZE: "initsize">
|   <INFINITY: "infinity">
|   <LDAPGROUP: "ldapgroup">
|   <LIST: "list">
|   <LOADER: "loader">
|   <LOCAL: "local">
|   <LRUCOUNT: "lrucount">
|   <LRUHEAPPERCENT: "lruheappercent">
|   <LRUMEMSIZE: "lrumemsize">
|   <MAXPARTSIZE: "maxpartsize">
|   <MAXSIZE: "maxsize">
|   <NOWAIT: "nowait">
|   <NVL: "nvl">
|   <OVERFLOW: "overflow">
|   <PARTITION: "partition">
|   <PARTITIONER: "partitioner">
|   <PERSISTENT: "persistent">
|   <PROCESSOR: "processor">
|   <RANGE: "range">
|   <RECOVERYDELAY: "recoverydelay">
|   <REDUNDANCY: "redundancy">
|   <REPLICATE: "replicate">
|   <SERVER: "server"> // also for CREATE SCHEMA
|   <STARTUPRECOVERYDELAY: "startupRecoverydelay">
|   <SYNCHRONOUS: "synchronous">
|   <TIMETOLIVE: "timetolive">
|   <ASYNCLISTENER: "asyncEventListener">
|   <DISKSTORE: "diskstore">
|	<HDFSSTORE: "hdfsstore">
| 	<NAMENODE: "namenode">
| 	<HOMEDIR: "homedir">
| 	<BLOCKCACHESIZE: "blockcachesize">
| 	<CLIENTCONFIGFILE: "clientconfigfile">
|   <COMPACTIONTHRESHOLD: "compactionthreshold">
|   <AUTOCOMPACT: "autocompact">
|   <ALLOWFORCECOMPACTION: "allowforcecompaction">
|   <TIMEINTERVAL: "timeinterval">
|   <WRITEBUFFERSIZE: "writebuffersize">
|   <QUEUESIZE: "queuesize">
|   <MAXLOGSIZE: "maxlogsize">
|   <GATEWAYSENDER: "gatewaysender">
|   <REMOTEDSID: "remotedsid">
|   <SOCKETBUFFERSIZE: "socketbuffersize">
|   <MANUALSTART: "manualstart">
|   <SOCKETREADTIMEOUT: "socketreadtimeout">
|   <ENABLEBATCHCONFLATION: "enablebatchconflation">
|   <BATCHSIZE: "batchsize">
|   <DISPATCHERTHREADS: "dispatcherthreads">
|   <BATCHTIMEINTERVAL: "batchtimeinterval">
|   <ENABLEPERSISTENCE: "enablepersistence">
|   <DISKSTORENAME: "diskstorename">
|   <MAXQUEUEMEMORY: "maxqueuememory">
|	<QUEUEPERSISTENT: "queuepersistent">
|   <DISKSYNCHRONOUS: "disksynchronous">
|   <ALERTTHRESHOLD: "alertthreshold">
|   <LISTENERCLASS: "listenerclass">
|   <INITPARAMS: "initparams">
|   <GATEWAYRECEIVER: "gatewayreceiver">
|   <STARTPORT: "startport">
|   <ENDPORT: "endport">
|   <ISPARALLEL: "isparallel">
|   <MAXTIMEBETWEENPINGS: "maxtimebetweenpings">
|   <BINDADDRESS: "bindaddress">
|   <HOSTNAMEFORSENDERS: "hostnameforsenders">
|	<OFFHEAP: "offheap">
|	<MINORCOMPACT: "minorcompact">
|	<MAJORCOMPACT: "majorcompact">
|	<MAXINPUTFILESIZE: "maxinputfilesize">
|	<MININPUTFILECOUNT: "mininputfilecount">
|	<MAXINPUTFILECOUNT: "maxinputfilecount">
|	<MINORCOMPACTIONTHREADS: "minorcompactionthreads">
|	<MAJORCOMPACTIONINTERVAL: "majorcompactioninterval">
|	<MAJORCOMPACTIONTHREADS: "majorcompactionthreads">
|	<PURGEINTERVAL: "purgeinterval">
|	<WRITEONLY: "writeonly">
|   <ENABLE: "enable" >
|   <DISABLE: "disable" >
|   <CONCURRENCY: "concurrency" >
|   <CHECKS: "checks" >
|	<MAXWRITEONLYFILESIZE: "maxwriteonlyfilesize">
|	<WRITEONLYFILEROLLOVERINTERVAL: "writeonlyfilerolloverinterval">
|	<SPARKHASH: "sparkhash">
|	<PUT: "put">

// GemStone changes END
}

TOKEN :
{	/* Operators and punctuation */
	<DOUBLE_QUOTE: "\"">
|	<PERCENT: "%">
|	<AMPERSAND: "&">
|	<QUOTE: "'">
|	<LEFT_BRACE: "{">
|	<RIGHT_BRACE: "}">
|	<LEFT_PAREN: "(">
|	<RIGHT_PAREN: ")">
|	<ASTERISK: "*">
|	<PLUS_SIGN: "+">
|	<COMMA: ",">
|	<MINUS_SIGN: "-">
|	<PERIOD: ".">
|	<SOLIDUS: "/">
|	<COLON: ":">
|	<DOUBLE_COLON: "::">
|	<SEMICOLON: ";">
|	<LESS_THAN_OPERATOR: "<">
|	<LESS_THAN_OR_EQUALS_OPERATOR: "<=">
|	<EQUALS_OPERATOR: "=">
|	<NOT_EQUALS_OPERATOR: "<>">
|	<NOT_EQUALS_OPERATOR2: "!=">
|	<GREATER_THAN_OPERATOR: ">">
|	<GREATER_THAN_OR_EQUALS_OPERATOR: ">=">
|	<QUESTION_MARK: "?">
|	<UNDERSCORE: "_">
|	<VERTICAL_BAR: "|">
|	<LEFT_BRACKET: "[">
|	<RIGHT_BRACKET: "]">
|	<CONCATENATION_OPERATOR: "||">
|	<FIELD_REFERENCE: "->">
// GemStone changes BEGIN
|   <DOLLAR: "$" >
// GemStone changes END
}

TOKEN :
{	/* Identifiers */
	<IDENTIFIER: (<UNDERSCORE>)* ( <LETTER> ) (<LETTER> | <UNDERSCORE> | <DIGIT>)* >
}

TOKEN: {	<K: "K" >	 }
TOKEN: {	<M: "M" >	 }
TOKEN: {	<G: "G" >	 }

TOKEN:
{
	<#LETTER: [
				"a"-"z",
				"A"-"Z",
				"\u00aa",
				"\u00b5",
				"\u00ba",
				"\u00c0" - "\u00d6",
				"\u00d8" - "\u00f6",
				"\u00f8" - "\u01f5",
				"\u01fa" - "\u0217",
				"\u0250" - "\u02a8",
				"\u02b0" - "\u02b8",
				"\u02bb" - "\u02c1",
				"\u02d0" - "\u02d1",
				"\u02e0" - "\u02e4",
				"\u037a",
				"\u0386",
				"\u0388" - "\u038a",
				"\u038c",
				"\u038e" - "\u03a1",
				"\u03a3" - "\u03ce",
				"\u03d0" - "\u03d6",
				"\u03da",
				"\u03dc",
				"\u03de",
				"\u03e0",
				"\u03e2" - "\u03f3",
				"\u0401" - "\u040c",
				"\u040e" - "\u044f",
				"\u0451" - "\u045c",
				"\u045e" - "\u0481",
				"\u0490" - "\u04c4",
				"\u04c7" - "\u04c8",
				"\u04cb" - "\u04cc",
				"\u04d0" - "\u04eb",
				"\u04ee" - "\u04f5",
				"\u04f8" - "\u04f9",
				"\u0531" - "\u0556",
				"\u0559",
				"\u0561" - "\u0587",
				"\u05d0" - "\u05ea",
				"\u05f0" - "\u05f2",
				"\u0621" - "\u063a",
				"\u0640" - "\u064a",
				"\u0671" - "\u06b7",
				"\u06ba" - "\u06be",
				"\u06c0" - "\u06ce",
				"\u06d0" - "\u06d3",
				"\u06d5",
				"\u06e5" - "\u06e6",
				"\u0905" - "\u0939",
				"\u093d",
				"\u0958" - "\u0961",
				"\u0985" - "\u098c",
				"\u098f" - "\u0990",
				"\u0993" - "\u09a8",
				"\u09aa" - "\u09b0",
				"\u09b2",
				"\u09b6" - "\u09b9",
				"\u09dc" - "\u09dd",
				"\u09df" - "\u09e1",
				"\u09f0" - "\u09f1",
				"\u0a05" - "\u0a0a",
				"\u0a0f" - "\u0a10",
				"\u0a13" - "\u0a28",
				"\u0a2a" - "\u0a30",
				"\u0a32" - "\u0a33",
				"\u0a35" - "\u0a36",
				"\u0a38" - "\u0a39",
				"\u0a59" - "\u0a5c",
				"\u0a5e",
				"\u0a72" - "\u0a74",
				"\u0a85" - "\u0a8b",
				"\u0a8d",
				"\u0a8f" - "\u0a91",
				"\u0a93" - "\u0aa8",
				"\u0aaa" - "\u0ab0",
				"\u0ab2" - "\u0ab3",
				"\u0ab5" - "\u0ab9",
				"\u0abd",
				"\u0ae0",
				"\u0b05" - "\u0b0c",
				"\u0b0f" - "\u0b10",
				"\u0b13" - "\u0b28",
				"\u0b2a" - "\u0b30",
				"\u0b32" - "\u0b33",
				"\u0b36" - "\u0b39",
				"\u0b3d",
				"\u0b5c" - "\u0b5d",
				"\u0b5f" - "\u0b61",
				"\u0b85" - "\u0b8a",
				"\u0b8e" - "\u0b90",
				"\u0b92" - "\u0b95",
				"\u0b99" - "\u0b9a",
				"\u0b9c",
				"\u0b9e" - "\u0b9f",
				"\u0ba3" - "\u0ba4",
				"\u0ba8" - "\u0baa",
				"\u0bae" - "\u0bb5",
				"\u0bb7" - "\u0bb9",
				"\u0c05" - "\u0c0c",
				"\u0c0e" - "\u0c10",
				"\u0c12" - "\u0c28",
				"\u0c2a" - "\u0c33",
				"\u0c35" - "\u0c39",
				"\u0c60" - "\u0c61",
				"\u0c85" - "\u0c8c",
				"\u0c8e" - "\u0c90",
				"\u0c92" - "\u0ca8",
				"\u0caa" - "\u0cb3",
				"\u0cb5" - "\u0cb9",
				"\u0cde",
				"\u0ce0" - "\u0ce1",
				"\u0d05" - "\u0d0c",
				"\u0d0e" - "\u0d10",
				"\u0d12" - "\u0d28",
				"\u0d2a" - "\u0d39",
				"\u0d60" - "\u0d61",
				"\u0e01" - "\u0e2e",
				"\u0e30",
				"\u0e32" - "\u0e33",
				"\u0e40" - "\u0e46",
				"\u0e81" - "\u0e82",
				"\u0e84",
				"\u0e87" - "\u0e88",
				"\u0e8a",
				"\u0e8d",
				"\u0e94" - "\u0e97",
				"\u0e99" - "\u0e9f",
				"\u0ea1" - "\u0ea3",
				"\u0ea5",
				"\u0ea7",
				"\u0eaa" - "\u0eab",
				"\u0ead" - "\u0eae",
				"\u0eb0",
				"\u0eb2" - "\u0eb3",
				"\u0ebd",
				"\u0ec0" - "\u0ec4",
				"\u0ec6",
				"\u0edc" - "\u0edd",
				"\u0f40" - "\u0f47",
				"\u0f49" - "\u0f69",
				"\u10a0" - "\u10c5",
				"\u10d0" - "\u10f6",
				"\u1100" - "\u1159",
				"\u115f" - "\u11a2",
				"\u11a8" - "\u11f9",
				"\u1e00" - "\u1e9b",
				"\u1ea0" - "\u1ef9",
				"\u1f00" - "\u1f15",
				"\u1f18" - "\u1f1d",
				"\u1f20" - "\u1f45",
				"\u1f48" - "\u1f4d",
				"\u1f50" - "\u1f57",
				"\u1f59",
				"\u1f5b",
				"\u1f5d",
				"\u1f5f" - "\u1f7d",
				"\u1f80" - "\u1fb4",
				"\u1fb6" - "\u1fbc",
				"\u1fbe",
				"\u1fc2" - "\u1fc4",
				"\u1fc6" - "\u1fcc",
				"\u1fd0" - "\u1fd3",
				"\u1fd6" - "\u1fdb",
				"\u1fe0" - "\u1fec",
				"\u1ff2" - "\u1ff4",
				"\u1ff6" - "\u1ffc",
				"\u207f",
				"\u2102",
				"\u2107",
				"\u210a" - "\u2113",
				"\u2115",
				"\u2118" - "\u211d",
				"\u2124",
				"\u2126",
				"\u2128",
				"\u212a" - "\u2131",
				"\u2133" - "\u2138",
				"\u3005",
				"\u3031" - "\u3035",
				"\u3041" - "\u3094",
				"\u309b" - "\u309e",
				"\u30a1" - "\u30fa",
				"\u30fc" - "\u30fe",
				"\u3105" - "\u312c",
				"\u3131" - "\u318e",
				"\u4e00" - "\u9fa5",
				"\uac00" - "\ud7a3",
				"\uf900" - "\ufa2d",
				"\ufb00" - "\ufb06",
				"\ufb13" - "\ufb17",
				"\ufb1f" - "\ufb28",
				"\ufb2a" - "\ufb36",
				"\ufb38" - "\ufb3c",
				"\ufb3e",
				"\ufb40" - "\ufb41",
				"\ufb43" - "\ufb44",
				"\ufb46" - "\ufbb1",
				"\ufbd3" - "\ufd3d",
				"\ufd50" - "\ufd8f",
				"\ufd92" - "\ufdc7",
				"\ufdf0" - "\ufdfb",
				"\ufe70" - "\ufe72",
				"\ufe74",
				"\ufe76" - "\ufefc",
				"\uff21" - "\uff3a",
				"\uff41" - "\uff5a",
				"\uff66" - "\uffbe",
				"\uffc2" - "\uffc7",
				"\uffca" - "\uffcf",
				"\uffd2" - "\uffd7",
				"\uffda" - "\uffdc"
			]>
}

TOKEN :
{
	<#DIGIT: [
				"0" - "9",
				"\u0660" - "\u0669",
				"\u06f0" - "\u06f9",
				"\u0966" - "\u096f",
				"\u09e6" - "\u09ef",
				"\u0a66" - "\u0a6f",
				"\u0ae6" - "\u0aef",
				"\u0b66" - "\u0b6f",
				"\u0be7" - "\u0bef",
				"\u0c66" - "\u0c6f",
				"\u0ce6" - "\u0cef",
				"\u0d66" - "\u0d6f",
				"\u0e50" - "\u0e59",
				"\u0ed0" - "\u0ed9",
				"\u0f20" - "\u0f29",
				"\uff10" - "\uff19"
			]>
}

TOKEN :
{	/* Delimited Identifiers - NOTE: this does not allow zero-length identifiers */
	<DELIMITED_IDENTIFIER: "\""
		(
			("\"\"") |
			(~["\""])
		) +
		"\"">
| <BACKQUOTED_IDENTIFIER: "`"
    (
			("``") |
			(~["`"])
		) +
		"`">
}

TOKEN :
{	/* Literals */
	<EXACT_NUMERIC: ( <UINT> ( "." ( <UINT> )? )? | "." <UINT> )>
|	<UINT: (["0" - "9"])+ >/* This is for an unsigned exact numeric */
|	<LENGTH_MODIFIER: ( <UINT> ["K","M","G","k","m","g"] )>
|	<STRING: "'"
		(
			"''" |
			~["'"]
		) *
		"'">
| <#HEX_RANGE: (["0"-"9","a"-"f","A"-"F"])> /* RESOLVE: does not allow separators */
| <UUID_LITERAL: <HEX_RANGE>(<HEX_RANGE>)+ "-" <HEX_RANGE>(<HEX_RANGE>)+ "-" <HEX_RANGE>(<HEX_RANGE>)+ "-" <HEX_RANGE>(<HEX_RANGE>)+ "-" <HEX_RANGE>(<HEX_RANGE>)+> // 00000001-ffff-ffff-ffff-00000000001c 
|	<HEX_STRING: ["X","x"] "'" (["0"-"9","a"-"f","A"-"F"])*"'"> /* RESOLVE: does not allow separators */
|	<APPROXIMATE_NUMERIC: <EXACT_NUMERIC> ["e","E"] ( ("+" | "-") )? ( ["0" - "9"] )+ >
/*****
	The tokenizer can't handle the date/time literals because
	they are constructed of two tokens with arbitrary whitespace between them.
	INTERVAL_LITERAL will also have to be upgraded at some point.
|	<DATE_LITERAL: "DATE" "'" <DATE_VALUE> "'" >
|	<#DATE_VALUE: <UINT> "-" <UINT> "-" <UINT> >
|	<TIME_LITERAL: "TIME" "'" <TIME_VALUE> ( <TIMEZONE_INTERVAL> ) ? "'" >
|	<#TIME_VALUE: <UINT> ":" <UINT> ":" <SECONDS_VALUE> >
|	<#TIMEZONE_INTERVAL: ("+" | "-") <UINT> ":" <UINT> >
|	<TIMESTAMP_LITERAL: "TIMESTAMP" "'" <DATE_VALUE> " " <TIME_VALUE> ( <TIMEZONE_INTERVAL> ) ? "'" >
*****/
|	<INTERVAL_LITERAL: "INTERVAL" "'" (["+","-"])? <INTERVAL_STRING> <INTERVAL_QUALIFIER> >
|	<#INTERVAL_STRING: "'" ( <YEAR_MONTH_LITERAL> | <DAY_TIME_LITERAL> ) "'" >
|	<#INTERVAL_QUALIFIER: <SINGLE_DATETIME_FIELD> | ( <START_FIELD> <TO> <END_FIELD> ) >
|	<#SINGLE_DATETIME_FIELD: <NON_SECOND_DATETIME_FIELD> ( <LEFT_PAREN> <UINT> <RIGHT_PAREN> ) ? >
|	<#START_FIELD: <NON_SECOND_DATETIME_FIELD> ( <LEFT_PAREN> <UINT> <RIGHT_PAREN> ) ? >
|	<#END_FIELD: <NON_SECOND_DATETIME_FIELD> >
|	<#NON_SECOND_DATETIME_FIELD: <YEAR> | <MONTH> | <DAY> | <HOUR> | <MINUTE> >
|	<#YEAR_MONTH_LITERAL: (<UINT> | ( <UINT> "-" ) )? <UINT> >
|	<#DAY_TIME_LITERAL:  ( <DAY_TIME_INTERVAL> | <TIME_INTERVAL> ) >
|	<#DAY_TIME_INTERVAL: <UINT> ( " " <UINT> ( ":" <UINT> ( ":" <SECONDS_VALUE> ) ? ) ? ) ? >
|	<#SECONDS_VALUE: <UINT> ( "." ( <UINT> ) ? ) ? >
|	<#TIME_INTERVAL: <UINT> ( ":" <UINT> ( ":" <SECONDS_VALUE> ) ? ) ?
		|	 <UINT> ( ":" <SECONDS_VALUE> ) ?
		|	<SECONDS_VALUE> >
}



/*
 * <A NAME="Statement">Statement</A>
 */
StatementNode
Statement( String statementSQLText, Object[] paramDefaults) throws StandardException :
{
	StatementNode	statementNode;

        initStatement(statementSQLText, paramDefaults);
}
{
	statementNode = StatementPart(null) 
	// GemStone changes BEGIN
	 [<SEMICOLON>] 
	// GemStone changes END
	<EOF>
	{
		return statementNode;
	}
}

StatementNode 
proceduralStatement(Token[] tokenHolder) throws StandardException : 
{
	StatementNode statementNode;
	tokenHolder[0] = getToken(1);
	//GemStone changes BEGIN
	//getCompilerContext().setPreparedStatement();
	getCompilerContext().allowOptimizeLiteral(false);
	//GemStone changes END
}   
{ 	
(
	statementNode = insertStatement()
|	
	statementNode = preparableUpdateStatement()
|
	statementNode = preparableDeleteStatement()
|
	statementNode =  preparableSelectStatement(true)	
|
	statementNode =  callStatement()	
)
	{
		return statementNode;
	}		
}

/*
 * <A NAME="StatementPart">StatementPart</A>
 * 
 * @param tokenHolder returns the token that starts
 * the statement.  If null, ignored.
 */
StatementNode
StatementPart(Token[] tokenHolder) throws StandardException :
{
	StatementNode	statementNode;
	//before starting new statements, initialize this variables. Otherwise, the left
	//over values from previously failed sql will affect the next sql. 
        explicitNotNull = false;
        explicitNull = false;
	explicitlyNullableColumnsList = new Vector();
//	Gemstone changes begin	 
        subqueryParamCount = null;
//	Gemstone changes end
	/*
	** Grab the token preceding this production
	*/
	if (tokenHolder != null) 
	{
		tokenHolder[0] = getToken(1);
	}
}
{
	/*
	 * The present method of invoking the parser is
	 * via JDBC, which uses preparable SQL statements only.
	 * the only place this makes a difference from other
	 * flavors of SQL (direct SQL, embedded SQL, dynamic SQL)
	 * is in the select and positioned update/delete statements,
	 * and in whether transaction and connection statements are
	 * allowed.
	 *
	 * When it becomes necessary to differentiate, we should
	 * define a way to put the parser into different modes
	 * (preparable SQL, dynamic SQL, direct SQL, embedded SQL, etc.)
	 * and have it accept/reject statements based on the mode
	 * it is in.
	 */
    (
        statementNode = spsRenameStatement() |
        // statementNode = SQLTransactionStatement() |
        statementNode = lockStatement()
    )
    {
        return statementNode;
    }
|   (
        statementNode = createStatements() |
        statementNode = dropStatements() |
        statementNode = spsAlterStatement() |
        statementNode = globalTemporaryTableDeclaration() |
        statementNode = preparableSQLDataStatement() |
        statementNode = spsSetStatement() |
		statementNode = truncateTableStatement() |
		statementNode = grantStatement() |
		statementNode = revokeStatement() |
		statementNode = execStatement()
        // GemStone changes BEGIN
        | statementNode = explainStatement()
	// GemStone changes END
        // statementNode = SQLTransactionStatement()
    )
    {
        return statementNode;
    }
 | statementNode=extractEscape(tokenHolder) 
   {
       return statementNode;
   }                           
}

//Gemstone changes Begin
/*
 * <A NAME="extractEscape">extractEscape</A>
 */
StatementNode
extractEscape(Token[] tokenHolder) throws StandardException :
{
	StatementNode statementNode;	
}
{
    <LESS_THAN_OPERATOR> {
      CompilerContext cc=getCompilerContext();
    }
    (<COHORT>
    {
      
      cc.setCohortFlag(true);
    }
  
    |<GLOBAL>
      {      
      cc.setGlobalScope();
    }
   
    |<LOCAL>
     {      
      cc.setLocalScope();
    }
    )
    
    <GREATER_THAN_OPERATOR>
    statementNode=StatementPart(tokenHolder)
	{
		return statementNode;
	}

}

/*
 * <A NAME="nvlFunction">nvlFunction</A>
 */
ValueNode
nvlFunction(String nvl) throws StandardException :
{
    ValueNodeList expressionList = (ValueNodeList) nodeFactory.getNode(
	C_NodeTypes.VALUE_NODE_LIST,
	getContextManager());
}
{
    <LEFT_PAREN>
        coalesceExpression(expressionList)
		<COMMA> coalesceExpression(expressionList)
    <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(
                C_NodeTypes.COALESCE_FUNCTION_NODE,
                nvl,
                expressionList,
                getContextManager());
    }
}

/*
 * <A NAME="decodeFunction">decodeFunction</A>
 */
ValueNode
decodeFunction() throws StandardException :
{
	ValueNode leftExpr;
	ValueNode expr;
}
{
	<LEFT_PAREN>
		leftExpr = additiveExpression(null, 0, false)
		expr = decodeWhenThenExpression(leftExpr)
	{
		return expr;
	}
}

/*
 * <A NAME="decodeCaseExpression">decodeCaseExpression</A>
 */
ValueNode
decodeCaseExpression(ValueNode leftExpr) throws StandardException :
{
	ValueNode expr;
	ValueNode thenExpr;
}
{
	<RIGHT_PAREN>
	{
		ValueNode value = (ValueNode) nodeFactory.getNode(
										C_NodeTypes.CAST_NODE,
										(ValueNode)nodeFactory.getNode(C_NodeTypes
											.UNTYPED_NULL_CONSTANT_NODE,
											getContextManager()),
										DataTypeDescriptor.getBuiltInDataTypeDescriptor(
											Types.CHAR, 1),
										getContextManager());
		((CastNode)value).setForExternallyGeneratedCASTnode();
		return value;
	}
|
	<COMMA> expr = thenElseExpression()
	(
		<RIGHT_PAREN>
		{
			return expr;
		}
	|
		thenExpr = decodeThenExpression(leftExpr,
			(ValueNode)nodeFactory.getNode(
							C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
							leftExpr,
							expr,
							getContextManager()))
		{
			return thenExpr;
		}
	)
}

/*
 * <A NAME="decodeWhenThenExpression">decodeWhenThenExpression</A>
 */
ValueNode
decodeWhenThenExpression(ValueNode leftExpr) throws StandardException :
{
	ValueNode expr;
	ValueNode thenExpr;
	ValueNode elseExpr;
}
{
	<COMMA> expr = additiveExpression(leftExpr, BinaryOperatorNode.EQ, false)
	thenExpr = decodeThenExpression(leftExpr, expr)
	{
		return thenExpr;
	}
}

/*
 * <A NAME="decodeThenExpression">decodeThenExpression</A>
 */
ValueNode
decodeThenExpression(ValueNode leftExpr, ValueNode expr) throws StandardException :
{
	ValueNode thenExpr;
	ValueNode elseExpr;
}
{
	<COMMA> thenExpr = thenElseExpression()
	elseExpr = decodeCaseExpression(leftExpr)
	{
		ContextManager cm = getContextManager();
		ValueNodeList thenElseList = (ValueNodeList)nodeFactory.getNode(
			C_NodeTypes.VALUE_NODE_LIST, cm);
		thenElseList.addElement(thenExpr); // then
		thenElseList.addElement(elseExpr); // else

		return ((ValueNode)nodeFactory.getNode(C_NodeTypes.CONDITIONAL_NODE,
												expr,
												thenElseList,
												Boolean.FALSE,
												cm));
	}
}

// GemStone changes END
/*
 * <A NAME="createStatements">spsCreateStatement</A>
 */
StatementNode
createStatements() throws StandardException :
{
	StatementNode statementNode;
	Token beginToken;
	int tokKind;
	//GemStone changes BEGIN
	//[sb] disabling globally literal optimization for 'create view/trigger' etc.
	CompilerContext cc = getCompilerContext();
	cc.allowOptimizeLiteral(false);
	//cc.setPreparedStatement();
	//GemStone changes END
}
{
	beginToken = <CREATE>
		{ cc.markAsDDLForSnappyUse(true);}
	(
		(
            statementNode = schemaDefinition() |
            statementNode = viewDefinition(beginToken) |
            statementNode = triggerDefinition() |
            statementNode = synonymDefinition() |
            statementNode = roleDefinition()  |
 //Gemstone changes Begin
            statementNode = aliasDefinition() |
            statementNode = diskStoreDefinition()|
            statementNode = hdfsStoreDefinition()|            
            statementNode = gatewaySenderDefinition() |
            statementNode = asyncEventListenerDefinition() |
            statementNode = gatewayReceiverDefinition()
 //Gemstone changes End           
        )
        {
        }
|       statementNode = tableDefinition()
        {
        }
|		statementNode = procedureDefinition()
|		statementNode = functionDefinition()
|		statementNode = udtDefinition()
|
		statementNode = indexDefinition()
        {
        }
	)
	{
		return statementNode;
	}

}

/*
 * <A NAME="dropStatements">spsDropStatement</A>
 */
StatementNode
dropStatements() throws StandardException :
{
	StatementNode statementNode;
}
{
	<DROP>
        (
            statementNode = dropSchemaStatement() |
            statementNode = dropTableStatement() |
            statementNode = dropIndexStatement() |
            statementNode = dropAliasStatement() |
            statementNode = dropViewStatement() |
            statementNode = dropTriggerStatement() |
            statementNode = dropRoleStatement() |
            statementNode = dropDiskStoreStatement() |
            statementNode = dropHDFSStoreStatement() |
            statementNode = dropAsyncEventListenerStatement() |
            statementNode = dropGatewaySenderStatement() |
            statementNode = dropGatewayReceiverStatement()
        )
	{
		return statementNode;
	}
}

StatementNode
alterHdfsStoreStatement() throws StandardException :
{
	StatementNode		node;
	String	            storeName;
    Map otherAttribs = new HashMap();
}
{
	<HDFSSTORE> storeName = identifier(Limits.MAX_IDENTIFIER_LENGTH,true)
    (<SET> populateAlterHDFSAttributes(otherAttribs))*
	{
               return (StatementNode) nodeFactory.getNode(
                                                               C_NodeTypes.ALTER_HDFS_STORE_NODE,
                                                               storeName,
                                                               otherAttribs,
                                                               getContextManager());
	}
}

void 
populateAlterHDFSAttributes(Map otherAttribs ) throws StandardException :
{
	Token tok;
	ValueNode val;
	Token bool ;
	BigDecimal interval = new BigDecimal("1");
}
{  
   (	      
	  (
	     tok= <BATCHSIZE>
    	 | tok = <MAXINPUTFILESIZE>
    	 | tok = <MININPUTFILECOUNT>
    	 | tok = <MAXINPUTFILECOUNT>
    	 | tok = <MINORCOMPACTIONTHREADS>
    	 | tok = <MAJORCOMPACTIONTHREADS> 
    	 | tok = <MAXWRITEONLYFILESIZE>
   	  )
      val = intLiteral()
	  {
	     if (getIntValue(val) < 0)
	     {
	        throw StandardException.newException(SQLState.LANG_INVALID_COLUMN_LENGTH,
                "Value " + getIntValue(val) + " is negative");
	     }
	     addToMapAllowOnce(otherAttribs, tok.image, val);
	  }
   )  
   |
   (
      (
         tok = <MAJORCOMPACTIONINTERVAL>
         | tok = <PURGEINTERVAL>
      )
      val = getIntervalInMins()
      {
         if (getIntValue(val) < 1)
         {
            throw StandardException.newException(SQLState.LANG_INVALID_COLUMN_LENGTH,
               "Value in minutes " + getIntValue(val) + " is less than 1");
         }
         addToMapAllowOnce(otherAttribs, tok.image, val);
      }
   )
   |
   (
      (
         tok = <WRITEONLYFILEROLLOVERINTERVAL>
      )   
      val = getIntervalInSecs()
     {
         if (getIntValue(val) < 1)
         {
            throw StandardException.newException(SQLState.LANG_INVALID_COLUMN_LENGTH,
               "Value in seconds " + getIntValue(val) + " is less than 1");
         }
         addToMapAllowOnce(otherAttribs, tok.image, val);
      }
   )
   |
   (
      (
         tok = <BATCHTIMEINTERVAL>
      )   
      val = getIntervalInMillis()
     {
         if (getIntValue(val) < 1)
         {
            throw StandardException.newException(SQLState.LANG_INVALID_COLUMN_LENGTH,
               "Value in milliseconds " + getIntValue(val) + " is less than 1");
         }
         addToMapAllowOnce(otherAttribs, tok.image, val);
      }
   )
   |
   (
      (
	     tok = <MINORCOMPACT>
		 | tok = <MAJORCOMPACT>
      )   
      bool = booleanLiteral()
	  {
	     addToMapAllowOnce(otherAttribs, tok.image, bool.image);
	  }
   )
}

/*
 * <A NAME="spsAlterStatement">spsAlterStatement</A>
 */
StatementNode
spsAlterStatement() throws StandardException :
{
	StatementNode statementNode;
}
{
	<ALTER>
        (
		    statementNode = alterTableStatement() | 
		    statementNode = alterHdfsStoreStatement()
        )
	{
		return statementNode;
	}
}

/*
 * <A NAME="spsSetStatement">spsSetStatement</A>
 */
StatementNode
spsSetStatement() throws StandardException :
{
	StatementNode statementNode;
	CompilerContext cc = getCompilerContext();
  cc.markAsDDLForSnappyUse(true);
}
{
        LOOKAHEAD ( { getToken(1).kind == SET && getToken(2).kind != CURRENT } )
	<SET>
        (
                statementNode = setIsolationStatement() |
	        statementNode = setSchemaStatement() |
            statementNode = setMessageLocaleStatement() |
            statementNode = setRoleStatement()
        )
	{
		return statementNode;
	}
|
	<USE> statementNode = setSchemaValues()
	{
		return statementNode;
	}
|
        LOOKAHEAD ( { getToken(1).kind == SET && getToken(2).kind == CURRENT } )
	<SET>
        (
	        statementNode = setSchemaStatement() |
                statementNode = setIsolationStatement()

        )
	{
		return statementNode;
	}
}
		
/*
 * <A NAME="preparableSQLDataStatement">preparableSQLDataStatement</A>
 *
 * preparableSQLDataStatement differs from
 * directSQLDataStatement in that it
 * supports positioned update and delete
 * and a preparable select (with FOR UPDATE)
 * instead of a direct select (without FOR UPDATE)
 */
StatementNode
preparableSQLDataStatement() throws StandardException :
{
	StatementNode	dmlStatement;
	CompilerContext cc = getCompilerContext();
}
{
	/*
	** RESOLVE: Ignoring temporary table declarations for now.
	*/
	dmlStatement = preparableDeleteStatement()
	{
	    cc.popDML(0);
		return dmlStatement;
	}
|
	dmlStatement = preparableSelectStatement(true)
	{
	    
		return dmlStatement;
	}
|
	dmlStatement = insertStatement()
	{
	    cc.popDML(0);
		return dmlStatement;
	}
|
	dmlStatement = preparableUpdateStatement()
	{
	    cc.popDML(0);
		return dmlStatement;
	}
|
	dmlStatement = callStatement()
	{
		return dmlStatement;
	}
|
	dmlStatement = savepointStatement()
	{
		return dmlStatement;
	}
}

/*
 * <A NAME="preparableDeleteStatement">preparableDeleteStatement</A>
 *
 *	This may be a search or positioned delete statement.
 */
StatementNode
preparableDeleteStatement() throws StandardException :
{
	StatementNode qtn;
}
{
	<DELETE> { getCompilerContext().pushDML(0);} qtn = deleteBody()
	{
		return qtn;
	}
}

StatementNode
deleteBody() throws StandardException :
{
	JavaToSQLValueNode	javaToSQLNode = null;
	String				correlationName = null;
	TableName  tableName = null;
	ValueNode  whereClause = null;
	FromTable  fromTable = null;
	QueryTreeNode retval;
	Properties targetProperties = null;
	Token	   whereToken = null;
}
{
	LOOKAHEAD( { fromNewInvocationFollows() } ) 
	<FROM> javaToSQLNode = newInvocation()
	[ whereToken = <WHERE> whereClause = whereClause(whereToken) ]
	{
		fromTable =  (FromTable) nodeFactory.getNode(
									C_NodeTypes.FROM_VTI,
									javaToSQLNode.getJavaValueNode(), 
									(String) null,
									null, 
									(Properties) null,
									getContextManager()); 

		return getDeleteNode(fromTable, tableName, whereClause);
	}
|
	<FROM> tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH) 
		[ 
			LOOKAHEAD
			( { (getToken(1).kind != EOF)
                  // GemStone changes BEGIN
                  && getToken(1).kind != SEMICOLON                
                  // GemStone changes END
			&& (getToken(1).kind != WHERE) && !derbyPropertiesListFollows() } )
			[ <AS> ] correlationName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true) 
		]
		[targetProperties = propertyList(false) <CHECK_PROPERTIES>] 
		[ 
			whereToken = <WHERE>
		    (
				//need LOOKAHEAD here to decide between CURRENT in class name
				//and CURRENT in CURRENT OF
				LOOKAHEAD ( 
	             	{
		         	 (getToken(1).kind == CURRENT) &&
					 (getToken(2).kind == OF) 
				  	}
				)	
				fromTable = currentOfClause( correlationName ) |
				whereClause = whereClause(whereToken)
			)
		]
	{
		/* Fabricate a ResultSetNode (SelectNode) under the DeleteNode.
		 * For a searched delete,
		 * The FromList is simply the table that we are deleting from.
		 * (NOTE - we mark the table as the one that we are deleting from.)
		 * For a positioned delete,
		 * the FromList is a CurrentOfNode holding the cursor name.
		 * The select list will be null for now.  We will generate it at
	 	 * bind time, in keeping with the design decision that the parser's
	  	 * output should look like the language.
		 */
		if (fromTable == null)
			fromTable = (FromTable) nodeFactory.getNode(
										C_NodeTypes.FROM_BASE_TABLE,
										tableName,
										correlationName,
										ReuseFactory.getInteger(
												FromBaseTable.DELETE),
										null,
										getContextManager());

		/* Update the FromTable with any properties, if non-null */
		if (targetProperties != null)
		{
			if (SanityManager.DEBUG)
			{
				if (((FromBaseTable) fromTable).getProperties() != null)
				{
					SanityManager.THROWASSERT(
						"Overwriting existing properties");
				}
			}
			((FromBaseTable) fromTable).setTableProperties(targetProperties);
		}

// GemStone changes BEGIN
		if (getLanguageConnectionContext().getDataDictionary()
		        .getBuiltinVTIClass(tableName.getSchemaName(),
			tableName.getTableName()) != null)
		{
		   // We do not allow users to DELETE from the built-inVTIs
		   throw StandardException.newException(SQLState.LANG_UPDATE_SYSTEM_TABLE_ATTEMPTED, 
						tableName);
		}
// GemStone changes END
		return getDeleteNode(fromTable, tableName, whereClause);
	}
}

/*
 * <A NAME="currentOfClause">currentOfClause</A>
 */
FromTable
currentOfClause( String correlationName ) throws StandardException :
{
	String cursorName = null;
}
{
	<CURRENT> <OF> cursorName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	{ 
                // Gemstone changes BEGIN
                // GemFireXD does not support WHERE CURRENT OF for DELETE or UPDATE
                // Block here instead of in Delete/UpdateNode
                if (!getLanguageConnectionContext().ignoreWhereCurrentOfUnsupportedException()) {
                   throw StandardException.newException(SQLState.NOT_IMPLEMENTED, "update where current of");
                }
                // Gemstone changes END

		return (FromTable) nodeFactory.getNode(
								C_NodeTypes.CURRENT_OF_NODE,
								correlationName,
								cursorName,
								null,
								getContextManager());
	}
}


/*
 * <A NAME="preparableSelectStatement">preparableSelectStatement</A>
 *
 *
 *	The preparable select statement is a superset of
 *	the directSelectStatementMultipleRows in that it
 *	allows both the preparable single row select statement
 *	(a query expression that returns one row, although it
 *	is also handled like a cursor) and the preparable
 *	multiple row select statement, which allows not only
 *	an order by clause but also a for update clause.
 */
CursorNode
preparableSelectStatement(boolean checkParams) throws StandardException :
{
	ResultSetNode	  queryExpression;
	Vector  updateColumns = new Vector();
	int               forUpdateState = CursorNode.UNSPECIFIED;
	int				  isolationLevel = ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL;
	CursorNode		  retval;
	OrderByList orderCols = null;
    ValueNode offset = null;
    ValueNode fetchFirst = null;
    
}
{
	queryExpression = queryExpression(null, NO_SET_OP) 
		[ orderCols = orderByClause() ]
        [ offset = offsetClause() ]
        [ fetchFirst = fetchFirstClause() ]
		[ <FOR> forUpdateState = forUpdateClause(updateColumns) ]
		[ isolationLevel = atIsolationLevel() ]
	{
		// Note: if order by is specified, the for update clause
		// must be READ ONLY or empty, and the cursor
		// is implicitly READ_ONLY.

		retval = (CursorNode) nodeFactory.getNode(
				C_NodeTypes.CURSOR_NODE,
				"SELECT",
				queryExpression,
				null,
				orderCols,
                offset,
                fetchFirst,				
				ReuseFactory.getInteger(forUpdateState),
				(forUpdateState == CursorNode.READ_ONLY ? null : updateColumns ),
				getContextManager());

		if (checkParams)
		{
			setUpAndLinkParameters();
		}

		/* Set the isolation levels for the scans if specified */
		if (isolationLevel != ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL)
		{
			getCompilerContext().setScanIsolationLevel(isolationLevel);
		}

		return retval;
	}
}

/*
 * <A NAME="insertStatement">insertStatement</A>
 */
StatementNode
insertStatement() throws StandardException :
{
	StatementNode	insertNode;
	QueryTreeNode	targetTable;
	getCompilerContext().pushDML(0);
	boolean isPutDML;
}
{
	<INSERT> <INTO> targetTable = targetTable()
			{ isPutDML = false; }			
			insertNode = insertColumnsAndSource(targetTable, isPutDML)
	{
		setUpAndLinkParameters();

		return insertNode;
	}
	|
    <PUT> <INTO> targetTable = targetTable()
         { isPutDML = true; }
       insertNode = insertColumnsAndSource(targetTable, isPutDML)
       {
               setUpAndLinkParameters();

               return insertNode;
       }
	
}

QueryTreeNode
targetTable() throws StandardException :
{
	JavaToSQLValueNode	javaToSQLNode = null;
	String				correlationName = null;
	TableName			tableName;
}
{
	/* NOTE: this rule has to come first in order to avoid making NEW
	 * a reserved word.
	 */
	/* identifier() used to be correlationName() */
	LOOKAHEAD( { newInvocationFollows(1) } )
	javaToSQLNode = newInvocation()
	{
		return nodeFactory.getNode(
								C_NodeTypes.FROM_VTI,
								javaToSQLNode.getJavaValueNode(), 
								correlationName,
								null, 
								(Properties) null,
								getContextManager()); 
	}
|
	tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH) 
	{
// GemStone changes BEGIN
		if (getLanguageConnectionContext().getDataDictionary()
			.getBuiltinVTIClass(tableName.getSchemaName(),
			tableName.getTableName()) != null)
		{
		   // We do not allow users to INSERT to the built-inVTIs
		   throw StandardException.newException(SQLState.LANG_UPDATE_SYSTEM_TABLE_ATTEMPTED, 
						tableName);
		}
// GemStone changes END
		return tableName;
	}
}

/*
 * <A NAME="preparableUpdateStatement">preparableUpdateStatement</A>
 */
StatementNode
preparableUpdateStatement() throws StandardException :
{
	StatementNode qtn;
	getCompilerContext().pushDML(0);
}
{
	// NOTE: It only makes sense to have a property list if there is a
	// table name, so I moved it into the [] for qualifiedName(). 

	<UPDATE> qtn = updateBody()
	{
		return qtn;
	}

}

boolean
tableOrIndex() :
{
}
{
	<TABLE>
	{
		return true;
	}
|
	<INDEX>
	{
		return false;
	}
}

StatementNode
updateBody() throws StandardException :
{
	ResultColumnList	columnList;
	String				correlationName = null;
	JavaToSQLValueNode	javaToSQLNode = null;
	TableName  tableName = null;
	ValueNode  whereClause = null;
	FromTable  fromTable = null;
	Properties targetProperties = null;
	Token	   whereToken = null;
}
{
	LOOKAHEAD( { newInvocationFollows(1) } ) 
	javaToSQLNode = newInvocation()
		<SET> columnList = setClauseList()
	[ whereToken = <WHERE> whereClause = whereClause(whereToken) ]
	{
		fromTable =  (FromTable) nodeFactory.getNode(
									C_NodeTypes.FROM_VTI,
									javaToSQLNode.getJavaValueNode(), 
									(String) null,
									null, 
									(Properties) null,
									getContextManager()); 

		return getUpdateNode(fromTable, tableName, columnList, whereClause);
	}
|
		tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
		[
			LOOKAHEAD( { (getToken(1).kind != SET) && !derbyPropertiesListFollows() } )
			[ <AS> ] correlationName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true) 
		]
		[
			targetProperties = propertyList(false) <CHECK_PROPERTIES>
		] 
		<SET> columnList = setClauseList()
		[ 
			whereToken = <WHERE>
		    (
				whereClause = whereClause(whereToken) |
				fromTable = currentOfClause( correlationName )
			)
		]
	{
		/* Fabricate a ResultSetNode (SelectNode) under the UpdateNode.
		 * For a searched update,
		 * The FromList is simply the table that we are updating.
		 * For a positioned update,
		 * the FromList is a CurrentOfNode holding the cursor name.
		 * (NOTE - we mark the table as the one that we are updating.)
		 * The select list is the columns in the SET clause.  At bind time,
	 	 * we will prepend the CurrentRowLocation() in keeping with the design 
		 * decision that the parser's output should look like the language.
		 */
		if (fromTable == null)
// GemStone changes BEGIN
		{
			// check for update on VTIs
			if (getLanguageConnectionContext().getDataDictionary()
				.getBuiltinVTIClass(tableName.getSchemaName(),
				tableName.getTableName()) != null) {
                	   // We do not allow users to UPDATE the built-inVTIs
	         	   throw StandardException.newException(SQLState.LANG_UPDATE_SYSTEM_TABLE_ATTEMPTED, 
						tableName);
			}
			else {
// GemStone changes END
			fromTable = (FromTable) nodeFactory.getNode(
										C_NodeTypes.FROM_BASE_TABLE,
										tableName,
										correlationName,
										ReuseFactory.getInteger(
														FromBaseTable.UPDATE),
										null,
										getContextManager());
// GemStone changes BEGIN
			}
		}
// GemStone changes END

		/* Update the FromTable with any properties, if non-null */
		if (targetProperties != null)
		{
			if (SanityManager.DEBUG)
			{
				if (((FromBaseTable) fromTable).getProperties() != null)
				{
					SanityManager.THROWASSERT(
						"Overwriting existing properties");
				}
			}
			((FromBaseTable) fromTable).setTableProperties(targetProperties);
		}
		return getUpdateNode(fromTable, tableName, columnList, whereClause);
	}
}

/*
 * <A NAME="callStatement">callStatement</A>
 */
StatementNode
callStatement() throws StandardException :
{
	StatementNode retval;
}
{
	(
		retval = bareCallStatement() |
		<LEFT_BRACE> retval = bareCallStatement() <RIGHT_BRACE>
	)
	{
		return retval;
	}
}

/*
 * <A NAME="bareCallStatement">baseCallStatement</A>
 */
StatementNode
bareCallStatement() throws StandardException :
{
	ParameterNode		returnParam;

	ValueNode			value;

	ResultSetNode		resultSetNode;
//Gemstone changes Begin	
    
    boolean coordinateNode=false;
    FromList fromList = (FromList) nodeFactory.getNode(
									C_NodeTypes.FROM_LIST,
									getNodeFactory().doJoinOrderOptimization(),
									getContextManager()); 
    FromTable tableReference;										
	Token               whereToken=null; 		
    ValueNode           whereClause=null;
    Boolean             all=Boolean.FALSE;
    Boolean             nowait=Boolean.FALSE;
    ServerGroupsTableAttribute serverGroups =
		new ServerGroupsTableAttribute();
	String javaClassName=null;
	String aliasName=null;
	
	//[sb] disabling by indicating 'call <... >' as PS type.
	getCompilerContext().allowOptimizeLiteral(false);
	//getCompilerContext().setPreparedStatement();
 //Gemstone changes End   	
}
{
	<CALL> value = primaryExpression( true )
	//Gemstone changes Begin
	[
	   <WITH> <RESULT> <PROCESSOR> {coordinateNode=true;}
	   (
	   	 LOOKAHEAD( { javaClassFollowsProcedureCall()} )
	   	 javaClassName=javaClass() [ < DOUBLE_COLON > ]
	   |
	       aliasName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true) 	 
	   	)
	]		
	[
	   <ON> {coordinateNode=true;}
	  ( <TABLE> tableReference = tableReferenceTypes(false)
	    { fromList.addFromTable(tableReference);}	 
	    [ whereToken=<WHERE> whereClause=whereClause(whereToken) ]
	   |<ALL> { all=Boolean.TRUE;}
	   |serverGroupDefinition(serverGroups) 
	  )
	]
	[
	<NOWAIT> { nowait = Boolean.TRUE; }
    ]
//Gemstone changes End	
	{
		if (! (value instanceof JavaToSQLValueNode) ||
			! (((JavaToSQLValueNode) value).getJavaValueNode() instanceof MethodCallNode))
		{
			throw StandardException.newException(SQLState.LANG_INVALID_CALL_STATEMENT);
		}

		//Gemstone changes Begin
        if(coordinateNode) {
        
              ProcedureProcessorNode processorNode=
                      (ProcedureProcessorNode)nodeFactory.getNode(C_NodeTypes.PROCEDURE_PROCESSOR_NODE,
                      javaClassName,
                      aliasName,
                      getContextManager()); 
              JavaValueNode jvn=((JavaToSQLValueNode) value).getJavaValueNode();  
              assert jvn instanceof StaticMethodCallNode;           
              StaticMethodCallNode callNode=(StaticMethodCallNode)jvn;
              DistributedProcedureCallNode distributedCallNode=
                (DistributedProcedureCallNode)nodeFactory.getNode(
                                                C_NodeTypes.DISTRIBUTED_PROCEDURE_CALL_NODE,                                              
												jvn,
												processorNode,
												fromList,
												whereClause,
												all,
												serverGroups,
												nowait,																							
												getContextManager());
             value=(ValueNode) nodeFactory.getNode(
                                                           C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
                                                                distributedCallNode,
                                                                getContextManager());                                  
        }
		StatementNode callStatement =
									(StatementNode) nodeFactory.getNode(
												C_NodeTypes.CALL_STATEMENT_NODE,
												value,
												getContextManager());
												
//Gemstone changes End
		setUpAndLinkParameters();

		return callStatement;
	}

	// ? = CALL method()
|	returnParam = dynamicParameterSpecification()
	{
		getCompilerContext().setReturnParameterFlag(); //bug4450
	}
	<EQUALS_OPERATOR> <CALL> resultSetNode = rowValueConstructor(null)
	{
		// validate that we have something that is an appropriate call statement
		ResultColumnList rcl = resultSetNode.getResultColumns();

		// we can have only 1 return value/column
		if (rcl == null || rcl.size() > 1)
		{
			throw StandardException.newException(SQLState.LANG_INVALID_CALL_STATEMENT);
		}

		// we must have a method call node
		value = ((ResultColumn) rcl.elementAt(0)).getExpression();
		if (! (value instanceof JavaToSQLValueNode) ||
			! (((JavaToSQLValueNode) value).getJavaValueNode() instanceof MethodCallNode))
		{
			throw StandardException.newException(SQLState.LANG_INVALID_CALL_STATEMENT);
		}

		// wrap the row result set in a cursor node
		StatementNode cursorNode =
					(StatementNode) nodeFactory.getNode(
						C_NodeTypes.CURSOR_NODE,
						"SELECT",
						resultSetNode,
						null,
						null,
                        null,
                        null,
						ReuseFactory.getInteger(CursorNode.READ_ONLY),
						null,
						getContextManager());

		// set the 0th param to be a RETURN param
		returnParam.setReturnOutputParam(value);

		setUpAndLinkParameters();

		return cursorNode;
	}
}

/*
 * <A NAME="primaryExpression">primaryExpression</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
ValueNode primaryExpression( boolean inSelectClause ) throws StandardException :
{
	ValueNode			value = null;
}
{
	LOOKAHEAD
	( {
		getToken(2).kind == PERIOD &&
		getToken(4).kind == LEFT_PAREN
	  }
	)
	value = routineInvocation()
	{
		return value;
	}
|
	value = primaryExpressionXX( inSelectClause )
	{
		return value;
	}
}

/* 
 * <A NAME="savepointStatement">savepointStatement</A>

	savepointStatementClauses contains the UNIQUE, ON ROLLBACK RETAIN LOCKS, ON ROLLBACK RETAIN CURSORS clauses.

	0 - Boolean - UNIQUE clause
	1 - Boolean - ON ROLLBACK RETAIN LOCKS clause
	2 - Boolean - ON ROLLBACK RETAIN CURSORS clause
 */
StatementNode
savepointStatement() throws StandardException :
{
	String			savepointName = null;
	int			savepointStatementType;
	Object[] savepointStatementClauses = new Object[3];
}
{
	(
	<SAVEPOINT> savepointName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true) (savepointStatementClause(savepointStatementClauses))+
	{
		//ON ROLLBACK RETAIN CURSORS is mandatory
		if (savepointStatementClauses[2] == null)
				throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, "MISSING ON ROLLBACK RETAIN CURSORS");
		savepointStatementType = 1;
	}
|	<ROLLBACK> [ <WORK> ] <TO> <SAVEPOINT> [ savepointName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true) ]
	{
		savepointStatementType = 2;
	}
|	<RELEASE> [ <TO> ] <SAVEPOINT> savepointName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	{
		savepointStatementType = 3;
	}
	)
	{
		return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.SAVEPOINT_NODE,
								savepointName,
								ReuseFactory.getInteger(savepointStatementType),
								getContextManager());
	}
}

void savepointStatementClause(Object[] savepointStatementClauses) throws StandardException :
{
	int clausePosition = -1;
}
{
	(
		<UNIQUE> {clausePosition = 0;}
	|
		<ON> <ROLLBACK> <RETAIN> (clausePosition = LocksOrCursors())
	)
	{
		if (clausePosition != -1) {
			// check for repeated clause
			if (savepointStatementClauses[clausePosition] != null) {

				String which = SAVEPOINT_CLAUSE_NAMES[clausePosition];
				throw StandardException.newException(SQLState.LANG_DB2_MULTIPLE_ELEMENTS, which);
			}
				
			savepointStatementClauses[clausePosition] = Boolean.TRUE;
		}
	}
}

/*
 * <A NAME="LocksOrCursors">LocksOrCursors</A>
 */
int
LocksOrCursors() :
{
}
{
	<LOCKS>
	{
		return (1);
	}
|
	<CURSORS>
	{
		return (2);
	}
}

/* 
 * <A NAME="globalTemporaryTableDeclaration">globalTemporaryTableDeclaration</A>

	declareTableClauses contains the NOT LOGGED, on commit and on rollback clauses.

	0 - Boolean - NOT LOGGED clause
	1 - Boolean - on commit behavior
	2 - Boolean - on rollback behavior
 */
StatementNode
globalTemporaryTableDeclaration() throws StandardException :
{
	TableName			tableName;
	TableElementList tableElementList;
	Object[] declareTableClauses = new Object[3];
}
{ 
	<DECLARE> <GLOBAL> <TEMPORARY> <TABLE> tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
		tableElementList = tableElementList()
		( declareTableClause(declareTableClauses) ) +
	{
		// NOT LOGGED is mandatory
		if (declareTableClauses[0] == null)
				throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, "MISSING NOT LOGGED");
		// if ON COMMIT behavior not explicitly specified in DECLARE command, resort to default ON COMMIT DELETE ROWS
		if (declareTableClauses[1] == null)
				declareTableClauses[1] = Boolean.TRUE;
		// if ON ROLLBACK behavior not explicitly specified in DECLARE command, resort to default ON ROLLBACK DELETE ROWS
		if (declareTableClauses[2] == null)
				declareTableClauses[2] = Boolean.TRUE;
		return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.CREATE_TABLE_NODE,
								tableName,
								tableElementList,
								(Properties)null,
								(Boolean) declareTableClauses[1],
								(Boolean) declareTableClauses[2],
								getContextManager());
	}
}

void declareTableClause(Object[] declareTableClauses) throws StandardException :
{
	int clausePosition = -1;
	Object clauseValue = null;
}
{
	(
		<NOT> <LOGGED> {clauseValue = Boolean.TRUE; clausePosition = 0;}
	|
		LOOKAHEAD( {getToken(1).kind == ON && getToken(2).kind == COMMIT} )
		<ON> <COMMIT> ( clauseValue = onCommit() ) <ROWS> { clausePosition = 1;} 
	|
		LOOKAHEAD( {getToken(1).kind == ON && getToken(2).kind == ROLLBACK} )
		<ON> <ROLLBACK> <DELETE> <ROWS> { clauseValue = Boolean.TRUE; clausePosition = 2;} 
	)


	{
		if (clausePosition != -1) {
			// check for repeated clause
			if (declareTableClauses[clausePosition] != null) {

				String which = TEMPORARY_TABLE_CLAUSE_NAMES[clausePosition];
				throw StandardException.newException(SQLState.LANG_DB2_MULTIPLE_ELEMENTS, which);
			}
				
			declareTableClauses[clausePosition] = clauseValue;
		}
	}
}

/*
 * <A NAME="onCommit">onCommit</A>
 */
Boolean
onCommit() :
{
}
{
	<PRESERVE>
	{
		return (Boolean.FALSE);
	}
|
	<DELETE>
	{
		return (Boolean.TRUE);
	}
}

/*
 * <A NAME="tableElementList">tableElementList</A>
 */
TableElementList
tableElementList() throws StandardException :
{
	TableElementList	tableElementList =
					(TableElementList) nodeFactory.getNode(
									C_NodeTypes.TABLE_ELEMENT_LIST,
									getContextManager());
}
{
	<LEFT_PAREN> tableElement(tableElementList)
		( <COMMA> tableElement(tableElementList) ) * <RIGHT_PAREN>
	{
		return tableElementList;
	}
}

/*
 * <A NAME="tableElement">tableElement</A>
 */
void
tableElement(TableElementList tableElementList) throws StandardException :
{
	TableElementNode	tableElement;
	//initialize following two booleans for every new table element so that the
	//values from previous tableElement doesn't impact the next tableElement
	explicitNotNull = false;
	explicitNull = false;

}
{
	tableElement = columnDefinition(tableElementList)
	{
		tableElementList.addTableElement(tableElement);
	}
|
	tableElement = tableConstraintDefinition()
	{
		tableElementList.addTableElement(tableElement);
	}
}

/*
 * <A NAME="columnDefinition">columnDefinition</A>
 */
TableElementNode
columnDefinition(TableElementList tableElementList) throws StandardException :
{
	DataTypeDescriptor[]	typeDescriptor = new DataTypeDescriptor[1];
	ValueNode			defaultNode = null;
	String				columnName;
// GemStone changes BEGIN
	long[]				autoIncrementInfo = new long[7];
	/* (original code)
	long[]				autoIncrementInfo = new long[4];
	*/
// GemStone changes END
}
{
	/*
	** RESOLVE: We are ignoring domains and collation.
	*/

	/* identifier() used to be columnName() */
	columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true) 
		( typeDescriptor[0] = dataTypeDDL() 
		)
	[ defaultNode = defaultAndConstraints(typeDescriptor, tableElementList, columnName, autoIncrementInfo) ]
	{
		// Only pass autoincrement info for autoincrement columns
		if (autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_IS_AUTOINCREMENT_INDEX] == 0)
		{
			autoIncrementInfo = null;
		}

		return (TableElementNode) nodeFactory.getNode(
								C_NodeTypes.COLUMN_DEFINITION_NODE,
								columnName,
								defaultNode,
								typeDescriptor[0],
								autoIncrementInfo,
								getContextManager());
	}
}


/*
 * <A NAME="defaultAndConstraints">defaultAndConstraints</A>
 */
ValueNode
defaultAndConstraints(DataTypeDescriptor[] typeDescriptor,
					  TableElementList tableElementList,
					  String columnName,
					  long[] autoIncrementInfo) throws StandardException :
{
	ValueNode		defaultNode = null;
}
{	// compatible with db2 syntax
	columnConstraintDefinition(typeDescriptor, tableElementList, columnName) ( columnConstraintDefinition(typeDescriptor, tableElementList, columnName)) *
	[ defaultNode = defaultClause(autoIncrementInfo, columnName) ( columnConstraintDefinition(typeDescriptor, tableElementList, columnName) )* ]
	{
		return defaultNode;
	}
|
	defaultNode = defaultClause(autoIncrementInfo, columnName)
	( columnConstraintDefinition(typeDescriptor, tableElementList, columnName) ) *
	{
		return defaultNode;
	}
}

/*
 * <A NAME="dataTypeDDL">dataTypeDDL</A>
 */
DataTypeDescriptor
dataTypeDDL() throws StandardException :
{
	DataTypeDescriptor	typeDescriptor;
}
{
	LOOKAHEAD( { commonDatatypeName(false) } )
	typeDescriptor = dataTypeCommon()
	{
		return typeDescriptor;
	}
|
    LOOKAHEAD ( { getToken(1).kind != GENERATED } )
	typeDescriptor = javaType()
	{
		return typeDescriptor;
	}
}

/**
   Returns  a dataTypeDDL() as a catalog type, ie.
   the Java interface TypeDescriptor.
*/
TypeDescriptor
catalogType() throws StandardException :
{
	DataTypeDescriptor	typeDescriptor;
}
{
	typeDescriptor = dataTypeDDL()
	{
		return typeDescriptor.getCatalogType();
	}
}


/*
 * <A NAME="dataTypeCast">dataTypeCast</A>
 */
DataTypeDescriptor
dataTypeCast() throws StandardException :
{
	DataTypeDescriptor	typeDescriptor;
}
{
	// This lookahead is required because the names of the built-in
	// datatypes are not reserved words
	LOOKAHEAD( { commonDatatypeName(true) } )
	typeDescriptor = dataTypeCommon()
	{
		return typeDescriptor;
	}
|
	typeDescriptor = javaType()
	{
		return typeDescriptor;
	}
}

/*
 * <A NAME="dataTypeCommon">dataTypeCommon</A>
 */
DataTypeDescriptor
dataTypeCommon() throws StandardException :
{
	DataTypeDescriptor	typeDescriptor;
	boolean checkCS = false;
}
{
(
	/* RESOLVE: Ignoring decimal, numeric, long */

	/*
	** We are not planning to support character sets, so I commented
	** out characterSetSpecification().
	*/
	( LOOKAHEAD({getToken(2).kind != LARGE})
		typeDescriptor = characterStringType()
	)
		/* [ <CHARACTER> <SET> characterSetSpecification() ] */
|
	( LOOKAHEAD({getToken(3).kind != LARGE})
		typeDescriptor = nationalCharacterStringType()
	)
|
	typeDescriptor = numericType()
|
	typeDescriptor = datetimeType()
| <BOOLEAN>
{
	// checkInternalFeature(TypeId.BOOLEAN_NAME);
	typeDescriptor = new DataTypeDescriptor(TypeId.BOOLEAN_ID, true);
}
|
	typeDescriptor = longType()
|
	typeDescriptor = LOBType()
|
	typeDescriptor = XMLType()
)
	{
		return typeDescriptor;
	}
}

/*
 * <A NAME="characterStringType">characterStringType</A>
 */
DataTypeDescriptor
characterStringType() throws StandardException :
{
	int					length = DEFAULT_STRING_COLUMN_LENGTH;
	Token				varyingToken = null;
	int type;
}
{
  (
	(
		<VARCHAR> length = charLength()
	)
	{
		type = Types.VARCHAR;
	}
|
	charOrCharacter()
	(
		// Length is optional for CHARACTER, not for plain CHARACTER VARYING
		varyingToken = <VARYING> length = charLength() |
		[ length = charLength() ]
	)
	{
		// If the user says CHARACTER VARYING, it's really VARCHAR
		type = (varyingToken == null ? Types.CHAR : Types.VARCHAR);
	}
  ) [ type = forBitData(type) ]

	{
		checkTypeLimits(type,length);
		DataTypeDescriptor charDTD = DataTypeDescriptor.getBuiltInDataTypeDescriptor(type, length);
		return charDTD;
	}
}


/*
 * <A NAME="charOrCharacter">charOrCharacter</A>
 */
void
charOrCharacter() :
{
}
{
	<CHAR> | <CHARACTER>
}

/*
 * <A NAME="charType">charType</A>
 */
int
charLength() throws StandardException :
{
	int length;
}
{
	<LEFT_PAREN> length = length() <RIGHT_PAREN>
	{
		return length;
	}
}

/*
** <A NAME="forBitData">forBitData</A>
*/

int
forBitData(int charType) :
{
}
{
	<FOR> <BIT> <DATA>
	{
		if (charType == Types.CHAR)
			charType = Types.BINARY;
		else if (charType == Types.VARCHAR)
			charType = Types.VARBINARY;
		else if (charType == Types.LONGVARCHAR)
			charType = Types.LONGVARBINARY;

		return charType;
	}
}

/*
 * <A NAME="nationalCharacterStringType">nationalCharacterStringType</A>
 */
DataTypeDescriptor
nationalCharacterStringType() throws StandardException :
{
	DataTypeDescriptor	dataTypeDescriptor;
	int					length = DEFAULT_STRING_COLUMN_LENGTH;
	String				type = null;
	Token				varyingToken = null;
}
{
(
	<NATIONAL> charOrCharacter() 
	(
		// Length is optional for NATIONAL CHARACTER , not for NATIONAL CHARACTER VARYING
		varyingToken = <VARYING> length = charLength() |
		[ length = charLength() ]
	)
	{

		// If the user says NATIONAL CHARACTER VARYING, it's really NATIONALVARCHAR
		type = (varyingToken == null ? TypeId.NATIONAL_CHAR_NAME : 
				TypeId.NATIONAL_VARCHAR_NAME);
	}
|
	<NCHAR> 
	(
		// Length is optional for NCHAR, not for NCHAR VARYING
		varyingToken = <VARYING> length = charLength() |
		[ length = charLength() ]
	)
	{
		// If the user says NCHAR VARYING, it's really NATIONALVARCHAR
		type = (varyingToken == null ? TypeId.NATIONAL_CHAR_NAME : 
				TypeId.NATIONAL_VARCHAR_NAME);

	}
|
	<NVARCHAR> 
	(
		length = charLength()
	)
	{
		type = TypeId.NATIONAL_VARCHAR_NAME;
	}
)

	{
		// need to re-enable according to SQL standard
		throw StandardException.newException(SQLState.NOT_IMPLEMENTED, type);
		// return DataTypeDescriptor.getBuiltInDataTypeDescriptor(type, length);
	} 
}

/*
 * <A NAME="LOBType">lobType</A>
 */
DataTypeDescriptor
LOBType() throws StandardException :
{
	int	length = 2147483647; // default to 2GB-1 if no length specified
	String	type;
}
{
	(
		<BLOB> [ length = lengthAndModifier() ]
		{
			type = TypeId.BLOB_NAME;
		}
	|
		<CLOB> [ length = lengthAndModifier() ]
		{
			type = TypeId.CLOB_NAME;
		}
	|
        <CLOB_STRING> [ length = lengthAndModifier() ]
        {
    	    type = TypeId.CLOB_NAME;
        }
	|
		<JSON> [ length = lengthAndModifier() ]
		{
			type = TypeId.JSON_NAME;
		}
	|
		<NCLOB> length = lengthAndModifier()
		{
			type = TypeId.NCLOB_NAME;
			// need to re-enable according to SQL standard
			throw StandardException.newException(SQLState.NOT_IMPLEMENTED, type);
		}
	|
		<BINARY> [ <LARGE> <OBJECT> ] [ length = lengthAndModifier() ]
		{
			type = TypeId.BLOB_NAME;
		}
	|
		charOrCharacter() <LARGE> <OBJECT> [ length = lengthAndModifier() ]
		{
			type = TypeId.CLOB_NAME;
		}
	|
		<NATIONAL> <CHARACTER> <LARGE> <OBJECT> length = lengthAndModifier()
		{
			type = TypeId.NCLOB_NAME;
			// need to re-enable according to SQL standard
			throw StandardException.newException(SQLState.NOT_IMPLEMENTED, type);
		}
	)
	{
		DataTypeDescriptor dtd = DataTypeDescriptor.getBuiltInDataTypeDescriptor(type, length);

		return dtd;
	}
}

/*
 * <A NAME="numericType">numericType</A>
 */
DataTypeDescriptor
numericType() throws StandardException :
{
	DataTypeDescriptor	typeDescriptor;
}
{
	typeDescriptor = exactNumericType()
	{
		return typeDescriptor;
	}
|
	typeDescriptor = approximateNumericType()
	{
		return typeDescriptor;
	}
}

/*
 * <A NAME="exactNumericType">exactNumericType</A>
 */
DataTypeDescriptor
exactNumericType() throws StandardException :
{
	int precision = TypeCompiler.DEFAULT_DECIMAL_PRECISION;
	int scale = TypeCompiler.DEFAULT_DECIMAL_SCALE;
	int type = Types.DECIMAL;
	String typeStr = "DECIMAL";
	int maxWidth;
	DataTypeDescriptor dtd =  null;
}
{
	( <NUMERIC> 
	{
		type = Types.NUMERIC;
		typeStr = "NUMERIC";
	}
	| <DECIMAL> | <DEC> )
    //GemStone changes BEGIN
    //inserting switchOptimizeLiteral in between.
    //originally [ <LEFT_PAREN> precision = precision() [ <COMMA> scale = scale() ] <RIGHT_PAREN> ]
	[ <LEFT_PAREN> 
	    {boolean existing = getCompilerContext().switchOptimizeLiteral(false);} 
    
        precision = precision() [ <COMMA> scale = scale() ]
        
      <RIGHT_PAREN>
        {getCompilerContext().switchOptimizeLiteral(existing); } 
	]
    //GemStone changes END
	{
		if ((precision <= 0) || 
			(precision > TypeCompiler.MAX_DECIMAL_PRECISION_SCALE))
		{
			throw StandardException.newException(SQLState.LANG_INVALID_PRECISION, 
				typeStr, String.valueOf(precision));
		} 
		else if ((scale < 0) || 
				 (scale > TypeCompiler.MAX_DECIMAL_PRECISION_SCALE))
		{
			throw StandardException.newException(SQLState.LANG_INVALID_DECIMAL_SCALE, 
				typeStr, String.valueOf(scale));
		}
		else if (scale > precision)
		{
			throw StandardException.newException(SQLState.LANG_INVALID_DECIMAL_PRECISION_SCALE, 
				String.valueOf(scale),
				String.valueOf(precision));
		}
		/*
		** If we have a decimal point, need to count it
		** towards maxwidth.  Max width needs to account
		** for the possible leading '0' and '-' and the
		** decimal point.  e.g., DEC(1,1) has a maxwidth
		** of 4 (to handle "-0.1").
		*/
		maxWidth = DataTypeUtilities.computeMaxWidth( precision, scale);
		return getDataTypeServices(type, precision, scale, maxWidth);
	}
	|
		dtd = exactIntegerType()
		{
			return dtd;
		}
}

/*
 * <A NAME="exactNumericType">exactNumericType</A>
 */
DataTypeDescriptor
exactIntegerType() throws StandardException :
{

}
{
	(<INTEGER> | <INT>)
	{
		return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.INTEGER);
	}
|
	<SMALLINT>
	{
		return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.SMALLINT);
	}
|
	<LONGINT>
	{
		return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.BIGINT);
	}
|
	(<SHORT> | <TINYINT> | <BYTE> )
	{
		return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.SMALLINT);
	}
}

/*
 * <A NAME="approximateNumericType">approximateNumericType</A>
 */
DataTypeDescriptor
approximateNumericType() throws StandardException :
{
	int type = 0, scale = 0, width = 0;
	int prec = -1;
	DataTypeDescriptor dts = null;
}
{
	<FLOAT> [ <LEFT_PAREN> prec = precision() <RIGHT_PAREN> ]
	{
		/*
			When not specified, default is DOUBLE_PRECISION
		 */
		if (prec == -1)
			prec = TypeId.DOUBLE_PRECISION;

		if (prec > 0 && prec <= TypeId.REAL_PRECISION)
		{
			type = Types.REAL;
			prec = TypeId.REAL_PRECISION;
			scale = TypeId.REAL_SCALE;
			width = TypeId.REAL_MAXWIDTH;
		}
		else if (prec > TypeId.REAL_PRECISION &&
				 prec <= TypeId.DOUBLE_PRECISION)
		{
			type = Types.DOUBLE;
			prec = TypeId.DOUBLE_PRECISION;
			scale = TypeId.DOUBLE_SCALE;
			width = TypeId.DOUBLE_MAXWIDTH;
		}
		else
			throw StandardException.newException(SQLState.LANG_INVALID_PRECISION, "FLOAT", String.valueOf(prec));

		/*
			REMIND: this is a slight hack, in that exacting reading of
			the InformationSchema requires that the type the user typed
			in be visible to them in the InformationSchema views. But
			most implementations use synonyms or mappings at some point,
			and this is one of those places, for us.
		 */
		return getDataTypeServices(type, prec, scale, width);
	}
| 
	<REAL>
	{
		return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.REAL);
	}
|
		dts = doubleType()
	{
		return dts;
	}
}

/*
 * <A NAME="doubleType">doubleType</A>
 */
DataTypeDescriptor
doubleType() throws StandardException :

{

}
{
	( LOOKAHEAD({getToken(2).kind == PRECISION}) <DOUBLE> <PRECISION> | <DOUBLE> )
	{
		return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.DOUBLE);
	}
}


/*
 * <A NAME="longType">longType</A>
 */
DataTypeDescriptor
longType() throws StandardException :
{
	DataTypeDescriptor	dataTypeDescriptor;
}
{
	<LONG> dataTypeDescriptor = longSubType()
	{
		return dataTypeDescriptor;
	}
}


DataTypeDescriptor
longSubType() throws StandardException :
{
	int lvcType = Types.LONGVARCHAR;
}
{
	<VARCHAR> [ lvcType = forBitData(lvcType) ]
	{
		return DataTypeDescriptor.getBuiltInDataTypeDescriptor(lvcType);
	}
|
	<NVARCHAR> 
	{
		// need to re-enable according to SQL standard
		throw StandardException.newException(SQLState.NOT_IMPLEMENTED, TypeId.NATIONAL_LONGVARCHAR_NAME);
		// return DataTypeDescriptor.getBuiltInDataTypeDescriptor(TypeId.NATIONAL_LONGVARCHAR_NAME);
	}
|
    {
        return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.BIGINT);
    }
}

/*
 * <A NAME="XMLType">XMLType</A>
 */
DataTypeDescriptor
XMLType() throws StandardException :
{
	DataTypeDescriptor value;
}
{
	<XML>
	{
		checkVersion(DataDictionary.DD_VERSION_DERBY_10_1, "XML");
		return DataTypeDescriptor.getBuiltInDataTypeDescriptor(
			JDBC40Translation.SQLXML);
	}
}

/*
 * <A NAME="xmlDocOrContent">xmlDocOrContent</A>
 *
 * Parse the XML keywords DOCUMENT and CONTENT.  We don't
 * support CONTENT yet, so we throw an appropriate error
 * if we see it.
 *
 */
void
xmlDocOrContent() throws StandardException :
{
}
{
	LOOKAHEAD({ (getToken(1).kind != DOCUMENT) &&
		(getToken(1).kind != CONTENT) })
	{
		throw StandardException.newException(
			SQLState.LANG_XML_KEYWORD_MISSING, "DOCUMENT",
			ReuseFactory.getInteger(getToken(1).beginLine),
			ReuseFactory.getInteger(getToken(1).beginColumn));
	}
|
	LOOKAHEAD({ getToken(1).kind == CONTENT }) <CONTENT>
	{
		throw StandardException.newException(
			SQLState.LANG_UNSUPPORTED_XML_FEATURE, "CONTENT");
	}
|
	LOOKAHEAD({ getToken(1).kind == DOCUMENT }) <DOCUMENT>
	{
		return;
	}
}

/*
 * <A NAME="javaType">javaType</A>
 */
DataTypeDescriptor
javaType() throws StandardException :
{
	TableName	typeName;
}
{
	typeName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
	{
		return getJavaClassDataTypeDescriptor(typeName);
	}
}

/*
 * <A NAME = "javaDSL">javaDSL</A>
 *
 * A Java dot-separated list.
 */
String
javaDSL() :
{
	String dotSeparatedList;
}
{
	dotSeparatedList = caseSensitiveIdentifierPlusReservedWords()
		( dotSeparatedList = javaDSLNameExtender(dotSeparatedList) ) *
	{
		return dotSeparatedList;
	}
}


/*
 * <A NAME="javaClassName">javaClassName</A>
 */
String
javaClassName() :
{
	String javaClassName;
}
{
	javaClassName = javaDSL()
	{
		return javaClassName;
	}
}

/*
 * <A NAME="javaDSLNameExtender">javaDSLNameExtender</A>
 */
String
javaDSLNameExtender(String dotSeparatedList)  :
{
	String	extender;
}
{
	<PERIOD> extender = caseSensitiveIdentifierPlusReservedWords()
	{
		return dotSeparatedList + "." + extender;
	}
// GemStone changes BEGIN
|
	<DOLLAR> extender = caseSensitiveIdentifierPlusReservedWords()
	{
		return dotSeparatedList + "$" + extender;
	}
// GemStone changes END
}

/*
 * <A NAME="length">lengthAndModifier</A>
 */
int
lengthAndModifier() throws StandardException :
{
	Token	tok;
	Token	tokmod = null;
}
{
	<LEFT_PAREN> 
	// we have essentially 3 different ways of specifying the length of a LOB
	( tok = <LENGTH_MODIFIER>					// LOB(33K)
	| tok = <EXACT_NUMERIC> [ tokmod = <IDENTIFIER> ] )		// LOB(33) or LOB(33 K)
	<RIGHT_PAREN>
	{
		String s = tok.image + (tokmod==null ? "" : tokmod.image); // colapse cases;
		try
		{
			char modifier = s.charAt(s.length()-1);
			String number = s.substring(0, s.length()-1); // in case of ending w. letter
			long mul;
			switch (modifier) {
			case 'G': 
			case 'g':
				mul =1073741824L;	//1 Giga
				break;
			case 'M':
			case 'm':
				mul=1048576L;		// 1 Mega
				break;
			case 'K':
			case 'k':
				mul=1024L;		// 1 Kilo
				break;
			default:
				mul=1;
				number = s; // no letter in end, need whole string
				break;
			}
			long	specifiedLength = Long.parseLong(number) * mul;
			
			// match DB2 limits of 1 to 2147483647
			if ((specifiedLength > 0L) && 
                (specifiedLength <= Limits.DB2_LOB_MAXWIDTH))
            {
				return (int)specifiedLength;
            }

			// DB2 allows 2G or 2048M or 2097152k that calculate out to 
            // 2147483648, but sets the length to be one less.
			if (mul != 1 && specifiedLength == 2147483648L)
				return Limits.DB2_LOB_MAXWIDTH;
				
		}
		catch (NumberFormatException nfe)
		{
		}

		throw StandardException.newException(
            SQLState.LANG_INVALID_COLUMN_LENGTH, s);
	}
}

/*
 * <A NAME="length">length</A>
 */
int
length() throws StandardException :
{
	Token	tok;
	int	retval;
}
{
	tok = <EXACT_NUMERIC>
	{
		try
		{
			retval = Integer.parseInt(tok.image);

			if (retval > 0)
				return retval;
		}
		catch (NumberFormatException nfe)
		{
		}
		throw StandardException.newException(SQLState.LANG_INVALID_COLUMN_LENGTH, tok.image);
	}
}


/*
 * <A NAME="exactNumber">exactNumber</A>
*/
long
exactNumber() throws StandardException :
{
	Token longToken;
	String sign = "";
}
{
	[ sign = sign() ] longToken = <EXACT_NUMERIC>
	{
		try 
		{
			/*
			 * Note that it's important to re-concatenate
			 * the - sign (if present) into the number
			 * before converting it to a long value so
			 * that we can successfully handle any value
			 * in the range Long.MIN_VALUE ... Long.MAX_VALUE.
			 * Unfortunately, we can't simply do:
			 *     return Long.parseLong(sign+longToken.image);
			 * because Long.parseLong() doesn't accept a
			 * leading + sign.
			 */

			if (sign.equals("-"))
			{
				return Long.parseLong("-"+longToken.image);
			}
			else
			{
				return Long.parseLong(longToken.image);
			}
		}
		catch (NumberFormatException nfe)
		{
			throw
			StandardException.newException(
				   SQLState.LANG_INVALID_INTEGER_LITERAL, longToken.image);
		}
	}
}
/*
 * <A NAME="precision">precision</A>
 */
int
precision() throws StandardException :
{
	int uintValue;
}
{
	uintValue = uint_value()
	{
		return uintValue;
	}
}

/*
 * <A NAME="uint_value">uint_value</A>
 */
int 
uint_value() throws StandardException :
{
	Token uintToken;
}
{
	/*
		because the parser won't match to UINT, we use EXACT_NUMERIC.
	 */
	uintToken = <EXACT_NUMERIC>
	{
		try {
			return Integer.parseInt(uintToken.image);
		} catch (NumberFormatException nfe) {
			throw StandardException.newException(SQLState.LANG_INVALID_INTEGER_LITERAL, uintToken.image);
		}
	}
}

/*
 * <A NAME="scale">scale</A>
 */
int
scale() throws StandardException :
{
	int uintValue;
}
{
	uintValue = uint_value()
	{
		return uintValue;
	}
}


/*
 * <A NAME="datetimeType">datetimeType</A>
 */
DataTypeDescriptor
datetimeType() throws StandardException :
{
	Token tzTok = null;
	int prec = -1; // know the value back is positive and in range
}
{
	<DATE> 
	{
		return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.DATE);
	}
|
	<TIME> 
	{

		/*
			We do not try to set up a precision for time/timestamp
			values because this field gets mapped to the precision
			field in the JDBC driver that is for the number of
			decimal digits in the value.  Precision for time is
			actually the scale of the seconds value.

			If/when precision for times is supported, we may need
			to migrate the system catalog information to fill in
			the default values appropriately (the default for
			time is 0, fortunately; but for timestamp it is
			actually 9 due to java.sql.Timestamp's precision).
		 */
		return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.TIME);
	}
|
	<TIMESTAMP> 
	{

		return DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.TIMESTAMP);
	}
}

/*
 * <A NAME="timePrecision">timePrecision</A>
 */

void
qualifiedNameList(Vector list, int id_length_limit) throws StandardException :
{
}
{
	qualifiedNameElement(list, id_length_limit) ( <COMMA> qualifiedNameElement(list, id_length_limit) ) *
}

void 
qualifiedNameElement(Vector list, int id_length_limit) throws StandardException :
{
	TableName qualifiedName = null;
}
{
	qualifiedName = qualifiedName(id_length_limit)
	{
		list.addElement(qualifiedName);
	}
}

/*
 * <A NAME="qualifiedName">qualifiedName</A>
 */
TableName
qualifiedName( int nodeType, int id_length_limit) throws StandardException :
{
	//String	catalogName = null;
	String	schemaName = null;
	String	qualifiedId;
	String	firstName = null;
	String	secondName = null;
}
{
	firstName = identifier(Limits.MAX_IDENTIFIER_LENGTH, false)
				[
					// This LOOKAHEAD is necessary because a selectSublist()
					// can be a qualifiedName.*. Make sure that the token after
					// the PERIOD is not an ASTERISK before committing to this
					// optional element.
					LOOKAHEAD( {getToken(1).kind == PERIOD &&
								getToken(2).kind != ASTERISK} )
					<PERIOD> secondName = identifier(Limits.MAX_IDENTIFIER_LENGTH, false)
				]
	{
		if (secondName == null)
		{
			qualifiedId = firstName;
		}
		else
		{
			schemaName = firstName;
			qualifiedId = secondName;
		}

		//limit the qualifiedId to the id length limit passed to this method
		checkIdentifierLengthLimit(qualifiedId, id_length_limit);
		if (schemaName != null)
			checkIdentifierLengthLimit(schemaName, Limits.MAX_IDENTIFIER_LENGTH);

		return (TableName) nodeFactory.getNode(
								nodeType,
								schemaName,
								qualifiedId,
// GemStone changes BEGIN
								// changed to use Integer.valueOf()
								Integer.valueOf(lastIdentifierToken.beginOffset),
								Integer.valueOf(lastIdentifierToken.endOffset),
// GemStone changes END
								getContextManager());
	}
}

/*
 * <A NAME="queryExpression">queryExpression</A>
 *
 * We have to be carefull to get the associativity correct. According to the SQL spec
 *   <non-join query expression> ::=
 *     <non-join query term>
 *    | <query expression body> UNION [ ALL ] <query term>
 *    | <query expression body> EXCEPT [ ALL ] <query term>
 * Meaning that
 *   t1 UNION ALL t2 UNION t3
 * is equivalent to
 *   (t1 UNION ALL t2) UNION t3
 * However recursive descent parsers want recursion to be on the right, so this kind of associativity is unnatural
 * for our parser. The queryExpression method must know whether it is being called as the right hand side of a
 * set operator to produce a query tree with the correct associativity.
 */
ResultSetNode
queryExpression(ResultSetNode leftSide, int operatorType) throws StandardException :
{
	ResultSetNode	term;
	getCompilerContext().pushDML(0);
}
{
	term = nonJoinQueryTerm(leftSide, operatorType) [ term = unionOrExcept(term) ]
	{
	    getCompilerContext().popDML(0);
		return term;
	}
}

/*
 * <A NAME="unionOrExcept">unionOrExcept</A>
 */
ResultSetNode
unionOrExcept(ResultSetNode term) throws StandardException :
{
	ResultSetNode	expression;
	Token 			tok = null;
}
{
	<UNION> [ tok = <ALL> | <DISTINCT> ] expression =
				queryExpression(term,
								(tok != null) ? UNION_ALL_OP : UNION_OP)
	{
		return expression;
	}
|
	<EXCEPT> [ tok = <ALL> | <DISTINCT> ] expression =
				queryExpression(term,
								(tok != null) ? EXCEPT_ALL_OP : EXCEPT_OP)
	{
		return expression;
	}
}


/*
 * <A NAME="nonJoinQueryTerm">nonJoinQueryTerm</A>
 *
 * Be careful with the associativity of INTERSECT. According to the SQL spec
 *   t1 INTERSECT t2 INTERSECT ALL t3
 * is equivalent to
 *   (t1 INTERSECT t2) INTERSECT ALL t3
 * which is not the same as
 *   t1 INTERSECT (t2 INTERSECT ALL t3)
 * See the comment on queryExpression.
 */
ResultSetNode
nonJoinQueryTerm(ResultSetNode leftSide, int operatorType) throws StandardException :
{
	ResultSetNode	term;
}
{
	term = nonJoinQueryPrimary() [ term = intersect( term) ]
	{
        switch( operatorType)
        {
        case NO_SET_OP:
            return term;

        case UNION_OP:
            return (ResultSetNode) nodeFactory.getNode(
                C_NodeTypes.UNION_NODE,
                leftSide,
                term,
                Boolean.FALSE,
                Boolean.FALSE,
                null,
                getContextManager());

        case UNION_ALL_OP:
            return (ResultSetNode) nodeFactory.getNode(
                C_NodeTypes.UNION_NODE,
                leftSide,
                term,
                Boolean.TRUE,
                Boolean.FALSE,
                null,
                getContextManager());

        case EXCEPT_OP:
            return (ResultSetNode) nodeFactory.getNode(
                C_NodeTypes.INTERSECT_OR_EXCEPT_NODE,
                ReuseFactory.getInteger( IntersectOrExceptNode.EXCEPT_OP),
                leftSide,
                term,
                Boolean.FALSE,
                null,
                getContextManager());

        case EXCEPT_ALL_OP:
            return (ResultSetNode) nodeFactory.getNode(
                C_NodeTypes.INTERSECT_OR_EXCEPT_NODE,
                ReuseFactory.getInteger( IntersectOrExceptNode.EXCEPT_OP),
                leftSide,
                term,
                Boolean.TRUE,
                null,
                getContextManager());

        case INTERSECT_OP:
            return (ResultSetNode) nodeFactory.getNode(
                C_NodeTypes.INTERSECT_OR_EXCEPT_NODE,
                ReuseFactory.getInteger( IntersectOrExceptNode.INTERSECT_OP),
                leftSide,
                term,
                Boolean.FALSE,
                null,
                getContextManager());

        case INTERSECT_ALL_OP:
            return (ResultSetNode) nodeFactory.getNode(
                C_NodeTypes.INTERSECT_OR_EXCEPT_NODE,
                ReuseFactory.getInteger( IntersectOrExceptNode.INTERSECT_OP),
                leftSide,
                term,
                Boolean.TRUE,
                null,
                getContextManager());


        default:
            if (SanityManager.DEBUG)
            {
                SanityManager.THROWASSERT( "Invalid set operator type: " + operatorType);
            }
            return null;
        }
    }
}

/*
 * <A NAME="intersect">intersect</A>
 */
ResultSetNode
intersect(ResultSetNode term) throws StandardException :
{
	ResultSetNode	expression;
	Token 			tok = null;
}
{
	<INTERSECT> [ tok = <ALL> | <DISTINCT> ] expression =
				nonJoinQueryTerm(term, (tok != null) ? INTERSECT_ALL_OP : INTERSECT_OP)
	{
		return expression;
	}
}

/*
 * <A NAME="nonJoinQueryPrimary">nonJoinQueryPrimary</A>
 */
ResultSetNode
nonJoinQueryPrimary() throws StandardException :
{
	ResultSetNode	primary;
}
{
	primary = simpleTable()
	{
		return primary;
	}
|
	<LEFT_PAREN> primary = queryExpression(null, NO_SET_OP) <RIGHT_PAREN>
	{
		return primary;
	}
}

/*
 * <A NAME="simpleTable">simpleTable</A>
 */
ResultSetNode
simpleTable() throws StandardException :
{
	ResultSetNode	resultSetNode;
}
{
	resultSetNode = querySpecification()
	{
		return resultSetNode;
	}
|
	resultSetNode = tableValueConstructor()
	{
		return resultSetNode;
	}
}

/*
 * <A NAME="querySpecification">querySpecification</A>
 */
ResultSetNode
querySpecification() throws StandardException :
{
	ResultColumnList	selectList;
	SelectNode			selectNode;
	boolean	isDistinct = false;
}
{
	<SELECT> [ isDistinct = setQuantifier() ]
		selectList = selectList()
		selectNode = tableExpression(selectList)
	{
		if (isDistinct) selectNode.makeDistinct();
		return selectNode;
	}
}

/*
 * <A NAME="setQuantifier">setQuantifier</A>
 */
boolean
setQuantifier() :
{}
{
	// This lookahead is required to distinquish distinct from
	// a class which starts with distinct (e.g., distinct::)
	LOOKAHEAD
	(
		{
			getToken(1).kind == DISTINCT &&
			!(
				getToken(2).kind == PERIOD ||
				getToken(2).kind == DOUBLE_COLON
			)
		}
	)
	<DISTINCT>
	{
		return true;
	}
|
	// This lookahead is required to distinquish all from
	// a class which starts with all (e.g., all::)
	LOOKAHEAD
	(
		{
			getToken(1).kind == ALL &&
			!(
				getToken(2).kind == PERIOD ||
				getToken(2).kind == DOUBLE_COLON
			)
		}
	)
	<ALL>
	{
		return false;
	}
}

/*
 * <A NAME="selectList">selectList</A>
 */
ResultColumnList
selectList() throws StandardException :
{
	ResultColumn	allResultColumn;
	ResultColumnList	resultColumns = (ResultColumnList) nodeFactory.getNode(
									C_NodeTypes.RESULT_COLUMN_LIST,
									getContextManager());
}
{
	<ASTERISK>
	{
		allResultColumn = (ResultColumn) nodeFactory.getNode(
										C_NodeTypes.ALL_RESULT_COLUMN,
										null,
										getContextManager());
		/* Add the new AllResultColumn to the end of the list */
		resultColumns.addResultColumn(allResultColumn);
		return resultColumns;
	}
|
	selectColumnList(resultColumns)
	{
		return resultColumns;
	}
}

void
selectColumnList(ResultColumnList resultColumns) throws StandardException :
{
}
{
	selectSublist(resultColumns) ( <COMMA> selectSublist(resultColumns) ) *
}

/*
 * <A NAME="selectSublist">selectSublist</A>
 */
void
selectSublist(ResultColumnList resultColumns) throws StandardException :
{
	ResultColumn	resultColumn;
	ResultColumn	allResultColumn;
	TableName	tableName;
    String          columnName = null;

}
{
	// This LOOKAHEAD is required because both a qualifiedName() and a
	// derivedColumn() can start with an identifier().  So, the two cases
	// we check for are x.* and x.y.*
	//
	// NOTE: It is hard to check for an identifier() using semantic lookahead.
	LOOKAHEAD
	(
		{
			getToken(2).kind == PERIOD &&
			(
				getToken(3).kind == ASTERISK ||
				(getToken(4).kind == PERIOD && getToken(5).kind == ASTERISK)
			)
		}
	)
	tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH) <PERIOD> <ASTERISK>
	{
		allResultColumn = (ResultColumn) nodeFactory.getNode(
										C_NodeTypes.ALL_RESULT_COLUMN,
										tableName,
										getContextManager());
		/* Add the new AllResultColumn to the end of the list */
		resultColumns.addResultColumn(allResultColumn);
	}
|
		/*
		 *  Lookahead to find window functions in unnamed windows
		 *  TODO: Use a method rather than the explicit function names?
		 *        Probably belongs in derivedColum()
		 */
		LOOKAHEAD(
		{
			getToken(1).kind == ROW_NUMBER &&
			getToken(2).kind == LEFT_PAREN &&
			getToken(3).kind == RIGHT_PAREN
		}
		)
		<ROW_NUMBER> <LEFT_PAREN> <RIGHT_PAREN>        

		/* 
		 * TODO: <windowspecification> is ignored for now, but OVER is required
		 */
		<OVER> <LEFT_PAREN> <RIGHT_PAREN>

		[ columnName = asClause() ]
		{
			/*
			 * If there is no AS clause, use the windowfunction name as the result column name.
			 */
			WindowNode windowNode = (WindowNode) nodeFactory.getNode(
											C_NodeTypes.WINDOW_NODE,
											null,  // name
											null,  // partition definition list
											null,  // order by list
											null,  // frame definition
											getContextManager());
			ValueNode expression = (ValueNode) nodeFactory.getNode(
											C_NodeTypes.ROW_NUMBER_COLUMN_NODE,
											windowNode,
											getContextManager());
            // Set the column name in the valuenode
            ((ResultColumn) expression).setName(columnName);
			resultColumn = (ResultColumn) nodeFactory.getNode(
											C_NodeTypes.RESULT_COLUMN,
											columnName,
											expression,
											getContextManager());
			/* Add the new ResultColumn to the end of the list */
			resultColumns.addResultColumn(resultColumn);
		}
|
	resultColumn = derivedColumn(resultColumns)
	{
		/* Add the new ResultColumn to the end of the list */
		resultColumns.addResultColumn(resultColumn);
	}
}

/*
 * <A NAME="derivedColumn">derivedColumn</A>
 */
ResultColumn
derivedColumn(ResultColumnList resultColumns) throws StandardException :
{
	ValueNode	columnExpression;
	String		columnName = null;
}
{
	//true to additiveExpression ensures that for the derived columns, we will not allow boolean values inside (), 
	//eg (2 > 1) should be disallowed in the select clause
	columnExpression = additiveExpression(null, 0, true) 
			[ columnName = asClause() ]
	{ 
		/*
		** If there is no AS clause, and the expression is a simple
		** column, use the name of the column as the result column
		** name.
		*/
		if ((columnName == null) && (columnExpression instanceof ColumnReference))
		{
			columnName = ((ColumnReference) columnExpression).columnName;
		}

		return (ResultColumn) nodeFactory.getNode(
						C_NodeTypes.RESULT_COLUMN,
						columnName,
						columnExpression,
						getContextManager());
	}
}

/*
 * <A NAME="asClause">asClause</A>
 */
String
asClause() throws StandardException :
{
	String	columnName;
}
{
	/* identifier() used to be columnName() */
	[ <AS> ] columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	{
		return columnName;
	}
}

/*
 * <A NAME="valueExpression">valueExpression</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
ValueNode
valueExpression( boolean inSelectClause ) throws StandardException :
{
	ValueNode	leftOperand;
}
{
	leftOperand = orExpression(null, inSelectClause)
		(<OR> leftOperand = orExpression(leftOperand, inSelectClause) ) *
	{

		return leftOperand;
	}
}
	
/*
 * <A NAME="orExpression">orExpression</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
ValueNode
orExpression(ValueNode farLeftOperand, boolean inSelectClause) throws StandardException :
{
	ValueNode	leftOperand;
}
{
	leftOperand = andExpression(null, inSelectClause)
		(<AND> leftOperand = andExpression(leftOperand, inSelectClause)) *
	{
		if (farLeftOperand == null)
		{
			return leftOperand;
		}
		else
		{
			return (ValueNode) nodeFactory.getNode(
										C_NodeTypes.OR_NODE,
										farLeftOperand,
										leftOperand,
										getContextManager());
		}
	}
}

/*
 * <A NAME="andExpression">andExpression</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
ValueNode
andExpression(ValueNode farLeftOperand, boolean inSelectClause) throws StandardException :
{
	Token		tok = null;
	ValueNode	test;
}
{
	//LOOKAHEAD required to tell that NOT is not part of a class name
	[ LOOKAHEAD({getToken(1).kind == NOT && !(getToken(2).kind == PERIOD ||
			getToken(2).kind == DOUBLE_COLON)}) tok = <NOT> ] test = isSearchCondition(inSelectClause) 
	{
		/* Put the NOT on top of test */
		if (tok != null)
		{
			test = (ValueNode) nodeFactory.getNode(
									C_NodeTypes.NOT_NODE,
									test,
									getContextManager());
		}

		if (farLeftOperand != null)
		{
			test = (ValueNode) nodeFactory.getNode(
										C_NodeTypes.AND_NODE,
										farLeftOperand,
										test,
										getContextManager());
		}
		return test;
	}
}

/*
 * <A NAME="isSearchCondition">isSearchCondition</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
ValueNode
isSearchCondition( boolean inSelectClause ) throws StandardException :
{
	ValueNode	result;
	ValueNode	booleanPrimary;
	Token		isToken = null;
	Token		notToken = null;
	Token		truthValue = null;
}
{
	booleanPrimary = booleanPrimary(inSelectClause)
	[
		isToken = <IS> [ notToken = <NOT> ] <NULL>
	]
	{
		if ( isToken != null )
		{
				result = (ValueNode) nodeFactory.getNode(
											C_NodeTypes.IS_NULL_NODE,
											booleanPrimary,
											getContextManager());
		
				/* Put the NOT on top of the tree */
				if (notToken != null)
				{
					result = (ValueNode) nodeFactory.getNode(
											C_NodeTypes.NOT_NODE,
											result,
											getContextManager());
				}
		}
		else { result = booleanPrimary; }

		return result;
	}
}

/*
 * <A NAME="booleanPrimary">booleanPrimary</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
ValueNode
booleanPrimary(boolean inSelectClause) throws StandardException :
{
	ValueNode	primary;
	ValueNode	searchCondition;
}
{
	primary = predicate(inSelectClause)
	{
		return	primary;
	}
}

/*
 * <A NAME="predicate">predicate</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
ValueNode
predicate( boolean inSelectClause ) throws StandardException :
{
	ValueNode	value;
}
{
	(
		value = additiveExpression(null, 0, inSelectClause) |
		value = existsExpression()
	)
	(
		// This LOOKAHEAD is necessary because remainingPredicate() can
		// start with NOT, and what follows a predicate() can also start
		// with NOT
		LOOKAHEAD( { remainingPredicateFollows() } )
		value = remainingPredicate(value, inSelectClause)
	)*
	{
		return value;
	}
/*
** RESOLVE: overlapsExpression commented out for the time being to avoid
** a left recursion.  An OVERLAPS expression is defined as taking row
** constructors as parameters.  A row constructor contains a valueExpression
** as its first element, so it can't return be the first element in a
** valueExpression.

|
	overlapsExpression()
	{
		return null;
	}
*/
}

/*
 * <A NAME="remainingPredicates">remainingPredicates</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
ValueNode
remainingPredicate(ValueNode value, boolean inSelectClause) throws StandardException :
{
	Token tok = null;
}
{
	value = remainingNonNegatablePredicate(value, inSelectClause)
	{
		return value;
	}
|
	[ tok = <NOT> ] value = remainingNegatablePredicate(value, inSelectClause)
	{
		/* Put the NOT on top of the tree */
		if (tok != null)
		{
			value = (ValueNode) nodeFactory.getNode(
										C_NodeTypes.NOT_NODE,
										value,
										getContextManager());
		}

		return value;
	}
}

/*
 * <A NAME="remainingNonNegatablePredicate">remainingNonNegatablePredicate</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
ValueNode 
remainingNonNegatablePredicate(ValueNode leftOperand, boolean inSelectClause) throws StandardException :
{
	int			operator;
	String		javaClassName;
	Token 		tok = null;
	ValueNode	tree = null;
	ValueNode	likePattern;
	ValueNode	betweenLeft;
	ValueNode	betweenRight;
}
{
	operator = compOp()
	(
		// Lookahead required here to tell ALL, ANY or SOME from a 
		// class which starts with these words (e.g., ALL::)
		LOOKAHEAD({(getToken(1).kind == ALL || getToken(1).kind == ANY || 
			getToken(1).kind == SOME) && getToken(2).kind == LEFT_PAREN})
		(
			operator = quantifier(operator)
			<LEFT_PAREN>
			leftOperand = tableSubquery(operator, leftOperand)
			<RIGHT_PAREN>
		)
		|
		(
			leftOperand = additiveExpression(leftOperand, operator, inSelectClause)
		)
	)
	{
		return leftOperand;
	}
}

/*
 * <A NAME="remainingNegatablePredicate">remainingNegatablePredicate</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
ValueNode 
remainingNegatablePredicate(ValueNode leftOperand, boolean inSelectClause) throws StandardException :
{
	ValueNode	tree = null;
	ValueNode	likePattern;
	ValueNode	betweenLeft;
	ValueNode	betweenRight;
	ValueNode	escapeValue = null;
}
{
	<IN> tree = inPredicateValue(leftOperand)
	{
		return tree;
	}
|
	<LIKE> likePattern = additiveExpression(null, 0, inSelectClause)
            [
                <ESCAPE> escapeValue = additiveExpression(null, 0, inSelectClause) |
                <LEFT_BRACE> <ESCAPE> escapeValue = additiveExpression(null, 0, inSelectClause) <RIGHT_BRACE>
            ]
	{
		tree = (ValueNode) nodeFactory.getNode(
								C_NodeTypes.LIKE_OPERATOR_NODE,
								leftOperand,
								likePattern,
								escapeValue,
								getContextManager());
		
		return tree;
	}
|
// GemStone changes BEGIN
	tree = betweenPredicateValue(leftOperand, inSelectClause)
	{
		return tree;
	}
}

/*
 * <A NAME="betweenPredicateValue">betweenPredicateValue</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
ValueNode
betweenPredicateValue(ValueNode leftOperand, boolean inSelectClause) throws StandardException :
{
	ValueNode	tree = null;
	ValueNode	betweenLeft;
	ValueNode	betweenRight;
}
{

	<BETWEEN> betweenLeft = specificationForRange() <AND>
			  betweenRight = specificationForRange()
	{
		ValueNodeList betweenList = (ValueNodeList) nodeFactory.getNode(
													C_NodeTypes.VALUE_NODE_LIST,
													getContextManager());
		if (betweenLeft == null) {
			if (betweenRight == null) {
				// TODO what exception to throw ....
				throw StandardException.newException(SQLState.LANG_COLUMN_OUT_OF_RANGE,
												"Both values in range specification cannot be null");
			} else {
				int betweenRightNodeType = betweenRight.getNodeType();
				//betweenRight.toString();
				String typename = ((ConstantNode)betweenRight).getValue().getTypeName();
				
				Object nullOrDateTimeTimestampObj = getNullOrDateTypeObj(typename);
				betweenLeft = (ValueNode) nodeFactory.getNode(betweenRightNodeType, 
				                                  nullOrDateTimeTimestampObj,
				                                  getContextManager());
				if (betweenLeft instanceof UserTypeConstantNode) {
					((UserTypeConstantNode)betweenLeft).setInfinity(true);
				}
			}
		} else if (betweenRight == null) {
			    int betweenLeftNodeType = betweenLeft.getNodeType();
			    String typename = ((ConstantNode)betweenLeft).getValue().getTypeName();
			    Object nullOrDateTimeTimestampObj = getNullOrDateTypeObj(typename);
				betweenRight = (ValueNode) nodeFactory.getNode(betweenLeftNodeType, 
				                                  nullOrDateTimeTimestampObj,
				                                  getContextManager());
				if (betweenRight instanceof UserTypeConstantNode) {
					((UserTypeConstantNode)betweenRight).setInfinity(true);
				}
		}
 // GemStone changes END
		betweenList.addElement(betweenLeft);
		betweenList.addElement(betweenRight);
		tree = (ValueNode) nodeFactory.getNode(
								C_NodeTypes.BETWEEN_OPERATOR_NODE,
								leftOperand,
								betweenList,
								getContextManager());
		
		return tree;
	}
}

/*
 * <A NAME="compOp">compOp</A>
 */
int
compOp() throws StandardException :
{}
{
	<EQUALS_OPERATOR>
	{
		return BinaryOperatorNode.EQ;
	}
|
	<NOT_EQUALS_OPERATOR>
	{
		return BinaryOperatorNode.NE;
	}
|
	<NOT_EQUALS_OPERATOR2>
	{
		return BinaryOperatorNode.NE;
	}
|
	<LESS_THAN_OPERATOR>
	{
		return BinaryOperatorNode.LT;
	}
|
	<GREATER_THAN_OPERATOR>
	{
		return BinaryOperatorNode.GT;
	}
|
	<LESS_THAN_OR_EQUALS_OPERATOR>
	{
		return BinaryOperatorNode.LE;
	}
|
	<GREATER_THAN_OR_EQUALS_OPERATOR>
	{
		return BinaryOperatorNode.GE;
	}
}

/*
 * <A NAME="additiveExpression">additiveExpression</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
ValueNode
additiveExpression(ValueNode farLeftOperand, int compOp, boolean inSelectClause) throws StandardException :
{
	ValueNode	leftOperand;
	int			operator;
	int			nodeType;
}
{
	leftOperand = multiplicativeExpression(null, 0, inSelectClause)  			
			(operator = additiveOperator() 			 
				leftOperand = multiplicativeExpression(leftOperand, operator, inSelectClause) )*
	{
		if (farLeftOperand == null)
			return leftOperand;

		switch (compOp)
		{
		  case BinaryOperatorNode.EQ:
			nodeType = C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE;
			break;

		  case BinaryOperatorNode.NE:
			nodeType = C_NodeTypes.BINARY_NOT_EQUALS_OPERATOR_NODE;
			break;

		  case BinaryOperatorNode.LT:
		  	nodeType = C_NodeTypes.BINARY_LESS_THAN_OPERATOR_NODE;
			break;

		  case BinaryOperatorNode.GT:
			nodeType = C_NodeTypes.BINARY_GREATER_THAN_OPERATOR_NODE;
			break;

		  case BinaryOperatorNode.LE:
			nodeType = C_NodeTypes.BINARY_LESS_EQUALS_OPERATOR_NODE;
			break;

		  case BinaryOperatorNode.GE:
			nodeType = C_NodeTypes.BINARY_GREATER_EQUALS_OPERATOR_NODE;
			break;

		  default:
			if (SanityManager.DEBUG)
			SanityManager.THROWASSERT("Unknown comparison operator " + compOp);
			nodeType = 0;
			break;
		}

		return (ValueNode) nodeFactory.getNode(
							nodeType,
							farLeftOperand,
							leftOperand,
							getContextManager());
	}
}

/*
 * <A NAME="additiveOperator">additiveOperator</A>
 */
int
additiveOperator() throws StandardException :
{
	Token tok;
}
{	tok = <PLUS_SIGN> 
	{
		return BinaryOperatorNode.PLUS;
	}
|
	tok = <MINUS_SIGN>
	{
		return BinaryOperatorNode.MINUS;
	}
}

/*
 * <A NAME="multiplicativeExpression">multiplicativeExpression</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
ValueNode
multiplicativeExpression(ValueNode farLeftOperand, int additiveOperator, boolean inSelectClause) throws StandardException :
{
	ValueNode	leftOperand;
	int			multOp;
}
{
	leftOperand = unaryExpression(null, 0, inSelectClause) 
				(multOp = multiplicativeOperator() 
				 leftOperand = unaryExpression(leftOperand, multOp, inSelectClause) )*
	{
		if (farLeftOperand == null)
			return leftOperand;

		switch (additiveOperator)
		{
		  case BinaryOperatorNode.PLUS:
			return (ValueNode) nodeFactory.getNode(
									C_NodeTypes.BINARY_PLUS_OPERATOR_NODE,
									farLeftOperand,
									leftOperand,
									getContextManager()
									);

		  case BinaryOperatorNode.MINUS:
			return (ValueNode) nodeFactory.getNode(
									C_NodeTypes.BINARY_MINUS_OPERATOR_NODE,
									farLeftOperand,
									leftOperand,
									getContextManager()
									);

		  default:
			if (SanityManager.DEBUG)
			SanityManager.THROWASSERT(
					"Unexpected operator value of " + additiveOperator);
			return null;
		}
	}
}

/*
 * <A NAME="multiplicativeOperator">multiplicativeOperator</A>
 */
int
multiplicativeOperator() throws StandardException :
{ }
{	<ASTERISK> 
	{
		return BinaryOperatorNode.TIMES;
	}
|
	<SOLIDUS>
	{
		return BinaryOperatorNode.DIVIDE;
	}
|
	<CONCATENATION_OPERATOR>
	{
		return BinaryOperatorNode.CONCATENATE;
	}
}

/*
 * <A NAME="unaryExpression">unaryExpression</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
ValueNode
unaryExpression(ValueNode farLeftOperand, int multiplicativeOperator, boolean inSelectClause) throws StandardException :
{
	ValueNode	value;
	String		sign = null;
	int			tokKind1;
	int			tokKind2;
}
{
	[
		// This LOOKAHEAD is required because a + or - sign can come before
		// any expression, and also can be part of a literal. If it comes
		// before a number, we want it to be considered part of the literal,
		// because the literal() rule knows how to handle the minimum value
		// for an int without changing it to a long.
		LOOKAHEAD( {
					( (tokKind1 = getToken(1).kind) == PLUS_SIGN ||
					   tokKind1 == MINUS_SIGN )
					&&
					( (tokKind2 = getToken(2).kind) != EXACT_NUMERIC &&
					   tokKind2 != APPROXIMATE_NUMERIC)
				   } )
		sign = sign()
	]
	value = primaryExpression(inSelectClause)
	{
		if ("-".equals(sign))
		{
			value = (ValueNode) nodeFactory.getNode(
										C_NodeTypes.UNARY_MINUS_OPERATOR_NODE,
										value,
										getContextManager());
		}
		else if ("+".equals(sign))
		{
			value = (ValueNode) nodeFactory.getNode(
										C_NodeTypes.UNARY_PLUS_OPERATOR_NODE,
										value,
										getContextManager());
		}
		else if (SanityManager.DEBUG)
		{
			if (sign != null)
			{
				SanityManager.THROWASSERT("Unknown unary operator '"
											+ sign
											+ "'");
			}
		}

		return multOp(farLeftOperand, value, multiplicativeOperator);
	}
}


/*
 * <A NAME="sign">sign</A>
 */
String
sign() :
{
	Token	s;
}
{
	s = <PLUS_SIGN>
	{
		return s.image;
	}
|
	s = <MINUS_SIGN>
	{
		return s.image;
	}
}

/*
 * <A NAME="primaryExpressionXX">primaryExpressionXX</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
ValueNode
primaryExpressionXX( boolean inSelectClause ) throws StandardException :
{
	ValueNode	value;
}
{
	value = primary(inSelectClause)
	  ( value = nonStaticMethodCallOrFieldAccess(value)) *	
	{
		return value;
	}
}

ValueNode
nonStaticMethodCallOrFieldAccess(ValueNode receiver) throws StandardException :
{
	ValueNode value;
}
{
	value = nonStaticMethodInvocation(receiver)
	{
		return value;
	}
}

/*
 * <A NAME="nonStaticMethodInvocation">nonStaticMethodInvocation</A>
 */
ValueNode
nonStaticMethodInvocation(ValueNode receiver) throws StandardException :
{
	Vector					parameterList = new Vector();
	MethodCallNode			methodNode;
	ParameterNode			parameterNode;
}
{
        LOOKAHEAD
	( {
		getToken(3).kind == LEFT_PAREN
	  }
	)

	( <FIELD_REFERENCE> | <PERIOD> )
		methodNode = methodName(receiver) methodCallParameterList(parameterList)

	{

		/*
		** ? parameters are not allowed for the receiver --
		** unless the receiver is standing in for a named parameter,
		** whose type is therefore known.
		*/
		if (receiver instanceof ParameterNode)
		{
			throw StandardException.newException(SQLState.LANG_PARAMETER_RECEIVER,
												methodNode.getMethodName());
		}

		methodNode.addParms(parameterList);

		/*
		** Assume this is being returned to the SQL domain.  If it turns
		** out that this is being returned to the Java domain, we will
		** get rid of this node.
		*/
		return (ValueNode) nodeFactory.getNode(
								C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
								methodNode,
								getContextManager());
	}
|
        <PERIOD> methodNode = methodName(receiver)
	{
		/*
		** ? parameters are not allowed for the receiver --
		** unless the receiver is standing in for a named parameter,
		** whose type is therefore known.
		*/
		if (receiver instanceof ParameterNode)
		{
			throw StandardException.newException(SQLState.LANG_PARAMETER_RECEIVER,
												methodNode.getMethodName());
		}

		methodNode.addParms(parameterList);

		/*
		** Assume this is being returned to the SQL domain.  If it turns
		** out that this is being returned to the Java domain, we will
		** get rid of this node.
		*/
		return (ValueNode) nodeFactory.getNode(
								C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
								methodNode,
								getContextManager());
	}


}

/*
 * <A NAME="methodName">methodName</A>
 */
MethodCallNode
methodName(ValueNode receiver) throws StandardException :
{
	String	methodName;
}
{
	/*
	** NOTE: allowing a delimited identifier as a method name is necessary,
	** because Java is case-sensitive.  But this also allows identifiers that
	** do not match Java syntax.  This will probably not cause a problem
	** in later phases, like binding and code generation.
	*/
	methodName = caseSensitiveIdentifierPlusReservedWords()
	{
		return (MethodCallNode) nodeFactory.getNode(
										C_NodeTypes.NON_STATIC_METHOD_CALL_NODE,
										methodName,
										receiver,
										getContextManager());
	}
}

/*
 * <A NAME="staticMethodName">staticMethodName</A>
 */
MethodCallNode
staticMethodName(String javaClassName) throws StandardException :
{
	String	methodName;
}
{
	/*
	** NOTE: allowing a delimited identifier as a method name is necessary,
	** because Java is case-sensitive.  But this also allows identifiers that
	** do not match Java syntax.  This will probably not cause a problem
	** in later phases, like binding and code generation.
	*/
	methodName = caseSensitiveIdentifierPlusReservedWords()
	{
		return (MethodCallNode) nodeFactory.getNode(
								C_NodeTypes.STATIC_METHOD_CALL_NODE,
								methodName,
								javaClassName,
								getContextManager());
	}
}

/*
 * <A NAME="methodParameter">methodParameter</A>
 */
void
methodParameter(Vector parameterList) throws StandardException :
{
	ValueNode	parameter;
}
{
	parameter = additiveExpression(null,0, false)
	{
		parameterList.addElement(parameter);
	}
|
	parameter = nullSpecification()
	{
		parameterList.addElement(parameter);
	}
}


/*
 * <A NAME="primary">primary</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
ValueNode
primary(boolean inSelectClause) throws StandardException :
{
	String		javaClassName;
	ValueNode	value;
}
{
	
	//Look ahead required here to tell a java class from a identifier
	LOOKAHEAD( { javaClassFollows() } )
	value = staticClassReference()
	{
		return value;
	}
|
	value = valueExpressionPrimary(inSelectClause)
	{
		return value;
	}
}

/*
 * <A NAME="staticClassReference">staticClassReference</A>
 */
ValueNode
staticClassReference() throws StandardException :
{
	String		javaClassName;
	ValueNode value;
}
{
	javaClassName = javaClass() <DOUBLE_COLON>  value = staticClassReferenceType(javaClassName)
	{
		return value;
	}
}

/*
 * <A NAME="staticClassReferenceType">staticClassReferenceType</A>
 */
ValueNode
staticClassReferenceType(String javaClassName) throws StandardException :
{
	ValueNode value;
}
{
	//Look ahead required here to tell method from field reference
	LOOKAHEAD({(getToken(2).kind == LEFT_PAREN)})
	value = staticMethodInvocation(javaClassName) 
	{
		return value;
	}
|
	value = staticClassFieldReference(javaClassName) 
	{
		return value;
	}
}

/*
 * <A NAME="staticClassFieldReference">staticClassFieldReference</A>
 */
ValueNode
staticClassFieldReference(String javaClassName) throws StandardException :
{
	String		fieldName = null;
}
{
	fieldName = caseSensitiveIdentifierPlusReservedWords() 
	{
		return	(ValueNode) nodeFactory.getNode(
					C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
					nodeFactory.getNode(
								C_NodeTypes.STATIC_CLASS_FIELD_REFERENCE_NODE,
								javaClassName,
								fieldName,
								nextToLastTokenDelimitedIdentifier,
								getContextManager()),
					getContextManager());
	}
}

/*
 * <A NAME="nonSecondDatetimeField">nonSecondDatetimeField</A>
 */
int
nonSecondDatetimeField() :
{}
{
	<YEAR> 
	{
		return DateTimeDataValue.YEAR_FIELD;
	}
|
	<MONTH> 
	{
		return DateTimeDataValue.MONTH_FIELD;
	}
|
	<DAY> 
	{
		return DateTimeDataValue.DAY_FIELD;
	}
|
	<HOUR> 
	{
		return DateTimeDataValue.HOUR_FIELD;
	}
|
	<MINUTE>
	{
		return DateTimeDataValue.MINUTE_FIELD;
	}
}


ValueNode
escapedValueFunction() throws StandardException :
{
	ValueNode	value;
    ValueNode   str1;
    ValueNode   str2;
	ValueNode	startPosition;
    ValueNode	length = null;
}
{
	value = miscBuiltinsCore( true /* is JDBC escape */)
	{
		return value;
	}
|
	/* Escaped function substring() */
    <SUBSTRING> <LEFT_PAREN> value = additiveExpression(null, 0, false) <COMMA> startPosition = additiveExpression(null, 0, false) [ <COMMA> length = additiveExpression(null, 0, false) ] <RIGHT_PAREN>
	{
        return getSubstringNode(value, startPosition, length, Boolean.FALSE);
	}
|
	/* CURDATE() is an escaped function supported by JCC 2.2 or higher */
	<CURDATE> <LEFT_PAREN> <RIGHT_PAREN>
	{
		return (ValueNode) nodeFactory.getNode(
								C_NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
								ReuseFactory.getInteger(
									CurrentDatetimeOperatorNode.CURRENT_DATE),
								getContextManager());
	}
|
	/* CURTIME() is an escaped function supported by JCC 2.2 or higher */
	<CURTIME> <LEFT_PAREN> <RIGHT_PAREN>
	{
		return (ValueNode) nodeFactory.getNode(
							C_NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
							ReuseFactory.getInteger(
								CurrentDatetimeOperatorNode.CURRENT_TIME),
							getContextManager());
	}
|
    /* CONCAT( string1, string2 )
     * CONCAT is not a reserved word.
     */
    <CONCAT> <LEFT_PAREN> str1 = additiveExpression(null,0, false) <COMMA> 
            str2 = additiveExpression(null,0, false) <RIGHT_PAREN>
    {
        return (ValueNode) nodeFactory.getNode(
                            C_NodeTypes.CONCATENATION_OPERATOR_NODE,
                            str1,
                            str2,
                            getContextManager());
    }
|
	/* Method versions of USER special registers
	 * are ODBC remnants.  Only supported
	 * when escaped.
	 */
	value = userNode() <LEFT_PAREN> <RIGHT_PAREN>
	{
		return value;
	}
|
    value = timestampArithmeticFuncion()
    {
        return value;
    }
 
|   
    LOOKAHEAD({ getEscapedSYSFUN(getToken(1).image) != null }) 
    value = escapedSYSFUNFunction()
    {
        return value;
    }

    
}

/*
 * <A NAME="numericValueFunction">numericValueFunction</A>
 */
ValueNode
escapedSYSFUNFunction() throws StandardException :
{
    Vector      parameterList = new Vector();
	Token tok;
}
{
    tok = <IDENTIFIER> methodCallParameterList(parameterList)
    {
	    String sysFunName = getEscapedSYSFUN(tok.image);
	    
	    TableName functionName = (TableName) nodeFactory.getNode(
								C_NodeTypes.TABLE_NAME,
								SchemaDescriptor.IBM_SYSTEM_FUN_SCHEMA_NAME,
								sysFunName,
// GemStone changes BEGIN
								// changed to use Integer.valueOf()
								Integer.valueOf(0),
								Integer.valueOf(0),
// GemStone changes END
								getContextManager());
	   
		MethodCallNode methodNode = (MethodCallNode) nodeFactory.getNode(
								C_NodeTypes.STATIC_METHOD_CALL_NODE,
								functionName,
								null,
								getContextManager());

		methodNode.addParms(parameterList);

		/*
		** Assume this is being returned to the SQL domain.  If it turns
		** out that this is being returned to the Java domain, we will
		** get rid of this node.
		*/
		return (ValueNode) nodeFactory.getNode(
								C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
								methodNode,
								getContextManager());
     }
}


/*
 * <A NAME="timestampArithmeticFuncion">timestampArithmeticFuncion</A>
 */
ValueNode
timestampArithmeticFuncion() throws StandardException :
{
    ValueNode intervalType;
    ValueNode tstamp1;
    ValueNode tstamp2;
    ValueNode count;
}
{
    <TIMESTAMPADD> <LEFT_PAREN> intervalType = jdbcIntervalType() <COMMA>
       count = additiveExpression(null,0,false) <COMMA>
       tstamp1 = additiveExpression(null,0,false) <RIGHT_PAREN>
    {
        return (ValueNode) nodeFactory.getNode( C_NodeTypes.TIMESTAMP_ADD_FN_NODE,
                                                tstamp1,
                                                intervalType,
                                                count,
                                                ReuseFactory.getInteger( TernaryOperatorNode.TIMESTAMPADD),
                                                null,
                                                getContextManager());
    }
|
    <TIMESTAMPDIFF> <LEFT_PAREN> intervalType = jdbcIntervalType() <COMMA>
       tstamp1 = additiveExpression(null,0,false) <COMMA>
       tstamp2 = additiveExpression(null,0,false) <RIGHT_PAREN>
    {
        return (ValueNode) nodeFactory.getNode( C_NodeTypes.TIMESTAMP_DIFF_FN_NODE,
                                                tstamp2,
                                                intervalType,
                                                tstamp1,
                                                ReuseFactory.getInteger( TernaryOperatorNode.TIMESTAMPDIFF),
                                                null,
                                                getContextManager());
    }
}       

/*
 * <A NAME="jdbcIntervalType">jdbcIntervalType</A>
 */
ValueNode jdbcIntervalType() throws StandardException :
{
}
{
    <SQL_TSI_FRAC_SECOND>
    {
        return getJdbcIntervalNode( DateTimeDataValue.FRAC_SECOND_INTERVAL);
    }
|
    <SQL_TSI_SECOND>
    {
        return getJdbcIntervalNode( DateTimeDataValue.SECOND_INTERVAL);
    }
|
    <SQL_TSI_MINUTE>
    {
        return getJdbcIntervalNode( DateTimeDataValue.MINUTE_INTERVAL);
    }
|
    <SQL_TSI_HOUR>
    {
        return getJdbcIntervalNode( DateTimeDataValue.HOUR_INTERVAL);
    }
|
    <SQL_TSI_DAY>
    {
        return getJdbcIntervalNode( DateTimeDataValue.DAY_INTERVAL);
    }
|
    <SQL_TSI_WEEK>
    {
        return getJdbcIntervalNode( DateTimeDataValue.WEEK_INTERVAL);
    }
|
    <SQL_TSI_MONTH>
    {
        return getJdbcIntervalNode( DateTimeDataValue.MONTH_INTERVAL);
    }
|
    <SQL_TSI_QUARTER>
    {
        return getJdbcIntervalNode( DateTimeDataValue.QUARTER_INTERVAL);
    }
|
    <SQL_TSI_YEAR>
    {
        return getJdbcIntervalNode( DateTimeDataValue.YEAR_INTERVAL);
    }
}

/*
 * <A NAME="numericValueFunction">numericValueFunction</A>
 */
ValueNode
numericValueFunction() throws StandardException :
{
	ValueNode	value;
	int			field;
}
{
    /*
     * NOTE: If you add a new rule here, you must add the appropriate
     *    LOOKAHEAD rule to miscBuiltins().
     */

    <ABS>  value = absFunction()
    {
		return value;
    }
|
    <ABSVAL>  value = absFunction()
    {
		return value;
    }
|
    <SQRT> <LEFT_PAREN> value = additiveExpression(null,0,false) <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(
                C_NodeTypes.SQRT_OPERATOR_NODE,
                value,
                getContextManager());
    }
|
	/* MOD(int, int)
	*/
	<MOD> value = modFunction()
	{
		return value;
	}
|
	<IDENTITY_VAL_LOCAL> <LEFT_PAREN> <RIGHT_PAREN>
	{
		return (ValueNode) nodeFactory.getNode(
						C_NodeTypes.IDENTITY_VAL_NODE,
						getContextManager());
	}
}

/*
 * <A NAME="coalesceFunction">coalesceFunction</A>
 */
ValueNode
coalesceFunction(String coalesceOrValue) throws StandardException :
{
    ValueNodeList expressionList = (ValueNodeList) nodeFactory.getNode(
	C_NodeTypes.VALUE_NODE_LIST,
	getContextManager());
}
{
    <LEFT_PAREN>
        coalesceExpression(expressionList)
		( <COMMA> coalesceExpression(expressionList) )* 
    <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(
                C_NodeTypes.COALESCE_FUNCTION_NODE,
                coalesceOrValue,
                expressionList,
                getContextManager());
    }
}

/*
 * <A NAME="coalesceExpression">coalesceExpression</A>
 */
void
coalesceExpression(ValueNodeList expressionList) throws StandardException :
{
	ValueNode	expression;
}
{
	expression = additiveExpression(null,0,false)
	{
		expressionList.addElement(expression);
	}
}

/*
 * <A NAME="absFunction">absFunction</A>
 */
ValueNode
absFunction() throws StandardException :
{
    ValueNode value;
}
{
    <LEFT_PAREN> value = additiveExpression(null,0, false) <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(
                C_NodeTypes.ABSOLUTE_OPERATOR_NODE,
                value,
                getContextManager());
    }
}
/*
 * <A NAME="modFunction">modFunction</A>
 */
ValueNode
modFunction() throws StandardException :
{
    ValueNode int1;
	ValueNode int2;
}
{
    <LEFT_PAREN> int1 = additiveExpression(null,0,false) <COMMA> 
            int2 = additiveExpression(null,0,false) <RIGHT_PAREN>
    {
        return (ValueNode)nodeFactory.getNode(
                C_NodeTypes.MOD_OPERATOR_NODE,
                int1, int2,
                getContextManager());
    }
}

/*
 * <A NAME="datetimeField">datetimeField</A>
 */
int
datetimeField() :
{
	int field;
}
{
	field = nonSecondDatetimeField() 
	{
		return field;
	}
|
	<SECOND>
	{
		return DateTimeDataValue.SECOND_FIELD;
	}
}


ValueNode
characterValueFunction() throws StandardException :
{
	ValueNode 	value = null;
	ValueNode 	str1;
	ValueNode 	str2;
	Token		upperTok = null;
	Token		lowerTok = null;
	ValueNode	startPosition;
    ValueNode	length = null;
}
{
	<SUBSTR> <LEFT_PAREN> value = additiveExpression(null,0,false) <COMMA> startPosition = additiveExpression(null,0,false) [ <COMMA> length = additiveExpression(null,0,false) ] <RIGHT_PAREN>
	{
        return getSubstringNode( value, startPosition, length, Boolean.FALSE );
	}
|
	( upperTok = <UPPER> | lowerTok = <LOWER> ) <LEFT_PAREN> value = additiveExpression(null,0,false) <RIGHT_PAREN>
	{
		return (ValueNode) nodeFactory.getNode(
					C_NodeTypes.SIMPLE_STRING_OPERATOR_NODE,
					value,
					(upperTok != null) ? "upper" : "lower",
					getContextManager());
	}
|
	( upperTok = <UCASE> | lowerTok = <LCASE> ) <LEFT_PAREN> value = additiveExpression(null,0,false) <RIGHT_PAREN>
	{
		return (ValueNode) nodeFactory.getNode(
					C_NodeTypes.SIMPLE_STRING_OPERATOR_NODE,
					value,
					(upperTok != null) ? "upper" : "lower",
					getContextManager());
	}
|
	value = trimFunction()
	{
		return value;
	}
|
    /* LOCATE( string1, string2[, start] )
     * LOCATE is a SQLJ reserved word.
     */
    <LOCATE> <LEFT_PAREN> str1 = additiveExpression(null,0,false) <COMMA>
            str2 = additiveExpression(null,0,false)
            [ <COMMA> value = additiveExpression(null,0,false) ]
            <RIGHT_PAREN>
    {
		// if start is missing, start is equal to 1
        return (ValueNode) nodeFactory.getNode(
                            C_NodeTypes.LOCATE_FUNCTION_NODE,
                            str1,
                            str2,
                            (value == null) ? getNodeFactory().getNode(
                                        C_NodeTypes.INT_CONSTANT_NODE, 
                                        ReuseFactory.getInteger(1), 
                                        getContextManager() )
											: value,
                            ReuseFactory.getInteger(TernaryOperatorNode.LOCATE),
                            null,
                            getContextManager());
    }
}


ValueNode
trimFunction() throws StandardException :
{
	ValueNode	source;
	Integer		trimType;
	ValueNode	ansiTrimNode;
}
{
	trimType = trimType() <LEFT_PAREN> source = additiveExpression(null,0,false) <RIGHT_PAREN>
	{
		return getTrimOperatorNode(trimType, null, source, null);
	}
|
	<TRIM> ansiTrimNode = ansiTrim()
	{
		return ansiTrimNode;
	}

}


ValueNode
ansiTrim() throws StandardException  :
{
    Integer trimSpec = ReuseFactory.getInteger(StringDataValue.BOTH);
    ValueNode trimChar = null;
    ValueNode trimSource = null;
}
{
    LOOKAHEAD ({ansiTrimSpecFollows()})
    <LEFT_PAREN> trimSpec = ansiTrimSpec()
    (
         // LEADING FROM <source>
         LOOKAHEAD(<FROM>)
         <FROM> trimSource = additiveExpression(null,0,false) <RIGHT_PAREN>
         {
             return getTrimOperatorNode(trimSpec, trimChar, trimSource, null);
         }
     |
         // LEADING <char> FROM <source>
         trimChar = additiveExpression(null,0,false) <FROM> trimSource = additiveExpression(null,0,false) <RIGHT_PAREN>
         {
             return getTrimOperatorNode(trimSpec, trimChar, trimSource, null);
         }
    )
|
    LOOKAHEAD ({!ansiTrimSpecFollows()})
    <LEFT_PAREN> trimChar = additiveExpression(null,0,false)
    (
        <FROM> trimSource = additiveExpression(null,0,false) <RIGHT_PAREN>
        {
            return getTrimOperatorNode(trimSpec, trimChar, trimSource, null);
        }
    |
        <RIGHT_PAREN>
        {
            // expr was trim(e)-- we assigned e to trimChar but it is really the trimSource
            return getTrimOperatorNode(trimSpec, null, trimChar, null);
        }
    )
}

Integer
ansiTrimSpec() :
{
}
{
	<TRAILING>
	{
		return ReuseFactory.getInteger(StringDataValue.TRAILING);
	}
|
	<LEADING>
	{
		return ReuseFactory.getInteger(StringDataValue.LEADING);
	}
|
	<BOTH>
	{
		return ReuseFactory.getInteger(StringDataValue.BOTH);
	}
}


Integer
trimType() :
{
}
{
	<RTRIM>
	{
		return ReuseFactory.getInteger(StringDataValue.TRAILING);
	}
|
	<LTRIM>
	{
		return ReuseFactory.getInteger(StringDataValue.LEADING);
	}
}

/*
 * <A NAME="valueExpressionPrimary">valueExpressionPrimary</A>
 * 
 * @param inSelectClause will be true if this method got called while parsing the select or values clause
 * If in select or values clause, we do not want to allow boolean values.
 */
ValueNode
valueExpressionPrimary(boolean inSelectClause) throws StandardException :
{
	ValueNode	value;
	int			tokKind;
}
{
	/* This LOOKAHEAD is required to distinguish 
	 * a escapedValueFunction() from other escaped 
	 * clauses. The former always has an FN as its 
	 * second token.
	 */
	LOOKAHEAD( { escapedValueFunctionFollows() } )
	<LEFT_BRACE> <FN> value = escapedValueFunction() <RIGHT_BRACE>
	{
		return value;
	}
|
	LOOKAHEAD({getToken(2).kind == SCHEMA || getToken(2).kind == SQLID}) 
	<CURRENT> (<SCHEMA> | <SQLID>)
	{
		return (ValueNode) nodeFactory.getNode(
						C_NodeTypes.CURRENT_SCHEMA_NODE,
						getContextManager());
	}
|
	LOOKAHEAD({getToken(2).kind == ISOLATION}) 
	<CURRENT> <ISOLATION>
	{
		return (ValueNode) nodeFactory.getNode(
						C_NodeTypes.CURRENT_ISOLATION_NODE,
						getContextManager());
	}
|
	/* Omitted "case_expression" */
	value = valueSpecification()
	{
		return value;
	}
|
	// This LOOKAHEAD is required to distinguish a newInvocation() from
	// an aggregateNode() and a columnReference(). It is necessary because
	// NEW is not a reserved word.
	LOOKAHEAD( { newInvocationFollows(1) } )
	value = newInvocation()
	{
		return value;
	}
|
	// This LOOKAHEAD is required to distinguish an aggregateNode from
	// miscBuiltins(). Both can start with an identifier.
	LOOKAHEAD( { aggregateFollows() } )
	value = aggregateNode()
	{
		return value;
	}
|
	// This LOOKAHEAD is required because both miscBuiltins() and
	// columnReference can start with an identifier()
	LOOKAHEAD( { miscBuiltinFollows() } )
	value = miscBuiltins()
	{
		return value;
	}
|
	value = columnReference()
	{
		return value;
	}
|
	<LEFT_PAREN>
	(
		// This LOOKAHEAD is required because a subquery can have
		// queryExpressions nested arbitrarily deep inside of parentheses,
		// so both subquery() and valueExpression() can start with
		// LEFT_PAREN. We disambiguate this case by only considering it
		// to be a subquery if it starts with SELECT or VALUES, which
		// are the first tokens to come after the LEFT_PAREN in a subquery.
		LOOKAHEAD( {getToken(1).kind == SELECT || getToken(1).kind == VALUES} )
		value = subquery(SubqueryNode.EXPRESSION_SUBQUERY, null)
		|
		/*
		** NOTE: The optional intervalQualfier() here makes sense only for
		** the MINUS operator.  We will have to add a semantic check that the
		** valueExpression() here is a MINUS operator if the intervalQualifier
		** is supplied.
		*/
		// without the following check, select/values (c1>c2) will not be caught
		LOOKAHEAD({inSelectClause})
		value = additiveExpression(null,0, inSelectClause)
		| //following will happen if we are not coming here for select/values clause
		value = valueExpression(inSelectClause)
	)
	<RIGHT_PAREN>
	{
		return value;
	}
|
	value = castSpecification()
	{
		return value;
	}
}

/*
 * <A NAME="miscBuiltins">miscBuiltins</A>
 */
ValueNode
miscBuiltins() throws StandardException :
{
	ValueNode value;
}
{
    /*
     * If you add rule to miscBuiltinsCore(), you must add the appropriate 
     *     LOOKAHEAD rule here.
     * SQRT and LOCATE are non-reserved keywords, so we need to disambiguate
     *     the grammar: "SQRT(" and "LOCATE(" introduce the SQRT and LOCATE
     *     built-in functions, not a static method invocation alias.
     */
    LOOKAHEAD( {
// GemStone changes BEGIN
             ( ((lookAhead = getToken(1)).kind == GET_CURRENT_CONNECTION ||
                lookAhead.kind == ABS ||
                lookAhead.kind == ABSVAL ||
                lookAhead.kind == SQRT ||
                lookAhead.kind == MOD ||
                lookAhead.kind == COALESCE ||
                lookAhead.kind == VALUE ||
                lookAhead.kind == NVL ||
                lookAhead.kind == DECODE ||
                lookAhead.kind == IDENTITY_VAL_LOCAL ||
                lookAhead.kind == SUBSTRING ||
                lookAhead.kind == SUBSTR ||
                lookAhead.kind == UPPER ||
                lookAhead.kind == LOWER ||
                lookAhead.kind == UCASE ||
                lookAhead.kind == LCASE ||
                lookAhead.kind == LTRIM ||
                lookAhead.kind == RTRIM ||
                lookAhead.kind == TRIM ||
                lookAhead.kind == DATE ||
                lookAhead.kind == TIME ||
                lookAhead.kind == TIMESTAMP ||
		        lookAhead.kind == DOUBLE ||
		        lookAhead.kind == CHAR ||
		        lookAhead.kind == VARCHAR ||
		        lookAhead.kind == INTEGER ||
		        lookAhead.kind == INT || 
		        lookAhead.kind == SMALLINT ||
		        lookAhead.kind == BYTE ||
		        lookAhead.kind == SHORT ||
		        lookAhead.kind == LONGINT ||
		        lookAhead.kind == TINYINT ||
                lookAhead.kind == YEAR ||
                lookAhead.kind == MONTH ||
                lookAhead.kind == DAY ||
                lookAhead.kind == HOUR ||
                lookAhead.kind == MINUTE ||
                lookAhead.kind == SECOND ||
                lookAhead.kind == LENGTH ||
                lookAhead.kind == LOCATE ||
                lookAhead.kind == XMLPARSE ||
                lookAhead.kind == XMLSERIALIZE ||
                lookAhead.kind == XMLEXISTS ||
                lookAhead.kind == XMLQUERY) &&
                /* (original code)
             ( (getToken(1).kind == GET_CURRENT_CONNECTION ||
                getToken(1).kind == ABS ||
                getToken(1).kind == ABSVAL ||
                getToken(1).kind == SQRT ||
                getToken(1).kind == MOD ||
                getToken(1).kind == COALESCE ||
                getToken(1).kind == VALUE ||
                getToken(1).kind == IDENTITY_VAL_LOCAL ||
                getToken(1).kind == SUBSTRING ||
                getToken(1).kind == SUBSTR ||
                getToken(1).kind == UPPER ||
                getToken(1).kind == LOWER ||
                getToken(1).kind == UCASE ||
                getToken(1).kind == LCASE ||
                getToken(1).kind == LTRIM ||
                getToken(1).kind == RTRIM ||
                getToken(1).kind == TRIM ||
                getToken(1).kind == DATE ||
                getToken(1).kind == TIME ||
                getToken(1).kind == TIMESTAMP ||
		getToken(1).kind == DOUBLE ||
		getToken(1).kind == CHAR ||
		getToken(1).kind == VARCHAR ||
		getToken(1).kind == INTEGER ||
		getToken(1).kind == INT || 
		getToken(1).kind == SMALLINT ||
		getToken(1).kind == LONGINT ||
		getToken(1).kind == SHORT ||
		getToken(1).kind == TINYINT ||
		getToken(1).kind == BYTE ||
                getToken(1).kind == YEAR ||
                getToken(1).kind == MONTH ||
                getToken(1).kind == DAY ||
                getToken(1).kind == HOUR ||
                getToken(1).kind == MINUTE ||
                getToken(1).kind == SECOND ||
                getToken(1).kind == LENGTH ||
                getToken(1).kind == LOCATE ||
                getToken(1).kind == XMLPARSE ||
                getToken(1).kind == XMLSERIALIZE ||
                getToken(1).kind == XMLEXISTS ||
                getToken(1).kind == XMLQUERY ) &&
                */
// GemStone changes END
              getToken(2).kind == LEFT_PAREN
              )
    } )
	/* miscBuiltins() are composed of the core
	 * system, string and numeric functions,
	 * date functions
	 * and static method calls.
	 */
	value = miscBuiltinsCore( false /* not JDBC escape */)
	{
		return value;
	}
|
	value = datetimeValueFunction()
	{
		return value;
	}
|	
	/* This is where we build a node for static method aliases */
	value = routineInvocation()
	{
		return value;
	}
}

ValueNode
miscBuiltinsCore( boolean isJDBCEscape) throws StandardException :
{
	ValueNode value;
}
{
	/* miscBuiltinsCore() are the core
	 * system, string and numeric functions.
	 * NOTE: date functions not currently considered
	 * core for purposes of the grammar since
	 * they can only be escaped when they appear
	 * as functions (not special registers).
     *
     * NOTE: If you add a new rule here, you must add the appropriate
     *    LOOKAHEAD rule to miscBuiltins().
	 */

	<GET_CURRENT_CONNECTION> <LEFT_PAREN> <RIGHT_PAREN>
	{
		checkInternalFeature("GETCURRENTCONNECTION()");
		return (ValueNode) nodeFactory.getNode(
								C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
								nodeFactory.getNode(
									C_NodeTypes.GET_CURRENT_CONNECTION_NODE,
									getContextManager()),
								getContextManager());
	}
|
	value = numericValueFunction() 
	{
		return value;
	}
|
	value = characterValueFunction()
	{
		return value;
	}
|
	value = dataTypeScalarFunction()
	{
		return value;
	}
|
	<COALESCE>  value = coalesceFunction("COALESCE")
	{
		return value;
	}
|
	<VALUE>  value = coalesceFunction("VALUE")
	{
		return value;
	}
// GemStone changes BEGIN
|
	<NVL> value = nvlFunction("NVL")
	{
		return value;
	}
|
	<DECODE> value = decodeFunction()
	{
		return value;
	}
// GemStone changes END
|
	<LENGTH> <LEFT_PAREN> value = additiveExpression(null,0, false) <RIGHT_PAREN>
	{
		ContextManager	localCM = getContextManager();
                if( isJDBCEscape)
                        return (ValueNode) nodeFactory.getNode(
								C_NodeTypes.CHAR_LENGTH_OPERATOR_NODE,
								getTrimOperatorNode(
									ReuseFactory.getInteger(StringDataValue.TRAILING),
									null,
									value,
									localCM),
								localCM);
		return (ValueNode) nodeFactory.getNode(
							C_NodeTypes.DB2_LENGTH_OPERATOR_NODE,
                                                        value,
                                                        localCM);
	}
|
	value = xmlFunction()
	{
		return value;
	}
}


/*
 * <A NAME="dataTypeScalarFunction">dataTypeScalarFunction</A>
 */
ValueNode
	dataTypeScalarFunction() throws StandardException :
{
	DataTypeDescriptor dts;
	ValueNode value;           //converted result
	ValueNode operand;
	int charType;
	int length = -1;
}
{
	//Note: When you add a new data type function, in addition to adding it 
	// here, you need to add it to miscBuiltins()
	value = dateTimeScalarFunction()
	{
		return value;
	}
	|
	 dts = numericFunctionType() <LEFT_PAREN> operand = additiveExpression(null,0, false) <RIGHT_PAREN>
	  {
			value = (ValueNode) nodeFactory.getNode(
									C_NodeTypes.CAST_NODE,
									operand,
									dts,
									getContextManager());
			((CastNode) value).setForDataTypeFunction(true);
			((CastNode) value).setForExternallyGeneratedCASTnode();

			return value;
	  }
	 | charType = charOrVarchar() <LEFT_PAREN> operand = additiveExpression(null,0, false) [ <COMMA> length = length() ] <RIGHT_PAREN>
	{
		// Always check db2 limits for this function. It's new
		checkTypeLimits(charType,length);
		value = (ValueNode) nodeFactory.getNode(
												C_NodeTypes.CAST_NODE,
												operand,
// GemStone changes BEGIN
												// changed to use Integer.valueOf()
												Integer.valueOf(charType),
												Integer.valueOf(length),
// GemStone changes END
												getContextManager());

		((CastNode) value).setForDataTypeFunction(true);
		((CastNode) value).setForExternallyGeneratedCASTnode();
		return value;
	}
}
	 
/*
 * <A NAME="xmlFunction">xmlFunction</A>
 *
 * This method parses the built-in functions used with
 * the XML datatype.
 *
 */
ValueNode
	xmlFunction() throws StandardException :
{
	ValueNode value;
	checkVersion(DataDictionary.DD_VERSION_DERBY_10_1, "XML");

	// We only allow XML operations if the classpath has all
	// of the required external classes (namley, JAXP and Xalan).
	com.pivotal.gemfirexd.internal.iapi.types.XML.checkXMLRequirements();
}
{
	<XMLPARSE> <LEFT_PAREN>
		xmlDocOrContent() value = xmlParseValue() <RIGHT_PAREN>
	{
		return value;
	}
|
	<XMLSERIALIZE> <LEFT_PAREN> value = xmlSerializeValue() <RIGHT_PAREN>
	{
		return value;
	}
|
	<XMLEXISTS> <LEFT_PAREN> value = xmlQueryValue(true) <RIGHT_PAREN>
	{
		return value;
	}
|
	<XMLQUERY> <LEFT_PAREN> value = xmlQueryValue(false) <RIGHT_PAREN>
	{
		return value;
	}
}

/*
 * <A NAME="xmlParseValue">xmlParseValue</A>
 *
 * Syntax is as follows:
 *
 *     XMLPARSE( DOCUMENT <string-value-expression> PRESERVE WHITESPACE )
 *
 * The result of this operation will be an XML value, which can either
 * be used transiently or else can be stored persistently in a table that
 * has an XML column.  For example:
 *
 * ij> CREATE TABLE x_table (id INT, xdoc XML);
 * 0 rows inserted/updated/deleted
 * ij> INSERT INTO x_table VALUES (1, XMLPARSE(DOCUMENT '<simp> doc </simp>'
 * PRESERVE WHITESPACE));
 * 1 row inserted/updated/deleted
 *
 * We only allow XML documents (as opposed to XML content) to be
 * parsed into XML values.  Note that we require the "PRESERVE WHITESPACE"
 * keyword to be explicit; this is because the SQL/XML (2003) spec says that
 * if no whitespace option is given, the default is "STRIP WHITESPACE", which
 * we don't support (yet).
 *
 * By the time we get to this method, the "DOCUMENT" keyword has already
 * been parsed.
 *
 */
ValueNode
	xmlParseValue() throws StandardException :
{
	ValueNode value;
	boolean wsOption;
}
{
	value = additiveExpression(null,0,false) wsOption = xmlPreserveWhitespace() {
		return (ValueNode) nodeFactory.getNode(
					C_NodeTypes.XML_PARSE_OPERATOR_NODE,
					value,
					ReuseFactory.getInteger(UnaryOperatorNode.XMLPARSE_OP),
					new Object[] {(wsOption ? Boolean.TRUE : Boolean.FALSE)},
					getContextManager());
	}
}

/*
 * <A NAME="xmlPreserveWhitespace">xmlPreserveWhitespace</A>
 *
 * For now, we only support the PRESERVE WHITESPACE option.
 *
 */
boolean
	xmlPreserveWhitespace() throws StandardException :
{
}
{
	LOOKAHEAD({ (getToken(1).kind != STRIP) &&
		(getToken(1).kind != PRESERVE) })
	{
		throw StandardException.newException(
			SQLState.LANG_XML_KEYWORD_MISSING, "PRESERVE WHITESPACE",
			ReuseFactory.getInteger(getToken(1).beginLine),
			ReuseFactory.getInteger(getToken(1).beginColumn));
	}
|
	<STRIP> <WHITESPACE>
	{ // don't preserve whitespace.
		throw StandardException.newException(
			SQLState.LANG_UNSUPPORTED_XML_FEATURE, "STRIP WHITESPACE");
	}
|
	<PRESERVE> <WHITESPACE>
	{ // must preserve whitespace.
		return true;
	}
}

/*
 * <A NAME="xmlSerializeValue">xmlSerializeValue</A>
 *
 * Syntax is as follows:
 *
 *   XMLSERIALIZE( <xml-value-expression> AS <string-data-type> )
 *
 * The result of this operation will be a string value with the type specified
 * by the user.  For example:
 *
 * ij> SELECT id, XMLSERIALIZE(xdoc AS varchar(30)) FROM x_table;
 * ID         |2
 * ------------------------------------------
 * 1          |<simp> doc </simp>
 *
 */
ValueNode
	xmlSerializeValue() throws StandardException :
{
	ValueNode value;
	DataTypeDescriptor targetType;
}
{
// GemStone changes BEGIN
	// inserting switchOptimizeLiteral in between (#42889)
	{ boolean existing = getCompilerContext().switchOptimizeLiteral(false); }
// GemStone changes END
	value = additiveExpression(null,0,false)
		targetType = xmlSerializeTargetType()
	{
// GemStone changes BEGIN
		getCompilerContext().switchOptimizeLiteral(existing);
// GemStone changes END
		return (ValueNode) nodeFactory.getNode(
					C_NodeTypes.XML_SERIALIZE_OPERATOR_NODE,
					value,
					ReuseFactory.getInteger(UnaryOperatorNode.XMLSERIALIZE_OP),
					new Object[] {targetType},
					getContextManager());
	}
}

/*
 * <A NAME="xmlSerializeTargetType">xmlSerializeTargetType</A>
 *
 * Parse the target type of an XMLSERIALIZE operation.
 *
 */
DataTypeDescriptor xmlSerializeTargetType() throws StandardException :
{
	DataTypeDescriptor targetType;
}
{
	LOOKAHEAD({ (getToken(1).kind != AS) })
	{
		throw StandardException.newException(
			SQLState.LANG_XML_KEYWORD_MISSING, "AS",
			ReuseFactory.getInteger(getToken(1).beginLine),
			ReuseFactory.getInteger(getToken(1).beginColumn));
	}
|
	<AS> targetType = dataTypeDDL()
	{
		return targetType;
	}
}

/*
 * <A NAME="xmlQueryValue">xmlQueryValue</A>
 *
 * This method is used for parsing the XMLEXISTS and XMLQUERY operators
 * (which operator depends on the received boolean parameter).
 *
 * For XMLEXISTS, the syntax is as follows:
 *
 *   XMLEXISTS( <xpath-expression> PASSING BY REF <xml-value-expression> )
 *
 * The result of this operation will be a boolean true/false/unknown value:
 *   -- Unknown if either <xquery-expression> or <xml-value-expression> is null;
 *   -- True if evaluation of the given query expression against the
 *      given xml-value returns at least one node.
 *   -- False otherwise.
 *
 * For example:
 *
 * ij> SELECT id FROM x_table WHERE XMLEXISTS('/simple' PASSING BY REF xdoc);
 * ID
 * -----------
 * 1
 *
 * ====
 *
 * For XMLQUERY, the syntax is as follows:
 *
 *   XMLQUERY( <xquery-expression>
 *      PASSING BY REF <xml-value-expression>
 *      [ RETURNING SEQUENCE [ BY REF ] ]
 *      EMPTY ON EMPTY
 *   )
 *
 * The result of this operation will be an XMLDataValue.
 *
 * For example:
 *
 * ij> SELECT XMLSERIALIZE(
 *       XMLQUERY('/simple' PASSING BY REF xdoc EMPTY ON EMPTY) AS CHAR(100));
 * ID
 * -----------
 * <simp> doc </simp>
 *
 */
ValueNode
	xmlQueryValue(boolean existsOnly) throws StandardException :
{
	// The query expression (currently must be an expression
	// supported by Xalan--i.e. XPath only).
	ValueNode xqueryExpr = null;

	// Context item for the query; not required by SQL/XML spec,
	// but required by Derby for now.
	ValueNode xmlValue = null;

	// User-specified default passing mechanism.  Since Derby only
	// supports one type of passing mechanism--BY REF--this value
	// isn't currently used.
	short defaultPassingMech = -1;
}
{
// GemStone changes BEGIN
	// inserting switchOptimizeLiteral in between (#42889)
	{ boolean existing = getCompilerContext().switchOptimizeLiteral(false); }
// GemStone changes END
	xqueryExpr = additiveExpression(null, 0, false)
// GemStone changes BEGIN
	{ getCompilerContext().switchOptimizeLiteral(existing); }
// GemStone changes END
	<PASSING> defaultPassingMech = xmlPassingMechanism()
		xmlValue = xqVarList()
	(
		LOOKAHEAD( { !existsOnly } )
		[ xqReturningClause() [ xmlPassingMechanism() ] ]
			xqEmptyHandlingClause()
		{ /* Right now, we only support one kind of returning clause
		   * (RETURNING SEQUENCE) and one kind of handling clause
		   * (EMPTY ON EMPTY), so there's nothing more to do here--
		   * we just needed to check the syntax.  In the future
		   * we may need to add more logic here to support the
		   * other options.  Note: if no returning clause is
		   * specified, RETURNING SEQUENCE is implied (because
		   * that's all we support).
		   */
		}
	|
		LOOKAHEAD( { existsOnly } )
		{ /* For XMLEXISTS there's nothing more to parse.  We need
		   * this LOOKAHEAD in order to tell the parser that we're
		   * done parsing and thus it shouldn't look for (nor allow)
		   * any more tokens (neither xqReturningClause() nor
		   * xqEmptyHandlingClause() is allowed for the XMLEXISTS
		   * operator).
		   */
		}
	)
	{
		ValueNode vNode = (ValueNode) nodeFactory.getNode(
			(existsOnly
				? C_NodeTypes.XML_EXISTS_OPERATOR_NODE
				: C_NodeTypes.XML_QUERY_OPERATOR_NODE),
			xqueryExpr,
			xmlValue,
			(existsOnly
				? ReuseFactory.getInteger(BinaryOperatorNode.XMLEXISTS_OP)
				: ReuseFactory.getInteger(BinaryOperatorNode.XMLQUERY_OP)),
			getContextManager());

		return vNode;
	}
}

/**
 * <A NAME="xqVarList">xqVarList</A>
 *
 * Parse a list of XML query variables, which can include at most one
 * XML value to be used as the "context item" for the query.  If
 * such a context item was found, return that item; for all other
 * variable declarations we currently throw a "not supported" error
 * because Xalan doesn't allowing binding of variables.
 */

ValueNode xqVarList()
	throws StandardException :
{
	// Placeholder for the XML context item as we parse the
	// argument list.
	ValueNode [] xmlValue = new ValueNode [] { (ValueNode)null };
}
{
	xqVariable(xmlValue)
		( <COMMA> xqVariable(xmlValue) )*
	{
		return xmlValue[0];
	}
}

/**
 * <A NAME="xqVariable">xqVariable</A>
 *
 * Parse an XML query variable.  If the argument is an XML value
 * to be used as the "context item" for a query, then store the
 * value in the first slot of the received ValueNode array;
 * otherwise, throw a "not supported" errror (for now).
 */

void xqVariable(ValueNode [] xmlVal) throws StandardException :
{
	ValueNode curVal;
	String varName = null;
	short passingMech = -1;
}
{
	curVal = additiveExpression(null,0, false)
	[
		LOOKAHEAD( { getToken(1).kind == AS } )
		<AS> varName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
		{
			/* From XQuery 1.0: "The <identifier> I contained in XQV
			 * shall be an XML 1.1 NCName."  From XML 1.1:
			 *
			 *   [4] NCName ::= (Letter | '_') (NCNameChar)*
			 *   [5] NCNameChar ::= Letter | Digit | '.' | '-' | '_' |
			 *                    CombiningChar | Extender
			 *
			 * Since Derby's definition of an "identifier" is a subset
			 * of NCName, we just use Derby's definition.  This means
			 * that some valid NCNames won't be recognized by Derby--
			 * but since the ones we _do_ recognize are all still valid
			 * NCNames, we're not breaking any rules.
			 */

			/* All of that said, since we use Xalan as the underlying
			 * query engine and Xalan doesn't support variable binding,
			 * there's no point in letting the user specify variables
			 * right now.  So we disallow it.  In the future we'll have
			 * to add logic here to store the variables and pass them
			 * to the correct operator for binding/execution.
			 */
			throw StandardException.newException(
				SQLState.LANG_UNSUPPORTED_XML_FEATURE, "PASSING ... AS");
		}
	] 
	(
		[ passingMech = xmlPassingMechanism() ]
		{
			if (varName == null)
			{
				/* We get here if we just parsed an XML context item.
				 * That said, if we already have one (xmlVal[0] is not
				 * null) then we can't allow second one, per SQL/XML[2006]
				 * (6.17: Syntax Rules:5.b.i): "XMQ shall contain exactly
				 * one <XML query context item> XQCI."
				 */
				if (xmlVal[0] != null)
				{
					throw StandardException.newException(
						SQLState.LANG_MULTIPLE_XML_CONTEXT_ITEMS);
				}

				xmlVal[0] = curVal;

				/* Note: It's possible that a passing mechanism was
				 * specified for the context item; if so its value is
				 * stored in passingMech.  However, we don't actually
			 	 * store that passing mechanism anywhere because we
				 * (currently) only support BY REF, so we know what
			 	 * it has to be.  If we add support for other passing
			 	 * mechanisms (namely, BY VALUE) in the future, we'll
			 	 * have to store the passing mechanism provided by
			 	 * the user and process it at compilation/execution
				 * time.
				 */
			}
		}
	)
	{ // By this time we've parsed everything we need so there's nothing
	  // more to do.  The reason we're left with this empty block is
	  // is that most of the syntax is optional.  We end up here if
	  // none of the optional syntax was given, in which case all we
	  // need to do is store curVal--and we already did that.
	}
}

/*
 * <A NAME="xmlPassingMechanism">xmlPassingMechanism</A>
 *
 * For now, we only support the BY REF option because
 * that gives us better performance (allows us to avoid
 * performing potentially deep copies of XML nodes).  This
 * means that if the same XML value is passed BY REF into
 * two different XML arguments for a single operator, then
 * every node in the first XML argument must have an
 * identical node in the second XML argument, and the
 * ids for both nodes must be the same.  That said,
 * since we don't support variable binding yet, this
 * becomes a non-issue because we can't pass XML values.
 * In the future, though, we may choose to support the
 * passing/binding of variables (the only reason we
 * don't now is because Xalan doesn't support it) and
 * if we do, BY REF should provide better performance
 * due to lack of deep copying.
 */
short
	xmlPassingMechanism() throws StandardException :
{
}
{
	LOOKAHEAD( { getToken(2).kind == REF })
	<BY> <REF>
	{ // pass the XML value by reference
		return com.pivotal.gemfirexd.internal.iapi.types.XML.XQ_PASS_BY_REF;
	}
|
	<BY> <VALUE>
	{ // pass a 'copy' of the XML value.
		throw StandardException.newException(
			SQLState.LANG_UNSUPPORTED_XML_FEATURE, "BY VALUE");
	}
}

/*
 * <A NAME="xqReturningClause">xqReturningClause</A>
 *
 * For now we only support "RETURNING SEQUENCE".  The reason
 * is that this applies to the XMLQUERY operator and the
 * results of evaluating a query expression in Xalan against
 * an XML value can be an arbritary sequence of items--including
 * atomic values.  For simplicity we just return the values
 * as they are, without doing any further work.  SQL/XML[2006]
 * says that if we supported RETURNING CONTENT then we'd have
 * to construct an XQuery document from the results--but we don't
 * do that extra work for now, so we just say that we return
 * SEQUENCE.
 *
 * NOTE: This means that we may not be able to store the results
 * of an XMLQUERY operation into a Derby XML column.  Right now
 * an XML column can only hold valid DOCUMENT nodes, which we
 * we define as an XML value whose serialized form can be parsed
 * by a JAXP DocumentBuilder (because that's what Derby's XMLPARSE
 * operator uses and the result is always a Document node).
 * Internally this means that we can only store a sequence if it
 * contains exactly one org.w3c.dom.Node that is an instance of
 * org.w3c.dom.Document.  If the result of an XMLQUERY operation
 * does not fit this criteria then it will *not* be storable into
 * Derby XML columns.
 */
short
	xqReturningClause() throws StandardException :
{
}
{
	LOOKAHEAD( { getToken(2).kind == SEQUENCE } )
	<RETURNING> <SEQUENCE>
	{ // XMLQUERY should return result as a sequence.
	  // NOTE: since Derby XML columns only allow DOCUMENT(UNTYPED),
	  // the result of an XMLQUERY operator that returns SEQUENCE
	  // might not be storable into an XML column.
		return com.pivotal.gemfirexd.internal.iapi.types.XML.XQ_RETURN_SEQUENCE;
	}
|
	<RETURNING> <CONTENT>
	{ // XMLQUERY should return 'content'.
		throw StandardException.newException(
			SQLState.LANG_UNSUPPORTED_XML_FEATURE, "RETURNING CONTENT");
	}
}

/*
 * <A NAME="xqEmptyHandlingClause">xqEmptyHandlingClause</A>
 *
 * Defines what the behavior should be when an XMLQUERY operator
 * results in an empty sequence.  For now we just return the
 * empty sequence.
 */
short
	xqEmptyHandlingClause() throws StandardException :
{
}
{
	LOOKAHEAD( { getToken(1).kind == EMPTY })
	<EMPTY> <ON> <EMPTY>
	{ // XMLQUERY should return an empty sequence when result of
	  // the query is an empty sequence (i.e. when there are no
	  // results).
		return com.pivotal.gemfirexd.internal.iapi.types.XML.XQ_EMPTY_ON_EMPTY;
	}
|
	<NULL> <ON> <EMPTY>
	{ // XMLQUERY should return a null XML value when result of
	  // the query is an empty sequence (i.e. when there are no
	  // results).
		throw StandardException.newException(
			SQLState.LANG_UNSUPPORTED_XML_FEATURE, "NULL ON EMPTY");
	}
}

/*
 * <A NAME="numericFunctionType">numericFunctionType</A>
 */
DataTypeDescriptor
numericFunctionType() throws StandardException :

{
	DataTypeDescriptor dts;
}
{
	dts = doubleType()
	{
		return dts;
	}
	|
	dts = exactIntegerType()
	{
		return dts;
	}
}

/*
 * <A NAME="dateTimeScalarFunction">dateTimeScalarFunction</A>
 */
ValueNode
dateTimeScalarFunction() throws StandardException :
{
	ValueNode	value;
	ValueNode	timestampNode;
        int             field;
}
{
    /*
     * NOTE: If you add a new rule here, you must add the appropriate
     *    LOOKAHEAD rule to miscBuiltins().
     */
        <TIME> <LEFT_PAREN> value = additiveExpression(null,0, false) <RIGHT_PAREN>
	{
		ValueNode castValue = (ValueNode) nodeFactory.getNode(
							C_NodeTypes.CAST_NODE,
                                                        value,
                                                        DataTypeDescriptor.getBuiltInDataTypeDescriptor( Types.TIME),
                                                        getContextManager());
		((CastNode) castValue).setForExternallyGeneratedCASTnode();
		return castValue;
        }
|
        <DATE> <LEFT_PAREN> value = additiveExpression(null,0, false) <RIGHT_PAREN>
	{
		return (ValueNode) nodeFactory.getNode(
							C_NodeTypes.UNARY_DATE_TIMESTAMP_OPERATOR_NODE,
                                                        value,
                                                        DataTypeDescriptor.getBuiltInDataTypeDescriptor( Types.DATE),
                                                        getContextManager());
        }
|
        <TIMESTAMP> <LEFT_PAREN> value = additiveExpression(null,0, false) timestampNode = timestampFunctionCompletion( value)
	{
                return timestampNode;
        }
|
        field = datetimeField() <LEFT_PAREN> value = additiveExpression(null,0, false) <RIGHT_PAREN>
	{
		return (ValueNode) nodeFactory.getNode(
								C_NodeTypes.EXTRACT_OPERATOR_NODE,
								ReuseFactory.getInteger(field),
								value,
								getContextManager());
	}
}


/*
 * <A NAME="timestampFunctionCompletion">timestampFunctionCompletion</A>
 */
ValueNode
timestampFunctionCompletion( ValueNode firstArg) throws StandardException :
{
        ValueNode timeValue;
}
{
        <RIGHT_PAREN>
	{
		return (ValueNode) nodeFactory.getNode(
							C_NodeTypes.UNARY_DATE_TIMESTAMP_OPERATOR_NODE,
                                                        firstArg,
                                                        DataTypeDescriptor.getBuiltInDataTypeDescriptor( Types.TIMESTAMP),
                                                        getContextManager());
        }
|
        <COMMA> timeValue = additiveExpression(null,0, false) <RIGHT_PAREN>
	{
		return (ValueNode) nodeFactory.getNode(
							C_NodeTypes.TIMESTAMP_OPERATOR_NODE,
                                                        firstArg,
                                                        timeValue,
                                                        getContextManager());
        }
}

/*
 * <A NAME="booleanLiteral">booleanLiteral</A>
 */
Token
booleanLiteral() :
{
	Token tok;
}
{
	tok = <TRUE>
	{
		return tok;
	}
|
	tok = <FALSE>
	{
		return tok;
	}
}

/*
 * <A NAME="generalValueSpecification">generalValueSpecification</A>
 */
ValueNode
generalValueSpecification() throws StandardException :
{
		ValueNode	parm;
}
{
	parm = dynamicParameterSpecification()
	{
		return parm;
	}
|
	parm = userNode()
	{
		return parm;
	}
|
	parm = currentRoleNode()
	{
		return parm;
	}
}

ValueNode
userNode() throws StandardException :
{
}
{
	<USER>
	{
		return (ValueNode) nodeFactory.getNode(
								C_NodeTypes.USER_NODE,
								getContextManager());
	}
|
	<CURRENT_USER>
	{
		return (ValueNode) nodeFactory.getNode(
						C_NodeTypes.CURRENT_USER_NODE,
						getContextManager());
	}
|
	<SESSION_USER>
	{
		return (ValueNode) nodeFactory.getNode(
						C_NodeTypes.SESSION_USER_NODE,
						getContextManager());
	}
}


/*
 * <A NAME="currentRoleNode">currentRoleNode</A>
 */
ValueNode
currentRoleNode() throws StandardException :
{
}
{
	<CURRENT_ROLE>
	{
		throw StandardException.newException
            (SQLState.NOT_IMPLEMENTED, "ROLES");
		checkVersion( DataDictionary.DD_VERSION_DERBY_10_4, "ROLES");
		checkSqlStandardAccess("CURRENT_ROLE");
		return (ValueNode) nodeFactory.getNode(
			C_NodeTypes.CURRENT_ROLE_NODE,
			getContextManager());
	}
}


/*
 * <A NAME="newInvocation">newInvocation</A>
 */
JavaToSQLValueNode
newInvocation() throws StandardException :
{
	QueryTreeNode	newNode;
	Vector	parameterList = new Vector();
	String	javaClassName;
}
{
	<NEW> javaClassName = javaClassName() methodCallParameterList(parameterList)
	{			
		if (!javaClassName.startsWith("com.pivotal.gemfirexd.internal.diag.") && !javaClassName.startsWith("com.pivotal.gemfirexd.internal.catalog.") && !javaClassName.startsWith("com.ibm.db2j."))
		{
			checkInternalFeature(javaClassName);
		}
		newNode =  nodeFactory.getNode(C_NodeTypes.NEW_INVOCATION_NODE,
									   javaClassName,
									   parameterList, 
									   lastTokenDelimitedIdentifier,
									   getContextManager());

		/*
		** Assume this is being returned to the SQL domain.  If it turns
		** out that this is being returned to the Java domain, we will
		** get rid of this node.
		*/
		return (JavaToSQLValueNode) nodeFactory.getNode(
								C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
								newNode,
								getContextManager());
	}
}

/*
 * <A NAME="vtiTableConstruct">vtiTableConstruct</A>
 *
 * Parse a TABLE() constructor that corresponds to an internal
 * VTI invocation.  For example:
 *
 *    TABLE ( <qualifiedName> (arg1, arg2, ...) )
 *
 * where <qualifiedName> is a table name that Derby will map internally
 * to a VTI (ex. "SYSCS_DIAG.SPACE_TABLE").  The list of arguments
 * will then be passed to the VTI when it is invoked (DERBY-2152).
 *
 * An example query where this might occur is as follows:
 *
 *   SELECT * FROM TABLE(SYSCS_DIAG.SPACE_TABLE('APP', 'T1')) x
 *
 * in which case SYSCS_DIAG.SPACE_TABLE will be mapped (internally)
 * to the "com.pivotal.gemfirexd.internal.diag.SpaceTable" diagnostic VTI.  Thus
 * the equivalent call prior to DERBY-2152 would have been:
 *
 *   SELECT * FROM NEW com.pivotal.gemfirexd.internal.diag.SpaceTable('APP', 'T1')) x
 *
 * Note that this latter syntax is still supported.
 */
JavaToSQLValueNode
vtiTableConstruct() throws StandardException :
{
    NewInvocationNode newNode = null;
    QueryTreeNode invocationNode = null;
    Vector parameterList = new Vector();
    TableName vtiTableName = null;
    TableDescriptor td;
    MethodCallNode	methodNode;
}
{
    <TABLE> <LEFT_PAREN>
        vtiTableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
        methodCallParameterList(parameterList)
    <RIGHT_PAREN>
    {
        /* The fact that we pass a NULL table descriptor to the
        * following call is an indication that we are mapping to a
        * VTI table function (i.e. one that accepts arguments).
        * Since we have the table name we do not need to pass in a
        * TableDescriptor--we'll just create one from the table
        * name. See NewInvocationNode for more.
        */
        newNode = (NewInvocationNode) nodeFactory.getNode
        (
            C_NodeTypes.NEW_INVOCATION_NODE,
            vtiTableName,  // TableName
            null,          // TableDescriptor
            parameterList, 
            lastTokenDelimitedIdentifier,
            getContextManager());

        if ( newNode.isBuiltinVTI() ) { invocationNode = newNode; }
        else
        {
            methodNode = (MethodCallNode) nodeFactory.getNode(
                C_NodeTypes.STATIC_METHOD_CALL_NODE,
                vtiTableName,
                null,
                getContextManager());
            methodNode.addParms(parameterList);

            invocationNode = methodNode;
        }


        /*
        ** Assume this is being returned to the SQL domain.  If it turns
        ** out that this is being returned to the Java domain, we will
        ** get rid of this node.
        */
        return (JavaToSQLValueNode) nodeFactory.getNode(
                    C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
                    invocationNode,
                    getContextManager());
    }
}

/*
 * <A NAME="staticMethodInvocation">staticMethodInvocation</A>
 */
ValueNode
staticMethodInvocation(String javaClassName) throws StandardException :
{
	Vector	parameterList = new Vector();
	MethodCallNode	methodNode;
}
{
	methodNode = staticMethodName(javaClassName) methodCallParameterList(parameterList)
	{
		methodNode.addParms(parameterList);

		/*
		** Assume this is being returned to the SQL domain.  If it turns
		** out that this is being returned to the Java domain, we will
		** get rid of this node.
		*/
		return (ValueNode) nodeFactory.getNode(
								C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
								methodNode,
								getContextManager());
	}
}

/**
 * <A NAME="methodCallParameterList">methodCallParameterList</A>
*/

void methodCallParameterList(Vector parameterList) throws StandardException :
{
}
{
	<LEFT_PAREN>
		[ methodParameter(parameterList)
			( <COMMA> methodParameter(parameterList) )* ]
	<RIGHT_PAREN>
}

/*
 * <A NAME="routineInvocation">routineInvocation</A>
 */
ValueNode
routineInvocation() throws StandardException :
{
	Vector	parameterList = new Vector();
	TableName	routineName;
	MethodCallNode	methodNode;
}
{
	routineName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
		methodCallParameterList(parameterList)
	{
		methodNode = (MethodCallNode) nodeFactory.getNode(
								C_NodeTypes.STATIC_METHOD_CALL_NODE,
								routineName,
								null,
								getContextManager());

		methodNode.addParms(parameterList);

		/*
		** Assume this is being returned to the SQL domain.  If it turns
		** out that this is being returned to the Java domain, we will
		** get rid of this node.
		*/
		return (ValueNode) nodeFactory.getNode(
								C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
								methodNode,
								getContextManager());
	}
}

/*
 * <A NAME="javaClass">javaClass</A>
 */

String
javaClass() throws StandardException :
{
	String javaClassName;
}
{
	javaClassName = javaClassName() 
	{
		return javaClassName;
	}
}

/*
 * <A NAME="columnMethodInvocation">columnMethodInvocation</A>
 */
ValueNode
columnMethodInvocation() throws StandardException :
{
	ValueNode	columnReference;
	ValueNode	methodNode;
}
{
	columnReference = columnNameForInvocation()
	methodNode = nonStaticMethodInvocation(columnReference)
	{
		return methodNode;
	}
}

/*
 * <A NAME="columnNameForInvocation">columnNameForInvocation</A>
 */
ValueNode
columnNameForInvocation() throws StandardException :
{
	String firstName;
	String secondName = null;
	String thirdName = null;
	String		columnName = null;
	String		tableName = null;
	String		schemaName = null;
	TableName	tabName = null;
	ValueNode	retval;
}
{
	firstName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	[
		// This LOOKAHEAD is required because we have the following cases:
		// schema.table.column.method()
		// table.column.method()
		// column.method()
		//
		// We have to look ahead to ensure that there is at least one more
		// PERIOD after the current one, so that we don't consider the
		// method name to be a table or column name
		LOOKAHEAD( {
					getToken(1).kind == PERIOD &&
					getToken(3).kind == PERIOD
				} )
		<PERIOD> secondName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
		[
			// See above: we don't want to mistake the method name for a
			// column name.
			LOOKAHEAD( {
						getToken(1).kind == PERIOD &&
						getToken(3).kind == PERIOD
					} )
			<PERIOD> thirdName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
		]
	]
	{
		// Figure out what each identifier stands for
		if (thirdName == null)
		{
			if (secondName == null)
			{
				// There's only one identifier, so it must be a column name
				columnName = firstName;
			}
			else
			{
				// There are two identifiers, so they are table and column names
				tableName = firstName;
				columnName = secondName;
			}
		}
		else
		{
			// There are three identifiers,
			// so they are schema, table, and column names
			schemaName = firstName;
			tableName = secondName;
			columnName = thirdName;
		}

		if (tableName != null)
		{
			// There is a table name, so get a TableName node
			tabName =
				(TableName) nodeFactory.getNode(
							C_NodeTypes.TABLE_NAME,
							schemaName,
							tableName,
// GemStone changes BEGIN
							// changed to use Integer.valueOf()
							Integer.valueOf(nextToLastIdentifierToken.beginOffset),
							Integer.valueOf(nextToLastIdentifierToken.endOffset),
// GemStone changes END
							getContextManager());
		}

		// Get the column reference
		retval = (ValueNode) nodeFactory.getNode(
									C_NodeTypes.COLUMN_REFERENCE,
									columnName,
									tabName,
// GemStone changes BEGIN
									// changed to use Integer.valueOf()
									Integer.valueOf(lastIdentifierToken.beginOffset),
									Integer.valueOf(lastIdentifierToken.endOffset),
// GemStone changes END
									getContextManager());

		return retval;
	}
}

/*
 * <A NAME="columnReference">columnReference</A>
 */
ColumnReference
columnReference() throws StandardException :
{
	String		firstName;
	String		secondName = null;
	String		thirdName = null;
	String		columnName = null;
	String		tableName = null;
	String		schemaName = null;
	TableName	tabName = null;
}
{
	firstName = identifier(Limits.MAX_IDENTIFIER_LENGTH, false)
	[
		// This LOOKAHEAD is needed to ensure that, if the identifier
		// after the PERIOD is a method name , we
		// don't treat it as part of the column reference.
		LOOKAHEAD( {
					getToken(1).kind == PERIOD &&
					getToken(3).kind != LEFT_PAREN
				} )
		<PERIOD> secondName = identifier(Limits.MAX_IDENTIFIER_LENGTH, false)
		[
			// This LOOKAHEAD is needed to ensure that, if the identifier
			// after the PERIOD is a method name , we
			// don't treat it as part of the column reference.
			LOOKAHEAD( {
						getToken(1).kind == PERIOD &&
						getToken(3).kind != LEFT_PAREN
					} )
			<PERIOD> thirdName = identifier(Limits.MAX_IDENTIFIER_LENGTH, false)
		]
	]
	{
		// Figure out what each name stands for
		if (thirdName == null)
		{
			if (secondName == null)
			{
				// Only one name, must be column name
				columnName = firstName;
			}
			else
			{
				// Two names: table.column
				tableName = firstName;
				columnName = secondName;
			}
		}
		else
		{
			// Three names: schema.table.column
			schemaName = firstName;
			tableName = secondName;
			columnName = thirdName;
		}

		checkIdentifierLengthLimit(columnName, Limits.MAX_IDENTIFIER_LENGTH);
		if (schemaName != null)
			checkIdentifierLengthLimit(schemaName, Limits.MAX_IDENTIFIER_LENGTH);
		if (tableName != null)
			checkIdentifierLengthLimit(tableName, Limits.MAX_IDENTIFIER_LENGTH);

		if (tableName != null)
		{
			tabName = (TableName) nodeFactory.getNode(
							C_NodeTypes.TABLE_NAME,
							schemaName,
							tableName,
// GemStone changes BEGIN
							// changed to use Integer.valueOf()
							Integer.valueOf(nextToLastIdentifierToken.beginOffset),
							Integer.valueOf(nextToLastIdentifierToken.endOffset),
// GemStone changes END
							getContextManager());
		}

		return (ColumnReference) nodeFactory.getNode(
								C_NodeTypes.COLUMN_REFERENCE,
								columnName,
								tabName,
// GemStone changes BEGIN
								// changed to use Integer.valueOf()
								Integer.valueOf(lastIdentifierToken.beginOffset),
								Integer.valueOf(lastIdentifierToken.endOffset),
// GemStone changes END
								getContextManager());
	}
}

/*
void
columnReference() throws StandardException :
{}
{
	/*
	**
	** I re-wrote the above rule because it caused a grammar ambiguitity.
	** The problem is that we are parsing a dot-separated list of identifiers,
	** and the grammar doesn't know what the identifiers stand for, but the
	** syntax assumed that it did.  For example, in schema.table.column,
	** the grammar doesn't know when it parses the first identifier whether
	** it will be a catalog name, schema name, table name, or column name.
	**
	** I think this problem could be solved by increasing the lookahead.
	** I will try that solution next.  I like that solution better because,
	** if it works, it will be easier for the grammar to figure out what
	** each identifier stands for.
	**

	[ <MODULE> <PERIOD> <IDENTIFIER> |
	  [ [ [ <IDENTIFIER> <PERIOD> ] <IDENTIFIER> <PERIOD> ] <IDENTIFIER> <PERIOD> ]
	]
	<IDENTIFIER>
}
*/

OrderByList
orderByClause() throws StandardException :
{
	OrderByList orderCols;
}
{
	<ORDER> <BY> orderCols = sortSpecificationList()
	{
		return orderCols;
	}
}

int
atIsolationLevel() throws StandardException :
{
	int isolationLevel;
}
{
	<WITH> isolationLevel = isolationLevelDB2Abbrev()
	{
		return isolationLevel;
	}

}

OrderByList
sortSpecificationList() throws StandardException :
{ 
	OrderByList orderCols = (OrderByList) nodeFactory.getNode(
											C_NodeTypes.ORDER_BY_LIST,
											getContextManager()); 
}
{
	sortSpecification(orderCols) ( <COMMA> sortSpecification(orderCols) ) *
	{
		return orderCols;
	}
}

void
sortSpecification(OrderByList orderCols) throws StandardException :
{	OrderByColumn orderCol; }
{
	orderCol = sortKey() /* [ collateClause() ] */ [ orderingSpecification(orderCol) ] [ nullOrdering(orderCol) ]
	{
		orderCols.addOrderByColumn(orderCol);
	} 
}

OrderByColumn
sortKey() throws StandardException :
{
	ValueNode columnExpression;
} 
{
  // GemStone changes BEGIN
  // disable constants in order by clauses.
  {boolean existing = getCompilerContext().switchOptimizeLiteral(false);}
  // GemStone changes END
	columnExpression = additiveExpression(null,0,true)
	{
    // GemStone changes BEGIN
    getCompilerContext().switchOptimizeLiteral(existing);
    // GemStone changes END
		return (OrderByColumn) nodeFactory.getNode(
								C_NodeTypes.ORDER_BY_COLUMN,
								columnExpression,
								getContextManager());
	}
}



void
orderingSpecification(OrderByColumn orderCol) :
{}
{
	<ASC> 
|
	<DESC>
	{
		orderCol.setDescending();
	}
}

/*
 * The data type comparison functions need to know whether NULL values
 * should sort higher than non-NULL values, or lower. The answer to this
 * depends on whether the user specified ASCending or DESCending, and on
 * whether the user specified NULLS FIRST, or NULLS LAST, as follows:
 *
 * +===============+========+========+
 * | ORDER BY says | ASC    | DESC   |
 * +===============+========+========+
 * | NULLS FIRST   | less   | greater|
 * +===============+========+========+
 * | NULLS LAST    | greater| less   |
 * +===============+========+========+
 */
void
nullOrdering(OrderByColumn orderCol) :
{}
{
        LOOKAHEAD( { getToken(2).kind == LAST } )
        <NULLS> <LAST>
        {
            if (! orderCol.isAscending())
                orderCol.setNullsOrderedLow();
        }
|
        <NULLS> <FIRST>
        {
            if (orderCol.isAscending())
                orderCol.setNullsOrderedLow();
        }
}


/*
 * <A NAME="offsetClause">offsetClause</A>
 */
ValueNode
offsetClause() throws StandardException :
{
    ValueNode result = null;
}
{
    // Since OFFSET is not yet a reserved keyword, cf. disambiguation
    // look-ahead for it w.r.t. offsetClause in method nonReservedKeyword.
    // This solves the shift/reduce conflict, and allows us to use OFFSET as an
    // identifier in all contexts.
    <OFFSET>
    ( result = intLiteral()
	| result = dynamicParameterSpecification()
    )
	( <ROW> | <ROWS> )
	{
        return result;
    }
}


/*
 * <A NAME="fetchFirstClause">fetchFirstClause</A>
 */
ValueNode
fetchFirstClause() throws StandardException :
{
    // The default number of rows to fetch if the literal is omitted is 1:
    ValueNode result = getNumericNode("1", true);
}
{
    <FETCH> ( <FIRST> | <NEXT> )
    //GemStone changes BEGIN
    //inserting switchOptimizedLiteral
    //originally [ result = intLiteral() ( <ROW> | <ROWS> ) <ONLY>
     [
       {boolean existing = getCompilerContext().switchOptimizeLiteral(false);} 
       result = intLiteral() 
       {getCompilerContext().switchOptimizeLiteral(existing);}
     | result = dynamicParameterSpecification()
     ] ( <ROW> | <ROWS> ) <ONLY>
    //GemStone changes END
    {
        return result;
    }
}



/*
 * <A NAME="forUpdateClause">forUpdateClause</A>
 */
int
forUpdateClause(Vector columnList) throws StandardException :
{
	int	retval;
}
{
	<UPDATE> [ <OF> forUpdateColumnList(columnList) ]
	{
		return CursorNode.UPDATE;
	}
|
	<READ> <ONLY>
	{
		return CursorNode.READ_ONLY;
	}
|
	<FETCH> <ONLY>
	{
		return CursorNode.READ_ONLY;
	}
}

/*
 * <A NAME="forUpdateColumnList">forUpdateColumnList</A>
 */
void
forUpdateColumnList(Vector columnList) throws StandardException :
{
}
{
	forUpdateColumn(columnList) ( <COMMA> forUpdateColumn(columnList) ) *
}

/*
 * <A NAME="forUpdateColumn">forUpdateColumn</A>
 */
void
forUpdateColumn(Vector columnList) throws StandardException :
{
	String		 columnName;
}
{
	/* identifier() used to be columnName() */
	columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	{
		columnList.addElement(columnName);
	}
}

/*
 * <A NAME="setClauseList">setClauseList</A>
 */
ResultColumnList
setClauseList() throws StandardException :
{
	ResultColumnList	columnList = (ResultColumnList) nodeFactory.getNode(
												C_NodeTypes.RESULT_COLUMN_LIST,
												getContextManager());
}
{
	setClause(columnList) ( <COMMA> setClause(columnList) ) *
	{
		return columnList;
	}
}

/*
 * <A NAME="setClause">setClause</A>
 */
void
setClause(ResultColumnList columnList) throws StandardException :
{
	ResultColumn resultColumn;
	ColumnReference	 columnName;
	ValueNode	 valueNode;
}
{
	/* identifier() used to be objectColumn() */
	/*
		SQL92 only wants identifiers here (column names)
		but JBuilder expects table.column, so we allow the
		general form.
	 */
	columnName = columnReference() <EQUALS_OPERATOR> valueNode = updateSource(columnName.getColumnName())
	{
		resultColumn = (ResultColumn) nodeFactory.getNode(
										C_NodeTypes.RESULT_COLUMN,
										columnName,
										valueNode,
										getContextManager());
		columnList.addResultColumn(resultColumn);
	}
}

/*
 * <A NAME="updateSource">updateSource</A>
 */
ValueNode
updateSource(String columnName) throws StandardException :
{
	ValueNode	valueNode;
}
{
	valueNode = additiveExpression(null,0, false) 
	{
		return valueNode;
	}
|
	valueNode = nullSpecification() 
	{
		return valueNode;
	}
|
	<_DEFAULT>
	{
		return (ValueNode) nodeFactory.getNode(
								C_NodeTypes.DEFAULT_NODE,
								columnName,
								getContextManager());
	}
}

/*
 * <A NAME="nullSpecification">nullSpecification</A>
 */
ValueNode
nullSpecification() throws StandardException :
{}
{
	<NULL>
	{
		return (ValueNode) nodeFactory.getNode(
									C_NodeTypes.UNTYPED_NULL_CONSTANT_NODE,
									getContextManager());
	}
}


// Gemstone Changes BEGIN
/*
 * <A NAME="specificationForRange">specificationForRange</A>
 */
ValueNode specificationForRange() throws StandardException :
{
  ValueNode node;
}
{
  LOOKAHEAD({ getToken(1).kind == INFINITY || getToken(2).kind == INFINITY })
  (
    (< PLUS_SIGN >)? < INFINITY >
  | < MINUS_SIGN > < INFINITY >
  )
  {
    return null;
  }
|
  node = additiveExpression(null, 0, false)
  {
    return node;
  }
}
// Gemstone Changes END

/*
 * <A NAME="insertColumnsAndSource">insertColumnsAndSource</A>
 */
StatementNode
insertColumnsAndSource(QueryTreeNode targetTable, boolean isPutDML) 
	throws StandardException :
{
	Properties			targetProperties = null;
	ResultSetNode	queryExpression;
	ResultColumnList	columnList = null;
}
{
	[
		// This LOOKAHEAD is required because a query expression can
		// be a SELECT or VALUES nested arbitrarily deep in parentheses
		// (which looks like a subquery). So, to be sure that a left
		// parenthesis introduces an insertColumnList(), we have to
		// be sure it doesn't introduce a subquery.
		LOOKAHEAD( { getToken(1).kind == LEFT_PAREN && ! subqueryFollows() } )
		<LEFT_PAREN> columnList = insertColumnList() <RIGHT_PAREN>
	]
	[ targetProperties = propertyList(false) <CHECK_PROPERTIES>]
	queryExpression = queryExpression(null, NO_SET_OP)
	{
               return (StatementNode) nodeFactory.getNode(
							C_NodeTypes.INSERT_NODE,
							targetTable,
							columnList,
							queryExpression,
							targetProperties,
							isPutDML,
							getContextManager());
	}
	/* RESOLVE: Ignoring default values for now
|
	[ targetProperties = propertyList(false) <CHECK_PROPERTIES>]
	<_DEFAULT> <VALUES>
	{
		return null;
	}
	*/
}

/*
 * <A NAME="insertColumnList">insertColumnList</A>
 */
ResultColumnList
insertColumnList() throws StandardException :
{
	ResultColumnList	columnList = (ResultColumnList) nodeFactory.getNode(
												C_NodeTypes.RESULT_COLUMN_LIST,
												getContextManager());
}
{
	columnQualifiedNameList(columnList)
	{
		return columnList;
	}
}

/*
 * <A NAME="columnQualifiedNameList">columnQualifiedNameList</A>
 */
void
columnQualifiedNameList(ResultColumnList columnList) throws StandardException :
{}
{
	columnQualifiedNameItem(columnList) ( <COMMA> columnQualifiedNameItem(columnList) ) *
}

/*
 * <A NAME="columnQualifiedNameItem">columnQualifiedNameItem</A>
 */
void
columnQualifiedNameItem(ResultColumnList columnList) throws StandardException :
{
	ColumnReference		columnRef;
	ResultColumn	resultColumn;
}
{
	/*
		SQL92 only wants identifiers here (column names)
		but JBuilder expects table.column, so we allow the
		general form.
	 */
	columnRef = columnReference()
	{
		/*
		** Store the column names for the result columns in the
		** result column list.  We don't know yet what valueNodes
		** should be hooked up to each result column, so set that
		** to null for now.
		*/
		resultColumn = (ResultColumn) nodeFactory.getNode(
										C_NodeTypes.RESULT_COLUMN,
										columnRef,
										null,
										getContextManager());
		columnList.addResultColumn(resultColumn);
	}
}

/*
 * <A NAME="rowValueConstructor">rowValueConstructor</A>
 */
ResultSetNode
rowValueConstructor(ResultSetNode leftRSN) throws StandardException :
{
	ResultColumnList	resultColumns = (ResultColumnList) nodeFactory.getNode(
												C_NodeTypes.RESULT_COLUMN_LIST,
												getContextManager());
	ResultSetNode		newRSN;
}
{
	// This LOOKAHEAD is required because a rowValueConstructorList is
	// nested in parentheses, and each element of the list can also be
	// nested in an arbitrary number of parentheses.
	LOOKAHEAD( { rowValueConstructorListFollows() } )
	<LEFT_PAREN> rowValueConstructorList(resultColumns) <RIGHT_PAREN>
	{
		/* If leftRSN is null, simply return the newRSN, else generate and
		 * return a UNION ALL above the 2 RSNs, after verifying that the size()
		 * of both RSNs RCLs is the same.
		 */
		newRSN = (ResultSetNode) nodeFactory.getNode(
								C_NodeTypes.ROW_RESULT_SET_NODE,
								resultColumns,
								null,
								getContextManager());
		if (leftRSN != null)
		{
			if (leftRSN.getResultColumns().size() !=
				newRSN.getResultColumns().size())
			{
				throw StandardException.newException(SQLState.LANG_ROW_VALUE_CONSTRUCTOR_UNMATCHED_COLUMNS);
			}

			newRSN = (ResultSetNode) nodeFactory.getNode(	
									C_NodeTypes.UNION_NODE,
									leftRSN,
									newRSN,
									Boolean.TRUE,
									Boolean.TRUE,
									null,
									getContextManager());
		}
		return newRSN;
		
	}
|
	rowValueConstructorElement(resultColumns)
	{
		/* If leftRSN is null, simply return the newRSN, else generate and
		 * return a UNION ALL above the 2 RSNs, after verifying that the size()
		 * of both RSNs RCLs is the same.
		 */
		newRSN = (ResultSetNode) nodeFactory.getNode(
								C_NodeTypes.ROW_RESULT_SET_NODE,
								resultColumns,
								null,
								getContextManager());
		if (leftRSN != null)
		{
			if (leftRSN.getResultColumns().size() !=
				newRSN.getResultColumns().size())
			{
				throw StandardException.newException(SQLState.LANG_ROW_VALUE_CONSTRUCTOR_UNMATCHED_COLUMNS);
			}

			newRSN = (ResultSetNode) nodeFactory.getNode(
									C_NodeTypes.UNION_NODE,
									leftRSN,
									newRSN,
									Boolean.TRUE,
									Boolean.TRUE,
									null,
									getContextManager());
		}
		return newRSN;
	}
}

/*
 * <A NAME="rowValueConstructorElement">rowValueConstructorElement</A>
 */
void
rowValueConstructorElement(ResultColumnList resultColumns) throws StandardException :
{
	ValueNode	value;
}
{
	value = additiveExpression(null, 0, true)
	{
		resultColumns.addResultColumn(
			(ResultColumn) nodeFactory.getNode(
							C_NodeTypes.RESULT_COLUMN,
							null,
							value,
							getContextManager())
				);
	}
|
	value = nullSpecification()
	{
		resultColumns.addResultColumn(
			(ResultColumn) nodeFactory.getNode(
							C_NodeTypes.RESULT_COLUMN,
							null,
							value,
							getContextManager())
				);
	}
|
	<_DEFAULT>
	{
		resultColumns.addResultColumn(
			(ResultColumn) nodeFactory.getNode(
							C_NodeTypes.RESULT_COLUMN,
							null,
							(ValueNode) nodeFactory.getNode(
								C_NodeTypes.DEFAULT_NODE,
								null,
								getContextManager()),
							getContextManager())
				);
	}
|
	{
		throw StandardException.newException(SQLState.LANG_EMPTY_VALUES_CLAUSE);
	}
}

/*
 * <A NAME="rowValueConstructorList">rowValueConstructorList</A>
 */
void
rowValueConstructorList(ResultColumnList resultColumns) throws StandardException :
{}
{
	rowValueConstructorElement(resultColumns)
		( <COMMA> rowValueConstructorElement(resultColumns) ) *
}


/*
 * <A NAME="tableSubquery">tableSubquery</A>
 */
SubqueryNode
tableSubquery(int subqueryType, ValueNode leftOperand) throws StandardException :
{
	SubqueryNode	subqueryNode;
}
{
	subqueryNode = subquery(subqueryType, leftOperand)
	{
		return subqueryNode;
	}
}


/*
 * <A NAME="subquery">subquery</A>
 */
SubqueryNode
subquery(int subqueryType, ValueNode leftOperand) throws StandardException :
{
	ResultSetNode	queryExpression;
	SubqueryNode	subqueryNode;
	 // GemStone changes BEGIN
    ValueNode offset = null;
    ValueNode fetchFirst = null;
    
	  int startIndex = token.endOffset+1;
	  if(this.subqueryParamCount == null)
	  {
	        CompilerContext cc = getCompilerContext();
            this.subqueryParamCount = new ArrayDeque<List<Integer>>();            
            this.subqueryParams= new ArrayDeque<List<ConstantNode>>();
            
	  }
	  this.subqueryParamCount.push(new ArrayList<Integer>(5));	  
	  this.subqueryParams.push(new ArrayList<ConstantNode>(5));
	  
	 // GemStone changes END
}
{
        
	queryExpression = queryExpression(null, NO_SET_OP)
     // GemStone changes BEGIN
     {
       
       if(queryExpression instanceof SelectNode)
       {
          ((SelectNode)queryExpression).setParentSubQueryNodeFlag();
           
       }
     }
       
    [ offset = offsetClause() ]
    [ fetchFirst = fetchFirstClause() ]
    // GemStone changes END      
	{
	  // GemStone changes BEGIN
	        int endIndex = this.token.endOffset+1;
	        CompilerContext cc = getCompilerContext();
	        List<Integer > params = this.subqueryParamCount.pop();
	        List<ConstantNode> paramsIndex = this.subqueryParams != null? this.subqueryParams.pop():null;
	  // GemStone changes END      
		subqueryNode = (SubqueryNode) nodeFactory.getNode(
										C_NodeTypes.SUBQUERY_NODE,
										queryExpression,
										offset,
										fetchFirst, 
										ReuseFactory.getInteger(subqueryType),
										leftOperand,
										getContextManager());
	// GemStone changes BEGIN
	    String subqueryTxt = statementSQLText.substring(startIndex, endIndex);
	    
	    int adjustment = startIndex;
	    if(paramsIndex != null) {
	    StringBuilder builder = new StringBuilder(subqueryTxt);
	      for(ConstantNode cn:paramsIndex) {
	         int begin = cn.getBeginOffset() - adjustment;
	         int end = cn.getEndOffset()-adjustment;
	         builder.replace(begin,end,"<?>");
	         adjustment += end-begin -"<?>".length();
	         
	      }
	      subqueryTxt = builder.toString();
	    }
		subqueryNode.setSubqueryString(subqueryTxt);
		
		subqueryNode.setGfxdSubactivationFlag( this.gfxdSubactivationNeeded);
		subqueryNode.setParams( params);
		subqueryNode.setIsPreparedStatement(cc.isPreparedStatement());
		subqueryNode.setIsOptimizeLiteralAllowed(cc.isOptimizeLiteralAllowed());
	// GemStone changes END
		return subqueryNode;
	}
}

/*
 * <A NAME="inPredicateValue">inPredicateValue</A>
 */
ValueNode
inPredicateValue(ValueNode leftOperand) throws StandardException :
{
	ValueNode		retval;
	int				tokKind;
}
{
  	<ARRAY> retval = inArrayPredicateValue(leftOperand)
	{
		return retval;
	}
	|
	<LEFT_PAREN>
	(
		// This LOOKAHEAD is necessary because both a subquery and an
		// inValueList can be nested arbitrarily deep in parentheses,
		// so both can start with LEFT_PAREN. To disambiguate, we only
		// consider it a subquery if the first token that comes after
		// all the LEFT_PARENS is either a SELECT or a VALUES.
		LOOKAHEAD( { subqueryFollows() } )
		retval = tableSubquery(SubqueryNode.IN_SUBQUERY, leftOperand)
	|
		retval = inValueList(leftOperand)
	)
	<RIGHT_PAREN>
	{
		return retval;
	}
}

/*
 * <A NAME="inArrayPredicateValue">inArrayPredicateValue</A>
 */
ValueNode
inArrayPredicateValue(ValueNode leftOperand) throws StandardException :
{
	ValueNode		retval;
	int				tokKind;
}
{
	<LEFT_PAREN>
	(
		retval = inSingleArrayValue(leftOperand)
	)
	<RIGHT_PAREN>
	{
		return retval;
	}
}

/*
 * <A NAME="inValueList">inValueList</A>
 */
ValueNode
inValueList(ValueNode leftOperand) throws StandardException:
{
	ValueNodeList	inList = (ValueNodeList) nodeFactory.getNode(
											C_NodeTypes.VALUE_NODE_LIST,
											getContextManager());
}
{
	inElement(inList) ( <COMMA> inElement(inList) ) *
	{
		return (ValueNode) nodeFactory.getNode(
								C_NodeTypes.IN_LIST_OPERATOR_NODE,
								leftOperand,
								inList,
								getContextManager());
	}
}

/*
 * <A NAME="inSingleArrayValue">inSingleArrayValue</A>
 */
ValueNode
inSingleArrayValue(ValueNode leftOperand) throws StandardException:
{
	ValueNodeList	inList = (ValueNodeList) nodeFactory.getNode(
											C_NodeTypes.VALUE_NODE_LIST,
											getContextManager());
}
{
	inElement(inList)
	{
		InListOperatorNode inListNode = (InListOperatorNode) nodeFactory.getNode(
								C_NodeTypes.IN_LIST_OPERATOR_NODE,
								leftOperand,
								inList,
								getContextManager());
		inListNode.setRightOperandArray();
		return (ValueNode)inListNode;
	}
}

/*
 * <A NAME="inElement">inElement</A>
 */
void
inElement(ValueNodeList inList) throws StandardException :
{
	ValueNode valueNode;
}
{
	valueNode = additiveExpression(null, 0, false)
	{
		inList.addElement(valueNode);
	}
}


/*
 * <A NAME="quantifier">quantifier</A>
 */
int
quantifier(int opType) throws StandardException :
{
	int retval = 0;
}
{
	<ALL> 
	{
		switch (opType)
		{
			case BinaryOperatorNode.EQ:
				retval = SubqueryNode.EQ_ALL_SUBQUERY;
				break;

			case BinaryOperatorNode.NE:
				retval = SubqueryNode.NE_ALL_SUBQUERY;
				break;

			case BinaryOperatorNode.LE:
				retval = SubqueryNode.LE_ALL_SUBQUERY;
				break;

			case BinaryOperatorNode.LT:
				retval = SubqueryNode.LT_ALL_SUBQUERY;
				break;

			case BinaryOperatorNode.GE:
				retval = SubqueryNode.GE_ALL_SUBQUERY;
				break;

			case BinaryOperatorNode.GT:
				retval = SubqueryNode.GT_ALL_SUBQUERY;
				break;

			default:
				if (SanityManager.DEBUG)
				SanityManager.THROWASSERT(
						"Invalid value for opType (" + opType +
						") passed to quantifier()");
		}
		return retval;
	}
|
	some()
	{
		switch (opType)
		{
			case BinaryOperatorNode.EQ:
				retval = SubqueryNode.EQ_ANY_SUBQUERY;
				break;

			case BinaryOperatorNode.NE:
				retval = SubqueryNode.NE_ANY_SUBQUERY;
				break;

			case BinaryOperatorNode.LE:
				retval = SubqueryNode.LE_ANY_SUBQUERY;
				break;

			case BinaryOperatorNode.LT:
				retval = SubqueryNode.LT_ANY_SUBQUERY;
				break;

			case BinaryOperatorNode.GE:
				retval = SubqueryNode.GE_ANY_SUBQUERY;
				break;

			case BinaryOperatorNode.GT:
				retval = SubqueryNode.GT_ANY_SUBQUERY;
				break;

			default:
				if (SanityManager.DEBUG)
				SanityManager.THROWASSERT(
						"Invalid value for opType (" + opType +
						") passed to quantifier()");
		}
		return retval;
	}
}

/*
 * <A NAME="some">some</A>
 */
void
some() throws StandardException :
{}
{
	<SOME> |
	<ANY>
}

/*
 * <A NAME="existsExpression">existsExpression</A>
 */
SubqueryNode
existsExpression() throws StandardException :
{
	SubqueryNode	subqueryNode;
}
{
	<EXISTS> <LEFT_PAREN>
	subqueryNode = tableSubquery(SubqueryNode.EXISTS_SUBQUERY, null)
	<RIGHT_PAREN>
	{
		return subqueryNode;
	}
}

/*
 * <A NAME="tableExpression">tableExpression</A>
 */
SelectNode
tableExpression(ResultColumnList selectList) throws StandardException :
{
	SelectNode	selectNode;
	FromList	fromList;
	ValueNode	whereClause = null;
	GroupByList	groupByList = null;
	ValueNode	havingClause = null;
	Token		whereToken;
}
{
	fromList = fromClause()
	[ whereToken = <WHERE> whereClause = whereClause(whereToken) ]
	[ groupByList = groupByClause() ]
	[ havingClause = havingClause() ]
	{
 
		// fix for HAVING without GROUP BY, makes sure we get one
		// aggregate operator by adding a count(*), this fixes beetle 5853, 5890
		if (havingClause != null && groupByList == null) {
			ValueNode vn = (ValueNode) nodeFactory.getNode(
								C_NodeTypes.AGGREGATE_NODE,
								null,
								com.pivotal.gemfirexd.internal.impl.sql.compile.CountAggregateDefinition.class,
								Boolean.FALSE, // distinct Boolean.TRUE?
                Boolean.TRUE,
								Boolean.FALSE,
								"COUNT(*)",
								getContextManager());
			AggregateNode n = (AggregateNode) vn;
			n.replaceAggregatesWithColumnReferences(selectList, 0);			
		}
		
		selectNode = (SelectNode) nodeFactory.getNode(
							C_NodeTypes.SELECT_NODE,
							selectList,
							null, 		/* AGGREGATE list */
							fromList,
							whereClause,
							groupByList,
							havingClause,
                            Boolean.valueOf(false), /* Dml op */
							getContextManager());

		return selectNode;
	}
}



/*
 * <A NAME="fromClause">fromClause</A>
 */
FromList
fromClause() throws StandardException :
{
	FromList fromList = (FromList) nodeFactory.getNode(
									C_NodeTypes.FROM_LIST,
									getNodeFactory().doJoinOrderOptimization(),
									getContextManager());
	int	tokKind;
        Token   beginToken;
        Token   endToken;
}
{
	<FROM> {beginToken = getToken(1);}
	[
		fromListProperties(fromList)
	]
	dummyTableReferenceRule(fromList)
			( <COMMA> dummyTableReferenceRule(fromList) ) * {endToken = getToken(0);}

	{
                fromList.setBeginOffset( beginToken.beginOffset);
                fromList.setEndOffset( endToken.endOffset);
		return fromList;
	}
}

/*
 * <A NAME="fromListProperties">fromListProperties</A>
 */
void
fromListProperties(FromList fromList) throws StandardException :
{
	Properties properties;
}
{
	properties = propertyList(true) <CHECK_PROPERTIES>
	{
		fromList.setProperties(properties);
	}
}

/* This rule created simply as a way to add the result of tableReference()
 * to the fromList.
 */
void
dummyTableReferenceRule(FromList fromList) throws StandardException :
{
	FromTable tableReference;
}
{
	/* If we have a table constructor and the expression is a SELECT
	 * query or a VALUES query then we read the <TABLE> keyword;
	 * otherwise we leave the <TABLE> token in the queue and let
	 * other types of expressions (namely, vtiTableConstruct())
	 * deal with it accordingly.  DERBY-2152.
	 */
	LOOKAHEAD({ getToken(1).kind == TABLE &&
				getToken(2).kind == LEFT_PAREN &&
				(
					getToken(3).kind == SELECT ||
					getToken(3).kind == VALUES
				)
			}) <TABLE>
	tableReference = tableReferenceTypes(false)
	{
		fromList.addFromTable(tableReference);
	}
|
	tableReference = tableReferenceTypes(false)
	{
		fromList.addFromTable(tableReference);
	}
}

FromTable
tableReferenceTypes(boolean nestedInParens) throws StandardException :
{
	FromTable tableReference;
}
{
	tableReference = tableReference(nestedInParens)
	{
		return tableReference ;
	}
|
	<LEFT_BRACE> <OJ> tableReference = tableReference(nestedInParens) <RIGHT_BRACE>
	{
		return tableReference;
	}
}

Object[]
optionalTableClauses() throws StandardException :
{
	Object[]			 otc = null;
	Properties			tableProperties = null;
	ResultColumnList	derivedRCL = null;
	String				correlationName = null;
}
{
	otc = optionalTableProperties() 
	{
		otc[OPTIONAL_TABLE_CLAUSES_DERIVED_RCL] = derivedRCL;
		otc[OPTIONAL_TABLE_CLAUSES_CORRELATION_NAME] = correlationName;
		return otc;
	}
|
	[ [ <AS> ] 
		correlationName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
		[ <LEFT_PAREN> derivedRCL = derivedColumnList() <RIGHT_PAREN> ] 
	    [tableProperties = propertyList(true) <CHECK_PROPERTIES>] ]
	{
		otc = new Object[OPTIONAL_TABLE_CLAUSES_SIZE];
		otc[OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES] = tableProperties;
		otc[OPTIONAL_TABLE_CLAUSES_DERIVED_RCL] = derivedRCL;
		otc[OPTIONAL_TABLE_CLAUSES_CORRELATION_NAME] = correlationName;
		return otc;
	}
}

Object[]
optionalTableProperties() throws StandardException :
{
	Object[]			otc = null;
	Properties			tableProperties = null;
}
{
	tableProperties = propertyList(true) <CHECK_PROPERTIES> 
	{
		otc = new Object[OPTIONAL_TABLE_CLAUSES_SIZE];
		otc[OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES] = tableProperties;
		return otc;
	}
}

/*
 * <A NAME="tableReference">tableReference</A>
 */
FromTable
tableReference(boolean nestedInParens) throws StandardException :
{
	JavaToSQLValueNode	javaToSQLNode = null;
	TableName			tableName;
	String				correlationName = null;
	ResultColumnList	derivedRCL = null;
	FromTable			fromTable;
	TableOperatorNode	joinTable = null;
	FromTable			tableReference;
	Object[]			optionalTableClauses = new Object[OPTIONAL_TABLE_CLAUSES_SIZE];
	Properties			tableProperties = null;
	ResultSetNode		derivedTable;
}
{
	/* NOTE: this rule has to come first in order to avoid making NEW
	 * a reserved word.
	 */
	/* identifier() used to be correlationName() */
	(LOOKAHEAD({ newInvocationFollows(1) }) javaToSQLNode = newInvocation()
	| javaToSQLNode = vtiTableConstruct()
	)
		[ <AS> ] correlationName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
		[ <LEFT_PAREN> derivedRCL = derivedColumnList() <RIGHT_PAREN> ]
		[ optionalTableClauses = optionalTableProperties() ]
		(LOOKAHEAD( { joinedTableExpressionFollows() } )
		 joinTable = joinedTableExpression(
									(joinTable != null) ?
										joinTable :
										(FromTable) nodeFactory.getNode(
											C_NodeTypes.FROM_VTI,
											javaToSQLNode.getJavaValueNode(), 
											correlationName,
											derivedRCL, 
											((optionalTableClauses != null) ? 
												(Properties) optionalTableClauses[OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES] :
												(Properties) null),
											getContextManager()),
									nestedInParens)) *
	{
		/* Build a derived table if not a join expression */
		if (joinTable == null)
		{
			fromTable = (FromTable) nodeFactory.getNode(
								C_NodeTypes.FROM_VTI,
								javaToSQLNode.getJavaValueNode(), 
								correlationName,
								derivedRCL, 
								((optionalTableClauses != null) ? 
									(Properties) optionalTableClauses[OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES] :
									(Properties) null),
								getContextManager()); 
		}
		else
		{
			fromTable = joinTable;
		}

		return fromTable;
	}
|
	/* identifier() used to be correlationName() */
	tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH) 
		optionalTableClauses = optionalTableClauses()
		(LOOKAHEAD( { joinedTableExpressionFollows() } )
		 joinTable = joinedTableExpression(
									(joinTable != null) ?
										joinTable :
										(FromTable) nodeFactory.getNode(
												C_NodeTypes.FROM_BASE_TABLE,
												tableName,
												(String) optionalTableClauses[OPTIONAL_TABLE_CLAUSES_CORRELATION_NAME],
												(ResultColumnList) optionalTableClauses[OPTIONAL_TABLE_CLAUSES_DERIVED_RCL],
												(Properties) optionalTableClauses[OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES],
												getContextManager()), 
									nestedInParens)) *
	{
		/* Build a from table if not a join expression */
		if (joinTable == null)
		{
			fromTable = (FromTable) nodeFactory.getNode(
											C_NodeTypes.FROM_BASE_TABLE,
											tableName,
												(String) optionalTableClauses[OPTIONAL_TABLE_CLAUSES_CORRELATION_NAME],
												(ResultColumnList) optionalTableClauses[OPTIONAL_TABLE_CLAUSES_DERIVED_RCL],
												(Properties) optionalTableClauses[OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES],
											getContextManager());
		}
		else
		{		   
			fromTable = joinTable;
		}
		return fromTable;
	}
|
	// There is a grammar ambiguity with nested parentheses here.
	// A series of left parentheses could introduce either a table
	// reference or a derived table.  For example:
	//
	//		(((select c from t) a inner join (select d from s) b ))
	//
	// and:
	//
	//		(((select c from t) a)))
	//
	// To distinguish these two cases, we consider anything that starts
	// with a single parenthesis and either SELECT or VALUES to be
	// a derived table, and anything else to be a table reference.
	// Note that we can't use the subqueryFollows() lookahead method,
	// because it skips over all leading left parentheses to decide
	// whether a subquery follows.
	LOOKAHEAD( {
				getToken(1).kind == LEFT_PAREN &&
				(
					getToken(2).kind == SELECT ||
					getToken(2).kind == VALUES
				)
			} )
	derivedTable = derivedTable() [ <AS> ] correlationName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
		[ <LEFT_PAREN> derivedRCL = derivedColumnList() <RIGHT_PAREN> ]
		[ optionalTableClauses = optionalTableProperties() ]
		( LOOKAHEAD( { joinedTableExpressionFollows() } )
		  joinTable = joinedTableExpression(
									(joinTable != null) ?
										joinTable :
										(FromTable) nodeFactory.getNode(
													C_NodeTypes.FROM_SUBQUERY,
													derivedTable, 
													correlationName,
													derivedRCL,
													((optionalTableClauses != null) ?
														(Properties) optionalTableClauses[OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES] :
														(Properties) null),
													getContextManager()),
									nestedInParens)) *
	{
		/* Build a derived table if not a join expression */
		if (joinTable == null)
		{
			fromTable = (FromTable) nodeFactory.getNode(
											C_NodeTypes.FROM_SUBQUERY,
											derivedTable, 
											correlationName,
											derivedRCL,
											((optionalTableClauses != null) ?
												(Properties) optionalTableClauses[OPTIONAL_TABLE_CLAUSES_TABLE_PROPERTIES] :
												(Properties) null),
											getContextManager()); 
		}
		else
		{
			fromTable = joinTable;
		}

		return fromTable;
	}
|
	<LEFT_PAREN> tableReference = tableReferenceTypes(true) <RIGHT_PAREN>
		( LOOKAHEAD( { joinedTableExpressionFollows() } )
		  joinTable = joinedTableExpression(
									(joinTable != null) ?
										joinTable :
										tableReference,
									nestedInParens)) *
	{
		if (joinTable == null)
		{
			fromTable = tableReference; 
		}
		else
		{
			fromTable = joinTable;
		}

		return fromTable;
	}
}

/*
 * <A NAME="derivedColumnList">derivedColumnList</A>
 */
ResultColumnList
derivedColumnList() throws StandardException :
{
	ResultColumnList	resultColumns =
									(ResultColumnList) nodeFactory.getNode(
											C_NodeTypes.RESULT_COLUMN_LIST,
											getContextManager());
}
{
	columnNameList(resultColumns)
	{
		return resultColumns;
	}
}

/*
 * <A NAME="columnNameList">columnNameList</A>
 */
void
columnNameList(ResultColumnList columnList) throws StandardException :
{}
{
	columnNameItem(columnList) ( <COMMA> columnNameItem(columnList) ) *
}

/*
 * <A NAME="columnNameItem">columnNameItem</A>
 */
void
columnNameItem(ResultColumnList columnList) throws StandardException :
{
	String		columnName;
	ResultColumn	resultColumn;
}
{
	/* identifier() used to be columnName() */
	columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	{
		/*
		** Store the column names for the result columns in the
		** result column list.  We don't know yet what valueNodes
		** should be hooked up to each result column, so set that
		** to null for now.
		*/
		resultColumn = (ResultColumn) nodeFactory.getNode(
									C_NodeTypes.RESULT_COLUMN,
									columnName,
									null,
									getContextManager());
		columnList.addResultColumn(resultColumn);
	}
}

/*
 * <A NAME="indexColumnList">indexColumnList</A>
 */
// GemStone changes BEGIN
void
indexColumnList(Vector columnList, boolean globalHash) throws StandardException :
{}
{
	indexColumnItem(columnList, globalHash) ( <COMMA> indexColumnItem(columnList, globalHash) ) *
}
/*
void
indexColumnList(Vector columnList) throws StandardException :
{}
{
	indexColumnItem(columnList) ( <COMMA> indexColumnItem(columnList) ) *
}
*/
// GemStone changes END

/*
 * <A NAME="indexColumnItem">indexColumnItem</A>
 */
void
// GemStone changes BEGIN
indexColumnItem(Vector columnList, boolean globalHash) throws StandardException :
/* indexColumnItem(Vector columnList) throws StandardException : */
// GemStone changes END
{
	String		columnName;
}
{
	/* identifier never ends with a space; appending a space meaning desc */
// GemStone changes BEGIN
// GLOBAL HASH index does not allow ASC or DESC as keys are not ordered
	columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true) [<ASC>
			{ if (globalHash) throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, "ASC"); }
		| <DESC>
			{ if (globalHash) throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, "DESC");
			  else columnName = columnName + ' '; }]
	/* columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true) [<ASC> | <DESC> {columnName = columnName + ' ';}] */
// GemStone changes END
	{
		/*
		** Store the column names for the index columns in the
		** index column list.
		*/
		columnList.addElement(columnName);
	}
}


/*
 * <A NAME="derivedTable">derivedTable</A>
 */
ResultSetNode
derivedTable() throws StandardException :
{
	SubqueryNode tableSubquery;
}
{
	<LEFT_PAREN>
	tableSubquery = tableSubquery(SubqueryNode.FROM_SUBQUERY, null)
	<RIGHT_PAREN>
	{
		return tableSubquery.getResultSet();
	}
}

TableOperatorNode
joinedTableExpression(ResultSetNode leftRSN, boolean nestedInParens) throws StandardException :
{
	TableOperatorNode joinNode;
}
{
	joinNode = qualifiedJoin(leftRSN, nestedInParens) 
	{
		return joinNode;
	}
}

TableOperatorNode
qualifiedJoin(ResultSetNode leftRSN, boolean nestedInParens) throws StandardException :
{
	int					joinType = JoinNode.INNERJOIN;
	ResultSetNode		rightRSN;
	TableOperatorNode	ton = null;
	Object[]			onOrUsingClause = null;
	ResultColumnList	usingClause = null;
	ValueNode			onClause;
}
{
	/* RESOLVE - If we ever support NATURAL JOIN then we will need to break up
	 * this rule.  Right now the joinSpecification() is non-optional.  This
	 * allows us to build the Join tree from left to right. With NATURAL JOINS
	 * there is no joinSpecification() and we would want to build the tree from
	 * right to left.
	 */
	//[ <NATURAL> ] 
		[ joinType = joinType() ] <JOIN>
		rightRSN = tableReferenceTypes(nestedInParens) 
		onOrUsingClause = joinSpecification(leftRSN, rightRSN)
	{
		/* If NATURAL OR UNION is specified, then no joinSpecification()
		 * is required, otherwise it is required.
		 */

		/* RESOLVE - Since we don't support NATURAL or UNION joins yet,
		 * onOrUsingClause must be non-null.  (Change error message if and
		 * when grammar changes.)
		 */

		/* Figure out whether an ON or USING clause was used */
		onClause = (ValueNode) onOrUsingClause[ON_CLAUSE];
		usingClause = (ResultColumnList) onOrUsingClause[USING_CLAUSE];

		if (onClause == null && usingClause == null)
		{
			throw StandardException.newException(SQLState.LANG_MISSING_JOIN_SPECIFICATION, 
							JoinNode.joinTypeToString(joinType));
		}

		switch(joinType)
		{
			case JoinNode.INNERJOIN:
				ton = (TableOperatorNode) nodeFactory.getNode(
									C_NodeTypes.JOIN_NODE,
									leftRSN,
									rightRSN,
									onClause,
									usingClause,
									null,
									null,
									null,
									getContextManager());
				break;

			case JoinNode.LEFTOUTERJOIN:
				ton = (TableOperatorNode) nodeFactory.getNode(
										C_NodeTypes.HALF_OUTER_JOIN_NODE,
										leftRSN,
										rightRSN,
										onClause,
										usingClause,
										Boolean.FALSE,
										null,
										getContextManager());
				break;

			case JoinNode.RIGHTOUTERJOIN:
				ton = (TableOperatorNode) nodeFactory.getNode(
										C_NodeTypes.HALF_OUTER_JOIN_NODE,
										leftRSN,
										rightRSN,
										onClause,
										usingClause,
										Boolean.TRUE,
										null,
										getContextManager());
				break;


			default:
				if (SanityManager.DEBUG)
				{
					SanityManager.ASSERT(false, "Unexpected joinType");
				}
				return null;
		}

		/* Mark whether or not we are nested within parens */
		ton.setNestedInParens(nestedInParens);
		return ton;
	}
}

int
joinType() throws StandardException :
{
	int joinType;
}
{
	<INNER> 
	{
		return JoinNode.INNERJOIN;
	}
|
	joinType = outerJoinType() [<OUTER>]
	{
		return joinType;
	}
}

int
outerJoinType() throws StandardException :
{}
{
	<LEFT> 
	{
		return JoinNode.LEFTOUTERJOIN;
	}
|
	<RIGHT> 
	{
		return JoinNode.RIGHTOUTERJOIN;
	}
}

Object[]
joinSpecification(ResultSetNode leftRSN, ResultSetNode rightRSN) 
		throws StandardException :
{
	Object[]			onOrUsingClause = new Object[ON_OR_USING_CLAUSE_SIZE];
	ResultColumnList	usingClause = null;
	ValueNode			joinClause = null;
}
{
	joinClause = joinCondition() 
	{
		onOrUsingClause[ON_CLAUSE] = joinClause;
		onOrUsingClause[USING_CLAUSE] = usingClause;
		return onOrUsingClause;
	}
}

ValueNode
joinCondition() throws StandardException :
{
	ValueNode joinClause;
}
{
	/* valueExpression() was searchCondition() */
	<ON> joinClause = valueExpression(false)
	{
		return joinClause;
	}
}

/*
 * <A NAME="tableValueConstructor">tableValueConstructor</A>
 */
ResultSetNode
tableValueConstructor() throws StandardException :
{
	ResultSetNode	resultSetNode;
}
{
	<VALUES> resultSetNode = tableValueConstructorList()
	{
		return resultSetNode;
	}
}

/*
 * <A NAME="tableValueConstructorList">tableValueConstructorList</A>
 */
ResultSetNode
tableValueConstructorList() throws StandardException :
{
	ResultSetNode	resultSetNode;
}
{
	resultSetNode = rowValueConstructor(null) 
		( <COMMA> resultSetNode = rowValueConstructor(resultSetNode) ) *
	{
		if (resultSetNode instanceof UnionNode)
		{
			((UnionNode) resultSetNode).markTopTableConstructor();
		}

		return resultSetNode;
	}
}

/*
 * <A NAME="explicitTable">explicitTable</A>
 */

/*
 * <A NAME="datetimeValueFunction">datetimeValueFunction</A>
 */
ValueNode
datetimeValueFunction() throws StandardException :
{
	int prec = -1; // can't be negative, if used
}
{
	LOOKAHEAD({(getToken(1).kind == CURRENT && getToken(2).kind == DATE)}) <CURRENT> <DATE> 
	{
		return (ValueNode) nodeFactory.getNode(
								C_NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
								ReuseFactory.getInteger(
									CurrentDatetimeOperatorNode.CURRENT_DATE),
								getContextManager());
	}
	| <CURRENT_DATE>
	{
		return (ValueNode) nodeFactory.getNode(
								C_NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
								ReuseFactory.getInteger(
									CurrentDatetimeOperatorNode.CURRENT_DATE),
								getContextManager());
	}
|
	LOOKAHEAD({(getToken(1).kind == CURRENT && getToken(2).kind == TIME)}) <CURRENT> <TIME> 
	{
		return (ValueNode) nodeFactory.getNode(
							C_NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
							ReuseFactory.getInteger(
								CurrentDatetimeOperatorNode.CURRENT_TIME),
							getContextManager());
	}
	| <CURRENT_TIME> 
	{
		return (ValueNode) nodeFactory.getNode(
							C_NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
							ReuseFactory.getInteger(
								CurrentDatetimeOperatorNode.CURRENT_TIME),
							getContextManager());
	}
|
	LOOKAHEAD({(getToken(1).kind == CURRENT && getToken(2).kind == TIMESTAMP)}) <CURRENT> <TIMESTAMP> 
	{
		return (ValueNode) nodeFactory.getNode(
							C_NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
							ReuseFactory.getInteger(
								CurrentDatetimeOperatorNode.CURRENT_TIMESTAMP),
							getContextManager());
	}
	| <CURRENT_TIMESTAMP> 
	{
		return (ValueNode) nodeFactory.getNode(
							C_NodeTypes.CURRENT_DATETIME_OPERATOR_NODE,
							ReuseFactory.getInteger(
								CurrentDatetimeOperatorNode.CURRENT_TIMESTAMP),
							getContextManager());
	}
}

/*
** Note that set function and aggregate are used
** interchangeably in the parser.  The tree has
** aggregate nodes.
*/
ValueNode
aggregateNode() throws StandardException :
{
	ValueNode agg;
}
{
	<COUNT> <LEFT_PAREN>
	( <ASTERISK>
	{
			agg = (ValueNode) nodeFactory.getNode(
								C_NodeTypes.AGGREGATE_NODE,
								null,
								CountAggregateDefinition.class, 
								Boolean.FALSE,
                Boolean.TRUE, //isCountStar
								Boolean.FALSE,
								"COUNT(*)",
								getContextManager());
	}
	|
		agg = aggregateExpression("COUNT", CountAggregateDefinition.class)
	)
	<RIGHT_PAREN>
	{
		return agg;
	}
|
	agg = generalAggregate()
	{
		return agg;
	}
}



ValueNode
aggregateExpression(String aggName, Class aggClass) throws StandardException :
{
	boolean		distinct = false;
	ValueNode	value;
}
{
	[ distinct = setQuantifier() ] value = additiveExpression(null, 0, false)
	{
      //GemStone changes BEGIN
      // splitting AVG to SUM(expr)/COUNT(expr).
      
	   if(!"AVG".equals(aggName)) {
	   
      //GemStone changes END
	
             return (ValueNode) nodeFactory.getNode(
								C_NodeTypes.AGGREGATE_NODE,
								value,
								aggClass, 
								distinct ? Boolean.TRUE : Boolean.FALSE,
                Boolean.FALSE,
                Boolean.FALSE,
								aggName,
								getContextManager());
      //GemStone changes BEGIN
      
       }
       else {
           Token tmptoken = Token.newToken(SUM);
           tmptoken.kind = SUM;
           ValueNode sumnode = (ValueNode) nodeFactory.getNode(
                                                C_NodeTypes.AGGREGATE_NODE,
                                                value,
                                                aggClass(tmptoken), 
                                                distinct ? Boolean.TRUE : Boolean.FALSE,
                                                Boolean.FALSE,
                                                Boolean.TRUE,
                                                aggName(tmptoken),
                                                getContextManager());

           tmptoken.kind = COUNT;
           ValueNode countnode = (ValueNode) nodeFactory.getNode(
                                                C_NodeTypes.AGGREGATE_NODE,
                                                value,
                                                aggClass(tmptoken), 
                                                distinct ? Boolean.TRUE : Boolean.FALSE,
                                                Boolean.FALSE,
                                                Boolean.FALSE,
                                                aggName(tmptoken),
                                                 getContextManager());
           CompilerContext context = getCompilerContext();
           if(context.createQueryInfo())
           {
				ValueNode expr =  (ValueNode) nodeFactory.getNode(
                                C_NodeTypes.BINARY_DIVIDE_OPERATOR_NODE,
                                sumnode,
                                countnode,Boolean.TRUE,
                                getContextManager());
                                return expr;
           }else
           {
             
           
           ValueNode expr =  (ValueNode) nodeFactory.getNode(
                                C_NodeTypes.BINARY_DIVIDE_OPERATOR_NODE,
                                sumnode,
                                countnode,
                                getContextManager());
                                return expr;
         }        

       }
      //GemStone changes END
       
	}
}

ValueNode
generalAggregate() throws StandardException :
{
	Token			aggToken;
	String			methodAliasString;
	ValueNode	aggExpr;
	ValueNode		value;
}
{
	aggToken = builtInAggregateType()
	<LEFT_PAREN>
		aggExpr = aggregateExpression(aggName(aggToken), aggClass(aggToken))
	<RIGHT_PAREN>
	{
		return aggExpr;
	}
}

/*
** All built in aggregates are pretty similar to user
** defined aggregates, except we know what to map to
** without looking up the class name.
**
** NOTE: COUNT is omitted here because the COUNT aggregate is
** factored into a different rule, to distinguish between
** COUNT(*) and COUNT(<expression>).
*/
Token
builtInAggregateType() throws StandardException :
{
	Token	retval;
}
{
	(
		retval = <MAX> |
		retval = <AVG> |
		retval = <MIN> |
		retval = <SUM>
	)
	{
		return retval;
	}
}

ValueNode
castSpecification() throws StandardException :
{
	DataTypeDescriptor dts;
	ValueNode		 treeTop;
	ValueNode		 value;
	int				 charType;
	int				 length = -1;
}
{
    //GemStone changes BEGIN
    //inserting switchOptimizeLiteral
	//originally <CAST> <LEFT_PAREN> value = castOperand() <AS> dts = dataTypeCast() <RIGHT_PAREN>
	<CAST> 
	<LEFT_PAREN> 
	{boolean existing = getCompilerContext().switchOptimizeLiteral(false);}
	value = castOperand() <AS> dts = dataTypeCast() 
	<RIGHT_PAREN>
	{getCompilerContext().switchOptimizeLiteral(existing);}
    //GemStone changes END
	{
		treeTop = (ValueNode) nodeFactory.getNode(
									C_NodeTypes.CAST_NODE,
									value,
									dts,
									getContextManager());
		((CastNode) treeTop).setForExternallyGeneratedCASTnode();

		/* We need to generate a SQL->Java conversion tree above us if
		 * the dataTypeCast is a user type.
		 */
		if (dts.getTypeId().userType())
		{
			treeTop = (ValueNode) nodeFactory.getNode(
							C_NodeTypes.JAVA_TO_SQL_VALUE_NODE,
							nodeFactory.getNode(
											C_NodeTypes.SQL_TO_JAVA_VALUE_NODE,
											treeTop,
											getContextManager()),
							getContextManager());
		}

		return treeTop;
	}
		
}

/*
 * <A NAME="charOrVarchar">charOrVarchar</A>
 */
int
charOrVarchar() :
{
}
{
	<CHAR>
	{
		return Types.CHAR;
	}
|
	<VARCHAR>
	{
		return Types.VARCHAR;
	}
}

ValueNode
castOperand() throws StandardException :
{
	ValueNode value;
}
{
	value = additiveExpression(null, 0, false)
	{
		return value;
	}
|
	<NULL>
	{
		return (ValueNode) nodeFactory.getNode(
									C_NodeTypes.UNTYPED_NULL_CONSTANT_NODE,
									getContextManager());
	}
}


/*
 * <A NAME="dynamicParameterSpecification">dynamicParameterSpecification</A>
 */
ParameterNode
dynamicParameterSpecification() throws StandardException :
{}
{
	<QUESTION_MARK>
	{
		return makeParameterNode( );
	}
}

/*
 * <A NAME="whereClause">whereClause</A>
 */
ValueNode
whereClause(Token beginToken) throws StandardException :
{
	ValueNode	value;
	Token		endToken;
}
{
	/* valueExpression() was searchCondition() */
	value = valueExpression(false)
	{
		endToken = getToken(0);

		value.setBeginOffset( beginToken.endOffset + 1 );
		value.setEndOffset( endToken.endOffset );

		return value;
	}
}

GroupByList
groupByClause() throws StandardException :
{
	GroupByList groupingCols;
}
{
	<GROUP> <BY> groupingCols = groupingColumnReferenceList()
	{
		return groupingCols;
	}
}

GroupByList
groupingColumnReferenceList() throws StandardException :
{
  // GemStone changes BEGIN
  // disable constants in order by clauses.
  boolean existing = getCompilerContext().switchOptimizeLiteral(false);
  // GemStone changes END
	GroupByList groupingCols = (GroupByList) nodeFactory.getNode(
									C_NodeTypes.GROUP_BY_LIST,
									getContextManager());
}
{
	groupingColumnReference(groupingCols) ( <COMMA> groupingColumnReference(groupingCols) ) *
	{
    // GemStone changes BEGIN
    getCompilerContext().switchOptimizeLiteral(existing);
    // GemStone changes END
		return groupingCols;
	}
}

void
groupingColumnReference(GroupByList groupingCols) throws StandardException :
{
        ValueNode columnExpression;
}
{
	columnExpression = additiveExpression(null, 0, false)
	{
		if (columnExpression.isParameterNode()) 
	    	{
			throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, "?");
	    	}
		if (columnExpression instanceof AggregateNode)
		{
			AggregateNode agNode = (AggregateNode)columnExpression;
			throw StandardException.newException(
				SQLState.LANG_AGGREGATE_IN_GROUPBY_LIST, 
				agNode.getAggregateName());
		}        
		groupingCols.addGroupByColumn(
			(GroupByColumn) nodeFactory.getNode(
							C_NodeTypes.GROUP_BY_COLUMN,
							columnExpression,
							getContextManager()));
	}
}

ValueNode
havingClause() throws StandardException :
{
	ValueNode value;
}
{
	/* valueExpression() was searchCondition() */
	<HAVING> value = valueExpression(false)
	{
		return value;
	}
}

StatementNode
schemaDefinition() throws StandardException :
{
	String	schemaName = null;
// GemStone changes BEGIN
	ServerGroupsTableAttribute defaultServerGroups =
		new ServerGroupsTableAttribute();
// GemStone changes END
	String	authName = null;
	String	groupName = null;
}
{
	/*
	** CREATE SCHEMA:
	** We are not currently handling character set
	** specifications for schema, or schema bodies.
	*/
	<SCHEMA>
	( schemaName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	    [ <AUTHORIZATION> [ <LDAPGROUP> <COLON> groupName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
			| authName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true) ] ]
// GemStone changes BEGIN
			[ <_DEFAULT> serverGroupDefinition(defaultServerGroups) ]
// GemStone change END
		{
			if (authName != null || groupName != null)
				checkVersion( DataDictionary.DD_VERSION_DERBY_10_2, "AUTHORIZATION");

			if (schemaName.startsWith("SYS"))
				throw StandardException.newException(SQLState.INVALID_SCHEMA_SYS, schemaName);
 
			if (groupName != null)
				authName = Constants.LDAP_GROUP_PREFIX + groupName;

			return (StatementNode) nodeFactory.getNode(
					C_NodeTypes.CREATE_SCHEMA_NODE,
					schemaName,
					authName,
					defaultServerGroups, // GemStone addition
					getContextManager()
					);
		}
	|
		<AUTHORIZATION> authName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true) 
// GemStone changes BEGIN
            [ <_DEFAULT> serverGroupDefinition(defaultServerGroups) ]
// GemStone change END
		{
			checkVersion( DataDictionary.DD_VERSION_DERBY_10_2, "AUTHORIZATION");
			if (authName.startsWith("SYS"))
				throw StandardException.newException(SQLState.INVALID_SCHEMA_SYS, authName);

			return (StatementNode) nodeFactory.getNode(
					C_NodeTypes.CREATE_SCHEMA_NODE,
					authName,
					authName,
                    defaultServerGroups, // GemStone addition
					getContextManager()
					);
		}
	)
}


/*
 * <A NAME="roleDefinition">roleDefinition</A>
 */
StatementNode
roleDefinition() throws StandardException :
{
	String	roleName = null;
}
{
	/*
	 * CREATE ROLE
	 *
	 * Not currently supported: [ WITH ADMIN <grantor>]
	 */
	<ROLE> roleName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	{
		throw StandardException.newException
            (SQLState.NOT_IMPLEMENTED, "ROLES");
		checkVersion( DataDictionary.DD_VERSION_DERBY_10_4, "ROLES");
		checkSqlStandardAccess("CREATE ROLE");

		// Reserve namespace for system roles
		if (roleName.startsWith("SYS")) {
			throw StandardException.newException
                            (SQLState.INVALID_ROLE_SYS, roleName);
                }

		return (StatementNode) nodeFactory.getNode(
			C_NodeTypes.CREATE_ROLE_NODE,
			roleName,
			getContextManager());
	}
}


/*
 * <A NAME="tableDefinition">tableDefinition</A>
 */
StatementNode
tableDefinition() throws StandardException :
{
	char				lockGranularity = TableDescriptor.DEFAULT_LOCK_GRANULARITY;
	Properties			properties = null;
	TableName			tableName;
	TableElementList	tableElementList;
	ResultColumnList	resultColumns = null;
	ResultSetNode		queryExpression;
	Token asClauseToken, withDataToken, columnListToken = null;
	boolean				withData = true;
	// GemStone changes BEGIN
    AttributesFactory afact = new AttributesFactory();
    PartitionAttributesFactory pafact = new PartitionAttributesFactory();
    boolean isReplicate = false;
    boolean isQueryExpressionCase = false;
    ServerGroupsTableAttribute serverGroups = new ServerGroupsTableAttribute();
    InitSizeTableAttribute initSize = null;
    // index 0 = replicated or not, index 1 = partitioned or not,
    // index 2 Persistent or not and index 3 = normal/local
    // index 4 = eviction attributes set or not
    // index 5 = HDFS store set or not
    // index 6 = whether EVICTION BY CRITERIA has been set
    // index 7 = whether to disable concurrency checks or not
    boolean[] repPartPersFlags = new boolean[] { false, false, false, false,
        false, false, false , false };
    DistributionDefinitionNode distributionNode =
        (DistributionDefinitionNode) nodeFactory.getNode(C_NodeTypes.DISTRIBUTION_DEFINTION_NODE,
                                                         Integer.valueOf(DistributionDescriptor.NONE),
                                                         getContextManager());
     CompilerContext cc = getCompilerContext();
    // GemStone changes END 
}
{
	<TABLE> tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
		{
  	  cc.setForcedDDLrouting(true);
  	}
			// Lookahead needed to choose between
			// tableElementList and tableColumnList
	(		LOOKAHEAD({getToken(1).kind == LEFT_PAREN && 
	                   getToken(3).kind != COMMA &&
	                   getToken(3).kind != RIGHT_PAREN})
			tableElementList = tableElementList()
			
			// GemStone changes BEGIN
			
            fabricTableAttributes(afact, pafact, serverGroups, initSize,
              repPartPersFlags, tableName, distributionNode)
            // GemStone changes END 
			
			[ properties = propertyList(false)<CHECK_PROPERTIES>]
			{
				// GemStone changes BEGIN
				tableElementList.addTableElement(distributionNode);
				if (properties == null) {
		          properties = new Properties();
	            }
				setGFAttributes(properties,
	                           afact,
	                           pafact,
	                           distributionNode,
	                           repPartPersFlags,
	                           isQueryExpressionCase,
	                           tableName,
	                           serverGroups,
	                           initSize);
				// GemStone changes END
				return (StatementNode) nodeFactory.getNode(
										C_NodeTypes.CREATE_TABLE_NODE,
										tableName,
										tableElementList,
										properties,
// GemStone changes BEGIN
										// changed to use valueOf()
										Character.valueOf(lockGranularity),
// GemStone changes END
										getContextManager());
			}
		|
			[ columnListToken = <LEFT_PAREN> resultColumns = tableColumnList() <RIGHT_PAREN> ]
			asClauseToken = <AS>
			queryExpression = queryExpression(null, NO_SET_OP)
			<WITH> [ <NO> { withData = false; } ] withDataToken = <DATA> 
			{
				// Raise error if WITH DATA is specified
				// (until it is implemented)
				if (withData) {
					throw StandardException.newException(
						SQLState.NOT_IMPLEMENTED, "WITH DATA");
				}
				/* Parameters not allowed in create table */
				HasNodeVisitor visitor =
					new HasNodeVisitor(ParameterNode.class);
				queryExpression.accept(visitor);
				if (visitor.hasNode())
				{
					throw StandardException.newException(
						SQLState.LANG_NO_PARAMS_IN_TABLES);
				}
				// GemStone changes BEGIN
//			if (queryExpression instanceof SelectNode)
//			{
//			  throw StandardException.newException(SQLState.NOT_IMPLEMENTED,
//                "create table as query expression not supported yet");
//			}
            fabricTableAttributes(afact, pafact, serverGroups, initSize,
              repPartPersFlags, tableName, distributionNode);
              if (properties == null) {
		          properties = new Properties();
	            }
				setGFAttributes(properties,
	                           afact,
	                           pafact,
	                           distributionNode,
	                           repPartPersFlags,
	                           isQueryExpressionCase,
	                           tableName,
	                           serverGroups,
	                           initSize);
	            queryExpression.setDistributionDefinition(distributionNode);

            // GemStone changes END
                int textToBeReplacedBegin;
                if (columnListToken != null) {
                  textToBeReplacedBegin = columnListToken.beginOffset;
                }  else {
                  textToBeReplacedBegin = asClauseToken.beginOffset;
                }
				return (StatementNode) nodeFactory.getNode(
										C_NodeTypes.CREATE_TABLE_NODE,
										tableName,
										resultColumns,
										queryExpression,
										textToBeReplacedBegin,
										withDataToken.endOffset,
										statementSQLText,
										getContextManager());
			}
	)
}
// GemStone changes BEGIN ---

StatementNode gatewaySenderDefinition() throws StandardException :
{
	String id = null;
    Integer remoteDsId = null;
    Map attrs = new HashMap();
    ServerGroupsTableAttribute serverGroups = new ServerGroupsTableAttribute();
}
{
    
   <GATEWAYSENDER> id = identifier(Limits.MAX_IDENTIFIER_LENGTH,true)
   {
      CompilerContext cc = getCompilerContext();
      cc.markAsDDLForSnappyUse(false);
      cc.setForcedDDLrouting(false);
   }
   <LEFT_PAREN>
   <REMOTEDSID > remoteDsId = simpleValueSpecification_int()
    (  populateGatewaySenderAttributes(attrs))*
 	<RIGHT_PAREN>
 	serverGroupDefinition(serverGroups)
	{
	return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.CREATE_GATEWAY_SENDER_NODE,
								id, 
								remoteDsId,
								serverGroups,
                                attrs,
								getContextManager());
 }					
	    
}
 void populateGatewaySenderAttributes(Map attrs) throws StandardException :
{

}
{
     <SOCKETBUFFERSIZE > 
     {
       addToMapAllowOnce(attrs, CreateGatewaySenderNode.SOCKETBUFFERSIZE, simpleValueSpecification_int());
     }
|   <MANUALSTART>( <TRUE>{ addToMapAllowOnce(attrs,CreateGatewaySenderNode.MANUALSTART, Boolean.TRUE); }| <FALSE>{ addToMapAllowOnce(attrs,CreateGatewaySenderNode.MANUALSTART, Boolean.FALSE); })
|   <SOCKETREADTIMEOUT>{  addToMapAllowOnce(attrs,CreateGatewaySenderNode.SOCKETREADTIMEOUT, simpleValueSpecification_int());}
|   <ENABLEBATCHCONFLATION>( <TRUE>{ addToMapAllowOnce(attrs,CreateGatewaySenderNode.ENABLEBATCHCONFLATION, Boolean.TRUE); }| <FALSE>{ addToMapAllowOnce(attrs,CreateGatewaySenderNode.ENABLEBATCHCONFLATION, Boolean.FALSE); })
|   <BATCHSIZE> {  addToMapAllowOnce(attrs,CreateGatewaySenderNode.BATCHSIZE, simpleValueSpecification_int());}
|   <BATCHTIMEINTERVAL> {  addToMapAllowOnce(attrs,CreateGatewaySenderNode.BATCHTIMEINTERVAL, simpleValueSpecification_int());}
|   <ENABLEPERSISTENCE>( <TRUE>{ addToMapAllowOnce(attrs,CreateGatewaySenderNode.ENABLEPERSISTENCE, Boolean.TRUE); }| <FALSE>{ addToMapAllowOnce(attrs,CreateGatewaySenderNode.ENABLEPERSISTENCE, Boolean.FALSE); })
|   <DISKSYNCHRONOUS>( <TRUE>{ addToMapAllowOnce(attrs,CreateGatewaySenderNode.DISKSYNCHRONOUS, Boolean.TRUE); }| <FALSE>{ addToMapAllowOnce(attrs,CreateGatewaySenderNode.DISKSYNCHRONOUS, Boolean.FALSE); })
|   <DISKSTORENAME > {  addToMapAllowOnce(attrs,CreateGatewaySenderNode.DISKSTORENAME, identifier(Limits.MAX_IDENTIFIER_LENGTH,true));}
|   <MAXQUEUEMEMORY> {  addToMapAllowOnce(attrs,CreateGatewaySenderNode.MAXQUEUEMEMORY, simpleValueSpecification_int());}
|   <ALERTTHRESHOLD> {  addToMapAllowOnce(attrs,CreateGatewaySenderNode.ALERTTHRESHOLD, simpleValueSpecification_int());}
|   <ISPARALLEL>( <TRUE>{ addToMapAllowOnce(attrs,CreateGatewaySenderNode.ISPARALLEL, Boolean.TRUE); }| <FALSE>{ addToMapAllowOnce(attrs,CreateGatewaySenderNode.ISPARALLEL, Boolean.FALSE); })
}


StatementNode asyncEventListenerDefinition() throws StandardException :
{
	String id = null;
    Map attrs = new HashMap();
    String listenerClass = null ;
    String initParams = null;
    ServerGroupsTableAttribute serverGroups = new ServerGroupsTableAttribute();
}
{
    
   <ASYNCLISTENER> id = identifier(Limits.MAX_IDENTIFIER_LENGTH,true)
   {
      CompilerContext cc = getCompilerContext();
      cc.markAsDDLForSnappyUse(false);
      cc.setForcedDDLrouting(false);
   }
   <LEFT_PAREN>
   <LISTENERCLASS>  listenerClass = string()
   <INITPARAMS>  initParams = string()   
    (  populateAsyncEventListenerAttributes(attrs))*
    
 	<RIGHT_PAREN>
 	serverGroupDefinition(serverGroups)
	{
	return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.CREATE_ASYNC_EVENT_LISTENER_NODE,
								id,
								listenerClass,
								initParams,
								serverGroups,
                                attrs,
								getContextManager());
 }					
	    
}

 void populateAsyncEventListenerAttributes(Map attrs) throws StandardException :
{

}
{
    <MANUALSTART>( <TRUE>{ addToMapAllowOnce(attrs,CreateGatewaySenderNode.MANUALSTART, Boolean.TRUE); }| <FALSE>{ addToMapAllowOnce(attrs,CreateGatewaySenderNode.MANUALSTART, Boolean.FALSE); })
|   <ENABLEBATCHCONFLATION>( <TRUE>{ addToMapAllowOnce(attrs,CreateGatewaySenderNode.ENABLEBATCHCONFLATION, Boolean.TRUE); }| <FALSE>{ addToMapAllowOnce(attrs,CreateGatewaySenderNode.ENABLEBATCHCONFLATION, Boolean.FALSE); })
|   <BATCHSIZE> {  addToMapAllowOnce(attrs,CreateGatewaySenderNode.BATCHSIZE, simpleValueSpecification_int());}
|   <BATCHTIMEINTERVAL> {  addToMapAllowOnce(attrs,CreateGatewaySenderNode.BATCHTIMEINTERVAL, simpleValueSpecification_int());}
|   <ENABLEPERSISTENCE>( <TRUE>{ addToMapAllowOnce(attrs,CreateGatewaySenderNode.ENABLEPERSISTENCE, Boolean.TRUE); }| <FALSE>{ addToMapAllowOnce(attrs,CreateGatewaySenderNode.ENABLEPERSISTENCE, Boolean.FALSE); })
|   <DISKSYNCHRONOUS>( <TRUE>{ addToMapAllowOnce(attrs,CreateGatewaySenderNode.DISKSYNCHRONOUS, Boolean.TRUE); }| <FALSE>{ addToMapAllowOnce(attrs,CreateGatewaySenderNode.DISKSYNCHRONOUS, Boolean.FALSE); })
|   <DISKSTORENAME > {  addToMapAllowOnce(attrs,CreateGatewaySenderNode.DISKSTORENAME, identifier(Limits.MAX_IDENTIFIER_LENGTH,true));}
|   <MAXQUEUEMEMORY> {  addToMapAllowOnce(attrs,CreateGatewaySenderNode.MAXQUEUEMEMORY, simpleValueSpecification_int());}
|   <ALERTTHRESHOLD> {  addToMapAllowOnce(attrs,CreateGatewaySenderNode.ALERTTHRESHOLD, simpleValueSpecification_int());}
|   <ISPARALLEL>( <TRUE>{ addToMapAllowOnce(attrs,CreateGatewaySenderNode.ISPARALLEL, Boolean.TRUE); }| <FALSE>{ addToMapAllowOnce(attrs,CreateGatewaySenderNode.ISPARALLEL, Boolean.FALSE); })
}


StatementNode dropAsyncEventListenerStatement() throws StandardException :
{
	String id = null;
// GemStone changes BEGIN
	Boolean onlyIfExists = Boolean.FALSE;
// GemStone changes END
}
{
    
   <ASYNCLISTENER>
// GemStone changes BEGIN
{
   CompilerContext cc = getCompilerContext();
   cc.markAsDDLForSnappyUse(false);
   cc.setForcedDDLrouting(false);
}
	[ <IF> <EXISTS> { onlyIfExists = Boolean.TRUE; } ]
// GemStone changes END
   id = identifier(Limits.MAX_IDENTIFIER_LENGTH,true)
  {
	return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.DROP_ASYNC_EVENT_LISTENER_NODE,
								id,
// GemStone changes BEGIN								
								onlyIfExists,
// GemStone changes END								
								getContextManager());
  }
 				
	    
}

StatementNode dropGatewaySenderStatement() throws StandardException :
{
	String id = null;
// GemStone changes BEGIN
	Boolean onlyIfExists = Boolean.FALSE;
// GemStone changes END
}
{
    
   <GATEWAYSENDER>
// GemStone changes BEGIN
{
   CompilerContext cc = getCompilerContext();
   cc.markAsDDLForSnappyUse(false);
   cc.setForcedDDLrouting(false);
}
	[ <IF> <EXISTS> { onlyIfExists = Boolean.TRUE; } ]
// GemStone changes END
   
   id = identifier(Limits.MAX_IDENTIFIER_LENGTH,true)
  {
	return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.DROP_GATEWAY_SENDER_NODE,
								id,
// GemStone changes BEGIN								
								onlyIfExists,
// GemStone changes END								
								getContextManager());
  }
 				
	    
}

StatementNode dropGatewayReceiverStatement() throws StandardException :
{
	String id  = null;
// GemStone changes BEGIN
{
   CompilerContext cc = getCompilerContext();
   cc.markAsDDLForSnappyUse(false);
   cc.setForcedDDLrouting(false);
}
	Boolean onlyIfExists = Boolean.FALSE;
// GemStone changes END
}
{
    
   <GATEWAYRECEIVER>
// GemStone changes BEGIN
	[ <IF> <EXISTS> { onlyIfExists = Boolean.TRUE; } ]
// GemStone changes END
   
   id = identifier(Limits.MAX_IDENTIFIER_LENGTH,true) 
  {
	return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.DROP_GATEWAY_RECEIVER_NODE,
								id,
// GemStone changes BEGIN								
								onlyIfExists,
// GemStone changes END								
								getContextManager());
  }
 				
	    
}
StatementNode 
gatewayReceiverDefinition() throws StandardException :
{
	Map attrs = new HashMap();
	ServerGroupsTableAttribute serverGroups = new ServerGroupsTableAttribute();
	String id  = null;
}
{
	<GATEWAYRECEIVER> id = identifier(Limits.MAX_IDENTIFIER_LENGTH,true)
	{
       CompilerContext cc = getCompilerContext();
       cc.markAsDDLForSnappyUse(false);
       cc.setForcedDDLrouting(false);
    }
	[ <LEFT_PAREN>
     ( populateGatewarReceiverAttributes(attrs) )*
	 <RIGHT_PAREN>
	]
	[ serverGroupDefinition(serverGroups) ] 
	{
		return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.CREATE_GATEWAY_RECEIVER_NODE,
								attrs,id, serverGroups,
								getContextManager());
	}
}
void populateGatewarReceiverAttributes(Map attrs) throws StandardException :
{

}
{
  <STARTPORT> {  addToMapAllowOnce(attrs,CreateGatewayReceiverNode.STARTPORT, simpleValueSpecification_int());}
| <ENDPORT> {  addToMapAllowOnce(attrs,CreateGatewayReceiverNode.ENDPORT, simpleValueSpecification_int());}
| <SOCKETBUFFERSIZE > { addToMapAllowOnce(attrs,CreateGatewayReceiverNode.SOCKETBUFFERSIZE, simpleValueSpecification_int());}
| <MAXTIMEBETWEENPINGS> { addToMapAllowOnce(attrs,CreateGatewayReceiverNode.MAXTIMEBETWEENPINGS, simpleValueSpecification_int());}
| <BINDADDRESS> {  addToMapAllowOnce(attrs,CreateGatewayReceiverNode.BINDADDRESS, stringLiteral().getString());}
| <HOSTNAMEFORSENDERS> {  addToMapAllowOnce(attrs,CreateGatewayReceiverNode.HOSTNAMEFORSENDERS, stringLiteral().getString());}
}

StatementNode
hdfsStoreDefinition() throws StandardException :
{
       String hdfsStoreName = null;
       String nameNode = null;
       String homeDir = null;
       Map otherAttribs = new HashMap();
       CharConstantNode strNode = null;
 }
{
       <HDFSSTORE> hdfsStoreName = identifier(Limits.MAX_IDENTIFIER_LENGTH,true)
       <NAMENODE> (strNode = stringLiteral())

       { 
        if (strNode != null)
        {
           nameNode = strNode.getString();
        }
       }
       
       (populateHDFSAttributes(otherAttribs))*
       
       {
               return (StatementNode) nodeFactory.getNode(
                                                               C_NodeTypes.CREATE_HDFS_STORE_NODE,
                                                               hdfsStoreName,
                                                               nameNode,
                                                               otherAttribs,
                                                               getContextManager());
       }
}

void 
populateHDFSAttributes(Map otherAttribs ) throws StandardException :
{
	Token tok;
	ValueNode val;
	Token bool ;
	String name = null;
	CharConstantNode strNode = null;
	String str = null;
	BigDecimal interval = new BigDecimal("1");
}
{  
   (	      
	  (
	     tok= <BATCHSIZE>
		 | tok = <DISPATCHERTHREADS>
     	 | tok = <MAXQUEUEMEMORY>
    	 | tok = <MAXINPUTFILESIZE>
    	 | tok = <MININPUTFILECOUNT>
    	 | tok = <MAXINPUTFILECOUNT>
    	 | tok = <MINORCOMPACTIONTHREADS>
    	 | tok = <MAJORCOMPACTIONTHREADS> 
    	 | tok = <BLOCKCACHESIZE>   
    	 | tok = <MAXWRITEONLYFILESIZE>
   	  )
      val = intLiteral()
	  {
	     if (getIntValue(val) < 0)
	     {
	        throw StandardException.newException(SQLState.LANG_INVALID_COLUMN_LENGTH,
                "Value " + getIntValue(val) + " is negative");
	     }
	     addToMapAllowOnce(otherAttribs, tok.image, val);
	  }
   )  
   |
   (
      (
         tok = <MAJORCOMPACTIONINTERVAL>
         | tok = <PURGEINTERVAL>
      )
      val = getIntervalInMins()
      {
         if (getIntValue(val) < 1)
         {
            throw StandardException.newException(SQLState.LANG_INVALID_COLUMN_LENGTH,
               "Value in minutes " + getIntValue(val) + " is less than 1");
         }
         addToMapAllowOnce(otherAttribs, tok.image, val);
      }
   )
   |
   (
      (
         tok = <WRITEONLYFILEROLLOVERINTERVAL>
      )   
      val = getIntervalInSecs()
     {
         if (getIntValue(val) < 1)
         {
            throw StandardException.newException(SQLState.LANG_INVALID_COLUMN_LENGTH,
               "Value in seconds " + getIntValue(val) + " is less than 1");
         }
         addToMapAllowOnce(otherAttribs, tok.image, val);
      }
   )
   |
   (
      (
         tok = <BATCHTIMEINTERVAL>
      )   
      val = getIntervalInMillis()
     {
         if (getIntValue(val) < 1)
         {
            throw StandardException.newException(SQLState.LANG_INVALID_COLUMN_LENGTH,
               "Value in milliseconds " + getIntValue(val) + " is less than 1");
         }
         addToMapAllowOnce(otherAttribs, tok.image, val);
      }
   )
   |
   (
      (
	     tok = <QUEUEPERSISTENT>
	     | tok = <DISKSYNCHRONOUS>
		 | tok = <MINORCOMPACT>
		 | tok = <MAJORCOMPACT>
      )   
      bool = booleanLiteral()
	  {
	     addToMapAllowOnce(otherAttribs, tok.image, bool.image);
	  }
   )
   |
   (
   	  (tok = <DISKSTORENAME>)
   	  name = identifier(Limits.MAX_IDENTIFIER_LENGTH,true)
	  {
	     addToMapAllowOnce(otherAttribs, tok.image, name);
	  }
   )
   |
   (
   	  (
   	     tok = <HOMEDIR>
   	     | tok = <CLIENTCONFIGFILE>
   	  )
   	  strNode = stringLiteral()
   	  { 
         if (strNode != null)
         {
            str = strNode.getString();
            addToMapAllowOnce(otherAttribs, tok.image, str);
         }
      }
   )     
}
  		
/*
 * <A NAME="diskStoreDefinition">diskStoreDefinition</A>
 */
StatementNode
diskStoreDefinition() throws StandardException :
{
	String diskStoreName;
	List<String> dirPaths  = new ArrayList<String >();
	List<Integer> dirSizes  = new ArrayList<Integer >();
	Map otherAttribs = new HashMap();

 
}

{
    
	<DISKSTORE> diskStoreName = identifier(Limits.MAX_IDENTIFIER_LENGTH,true)
	
	 (  populateDiskAttributes(dirPaths,dirSizes, otherAttribs))*
	
			 	
	
	{
		return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.CREATE_DISK_STORE_NODE,
								diskStoreName, 
								dirPaths,
								dirSizes,
								otherAttribs,getContextManager());
	
	}
    

}  			





void populateDiskAttributes(List<String> dirPaths, List<Integer> dirSizes,
       Map otherAttribs ) throws StandardException :
{
}
{
  (
    diskStoreAttribs(otherAttribs)
    |
    (
      (
        
       <LEFT_PAREN> dirPathsAndSizes(dirPaths, dirSizes)
       (<COMMA> dirPathsAndSizes(dirPaths, dirSizes))*
       <RIGHT_PAREN>
     )
     | 
         dirPathsAndSizes(dirPaths, dirSizes)
    )     
  )
}
void
dirPathsAndSizes(List<String> dirlist, List<Integer> dirSizes) throws StandardException :
{
	int val = -1;
	String dirname;
	File file;
	CharConstantNode strNode = null;
}
{
	 strNode = stringLiteral()	   
	    {
	        dirname = strNode.getString();
	        // If string is zero-length, throw exception
	        if (dirname.length() == 0)
	        {
  			  throw StandardException.newException(SQLState.NOT_IMPLEMENTED,
                  "Directory name is invalid");
	        }
	    }
	    
	    [  val = simpleValueSpecification_int()  ]
	    
	    {
	    	if (val == 0)
	    	{
	    		throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR,
	    	    	"Directory size should be greater than zero");
	    	}
	    }
	   
	    {
	      dirlist.add(dirname);
	  	  dirSizes.add(Integer.valueOf(val));
	    }
}

StatementNode 
dropHDFSStoreStatement() throws StandardException :
{
	String id  = null;
	Boolean onlyIfExists = Boolean.FALSE;
}
{
    
   <HDFSSTORE>

	[ <IF> <EXISTS> { onlyIfExists = Boolean.TRUE; } ]

   id = identifier(Limits.MAX_IDENTIFIER_LENGTH,true) 
  {
	return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.DROP_HDFS_STORE_NODE,
								id,							
								onlyIfExists,						
								getContextManager());
  }
	    
}

StatementNode dropDiskStoreStatement() throws StandardException :
{
	String id  = null;
// GemStone changes BEGIN
	Boolean onlyIfExists = Boolean.FALSE;
// GemStone changes END
}
{
    
   <DISKSTORE>
// GemStone changes BEGIN
	[ <IF> <EXISTS> { onlyIfExists = Boolean.TRUE; } ]
// GemStone changes END
   id = identifier(Limits.MAX_IDENTIFIER_LENGTH,true) 
  {
	return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.DROP_DISK_STORE_NODE,
								id,
// GemStone changes BEGIN								
								onlyIfExists,
// GemStone changes END								
								getContextManager());
  }
	    
}
void
fabricTableAttributes(AttributesFactory afact,
    PartitionAttributesFactory pafact,
    ServerGroupsTableAttribute serverGroups,
    InitSizeTableAttribute initSize, boolean[] repPartPersFlags,
    TableName tableName,
    DistributionDefinitionNode distributionNode)
        throws StandardException :
{
}
{
	(
	  fabricTableAttribute(afact, pafact, serverGroups, 
	       initSize, repPartPersFlags, tableName, distributionNode)
	)*
	
}

void
fabricTableAttribute(AttributesFactory afact,
    PartitionAttributesFactory pafact,
    ServerGroupsTableAttribute serverGroups, InitSizeTableAttribute initSize,
    boolean[] repPartPersFlags, TableName tableName, 
    DistributionDefinitionNode distributionNode) throws StandardException :
{
                                                               
}
{
	(
	regionTypeDefinition(afact, pafact, repPartPersFlags, tableName, distributionNode)
|
  tableEncoderDefinition(distributionNode, tableName)
|
    serverGroupDefinition(serverGroups)
|
    initSizeDefinition(initSize)
//|
    //loaderDefinition(afact, tableName)
|
(
  <EVICTION> <BY>
  (
    evictionDefinition(afact, repPartPersFlags)
  |
    customEvictionDefinition(afact, repPartPersFlags)
  )
)
|
    expirationDefinition(afact)
|
    persistenceDiskDefinition(afact, repPartPersFlags)
|
	persistenceHDFSDefinition(afact, repPartPersFlags)    
|   
    gatewaySenderRegionDefinition(afact)
|
    concurrencyLevelDefinition(afact)
|
	memScaleDefinition(afact)
|
    concurrencyChecksDefinition(afact , repPartPersFlags)
   )
}

void
regionTypeDefinition(AttributesFactory afact,
    PartitionAttributesFactory pafact, boolean[] repPartPersFlags,
    TableName tableName, DistributionDefinitionNode distributionNode)
    throws StandardException :
{
}
{
	(
	partitionClauseAndColocationDefinition(afact, pafact, repPartPersFlags,
	  tableName, distributionNode)
|
    replicatedDefinition(repPartPersFlags, distributionNode)
    )
|   <LOCAL>
    {
      repPartPersFlags[3] = true;
      distributionNode.setPolicy(DistributionDescriptor.LOCAL);
    }
}

void tableEncoderDefinition(DistributionDefinitionNode distributionNode,
    TableName tableName) throws StandardException :
{
  String encoderClassName;
}
{
  <ENCODER> encoderClassName = string()
  {
    distributionNode.setRowEncoderClass(encoderClassName);
  }
}

void
replicatedDefinition(boolean[] repPartPersFlags, 
         DistributionDefinitionNode distributionNode) throws StandardException :
{
}
{
	<REPLICATE>
	{
		repPartPersFlags[0] = true;
		distributionNode.setPolicy(DistributionDescriptor.REPLICATE);
	}
}

void 
partitionClauseAndColocationDefinition(AttributesFactory afact,
    PartitionAttributesFactory pafact, boolean[] repPartPersFlags,
    TableName tableName, DistributionDefinitionNode distributionNode)
    throws StandardException :
{
	PartitionResolver prslvr = null;
	TableName colocatedTable = null;
}
{
  (
    prslvr = partitioningClause(distributionNode, tableName, repPartPersFlags)
    (
      colocatedTable = otherTablesColocationDefinition(distributionNode)
      {
        if (colocatedTable != null) {
          String tablePath = colocatedTable.getFullTableNameAsRegionPath();
          // check that colocated table should be partitioned too
          final Region<?, ?> masterRegion = Misc.getGemFireCache()
              .getRegionByPath(tablePath, false);
          if (masterRegion == null) {
            throw StandardException.newException(SQLState.LANG_TABLE_NOT_FOUND,
                colocatedTable.getFullTableName());
          }
          else if (!masterRegion.getAttributes().getDataPolicy().withPartitioning()) {
            throw StandardException.newException(SQLState.TABLE_NOT_PARTITIONED,
                colocatedTable.toString(), "colocation with '"
                + tableName.toString() + "'");
          }
    	  pafact.setColocatedWith(tablePath);
          if (prslvr instanceof GfxdPartitionResolver) {
            ((GfxdPartitionResolver)prslvr).setMasterTable(tablePath);
          }
        }
      }
    )?
    {
      pafact.setPartitionResolver(prslvr);
    }
  )
|
  (
    redundancyAndMaxPartSizeDefinition(pafact, distributionNode)
  )+
  {
    afact.setDataPolicy(DataPolicy.PARTITION);
  }
}



PartitionResolver 
partitioningClause(DistributionDefinitionNode distributionNode,
    TableName tableName, boolean[] repPartPersFlags) throws StandardException :
{
	PartitionResolver tmpprslvr = null;
	String resolverClass;
}
{
	<PARTITION> <BY>

    (
           <SPARKHASH>
           {
               distributionNode.setCustomHashing(true);
            }
    )?

	(

	<RANGE>	tmpprslvr = partitionRangeDefinition(distributionNode)
    |
    <LIST>  tmpprslvr = partitionListDefinition(distributionNode)
    |
    tmpprslvr = partitionPKeyOrColumnDefinition(distributionNode)
    |
    tmpprslvr = partitionExpressionDefinition(distributionNode)
    )
    {
        if (repPartPersFlags[1] == true)
        {
          // We already have a partition by clause, throw error
          throw StandardException.newException(SQLState.LANG_DUPLICATE_PROPERTY, "partitioning clause");
        }
    	repPartPersFlags[1] = true;
    	return tmpprslvr;
    }
|
    <PARTITIONER> resolverClass = string()
    {
      if (repPartPersFlags[1]) {
        // We already have a partition by clause, throw error
        throw StandardException.newException(SQLState.LANG_DUPLICATE_PROPERTY,
            "partitioning clause");
      }
      repPartPersFlags[1] = true;
      try {
        PartitionResolver resolver = (PartitionResolver)ClassPathLoader.getLatest().forName(
            resolverClass).getConstructor(TableName.class).newInstance(tableName);
        if (resolver instanceof InternalPartitionResolver) {
          InternalPartitionResolver internalResolver = (InternalPartitionResolver)resolver;
          String[] partCols = internalResolver.getPartitioningColumns();
          if (partCols != null && partCols.length > 0) {
            for (String partCol : partCols) {
               ColumnReference ref = (ColumnReference)nodeFactory.getNode(
                   C_NodeTypes.COLUMN_REFERENCE, partCol, null, getContextManager());
               distributionNode.addColumnReference(ref);
            }
            distributionNode.setPolicy(DistributionDescriptor.PARTITIONBYEXPRESSION);
          }
        }
        return resolver;
      } catch (Exception e) {
        throw StandardException.newException(
            SQLState.UNEXPECTED_EXCEPTION_FOR_PARTITION_RESOLVER, e, tableName);
      }
    }
}

PartitionResolver
partitionExpressionDefinition(DistributionDefinitionNode distributionNode) 
    throws StandardException :
{
    ValueNode exprNode = null;
    distributionNode.setPolicy(DistributionDescriptor.PARTITIONBYEXPRESSION);
    PartitionResolver prslvr = null;
}
{
    <LEFT_PAREN>
        exprNode = additiveExpression(null, 0 ,false)
    <RIGHT_PAREN>
    {
        prslvr = new GfxdPartitionByExpressionResolver(
            exprNode);
        return prslvr;                      
    }
}

PartitionResolver
partitionRangeDefinition(DistributionDefinitionNode distributionNode) 
    throws StandardException :
{
   
	ColumnReference columnName;
	ValueNode range;
	ValueNodeList ranges;
	distributionNode.setPolicy(DistributionDescriptor.PARTITIONBYRANGE);
	PartitionResolver prslvr = null;
}
{
	<LEFT_PAREN> columnName = columnReference() <RIGHT_PAREN> 
	{
	   distributionNode.addColumnReference(columnName);
	}
	<LEFT_PAREN> <VALUES> range = betweenPredicateValue(columnName, false)
	{
	    
	 
	     
		ContextManager cm = getContextManager();
		ranges = (ValueNodeList) nodeFactory.getNode(
			C_NodeTypes.VALUE_NODE_LIST, cm);
			
		ranges.addValueNode(range);
		distributionNode.addValueNodeList(((BetweenOperatorNode)range).getRightOperandList());
	}
	(
		<COMMA> <VALUES> range = betweenPredicateValue(columnName, false)
		{
			ranges.addValueNode(range);
			distributionNode.addValueNodeList(((BetweenOperatorNode)range).getRightOperandList());
			
		}
	)* <RIGHT_PAREN>
	{
		prslvr = new GfxdRangePartitionResolver(
			columnName, ranges);
		return prslvr;						
	}
}

PartitionResolver
partitionListDefinition(DistributionDefinitionNode distributionNode)
    throws StandardException :
{
	ColumnReference columnName;
	ValueNode value;
	ValueNodeList valueList;
	ArrayList listOfValueLists;
	ContextManager cm = getContextManager();
	distributionNode.setPolicy(DistributionDescriptor.PARTITIONBYLIST);
	PartitionResolver prslvr = null;
}
{
	<LEFT_PAREN> columnName = columnReference() <RIGHT_PAREN>
	<LEFT_PAREN>
	<VALUES> <LEFT_PAREN> value = additiveExpression(null, 0, false)
	{
	  distributionNode.addColumnReference(columnName);
	  
	    
      valueList = (ValueNodeList) nodeFactory.getNode(
			C_NodeTypes.VALUE_NODE_LIST, cm);
      valueList.addValueNode(value);
      listOfValueLists = new ArrayList();
	}
	
	(
	  <COMMA>
	    value = additiveExpression(null, 0, false)	    
	    {
	    	valueList.addValueNode(value);
	    }
	)*
	{
	    distributionNode.addValueNodeList(valueList);
		listOfValueLists.add(valueList);
	}
	<RIGHT_PAREN>
	[
	(
	  <COMMA> <VALUES> <LEFT_PAREN> value = additiveExpression(null, 0, false)
	  {
	  	valueList = (ValueNodeList) nodeFactory.getNode(
			C_NodeTypes.VALUE_NODE_LIST, cm);
	    valueList.addValueNode(value);
	  }
	  (
	  <COMMA>
	    value = additiveExpression(null, 0, false)
	    
	    {
	    	valueList.addValueNode(value);
	    }
	  )*
	  {
	    distributionNode.addValueNodeList(valueList);
	  	listOfValueLists.add(valueList);
	  }
	  <RIGHT_PAREN>
	 )+
	]
	<RIGHT_PAREN>
	{
		prslvr = new GfxdListPartitionResolver(
			columnName, listOfValueLists);
		return prslvr;
	}
}

PartitionResolver
partitionPKeyOrColumnDefinition(DistributionDefinitionNode distributionNode)
    throws StandardException :
{
	ColumnReference column_name;
	List colNames;
	GfxdPartitionByExpressionResolver prslvr = null;
}
{

	<PRIMARY> <KEY>
	{
	    distributionNode.setPolicy(DistributionDescriptor.PARTITIONBYPRIMARYKEY);
		prslvr = new GfxdPartitionByExpressionResolver();
		prslvr.setCustomHashing(distributionNode.getCustomHashing());
		prslvr.setPartitionByPrimaryKey();
		return prslvr;
	}
|
	<COLUMN> <LEFT_PAREN>
    column_name = columnReference()
    {
    	colNames = new ArrayList();
    	colNames.add(column_name);
    	distributionNode.addColumnReference(column_name);
    }
    (
      <COMMA> column_name = columnReference()
      {
      	colNames.add(column_name);
      	distributionNode.addColumnReference(column_name);
      } 
    )* <RIGHT_PAREN>
    {
        distributionNode.setPolicy(DistributionDescriptor.PARTITIONBYEXPRESSION);
    	prslvr = new GfxdPartitionByExpressionResolver(colNames.toArray());
    	prslvr.setCustomHashing(distributionNode.getCustomHashing());
    	return prslvr;
    }
}

TableName
otherTablesColocationDefinition(DistributionDefinitionNode distributionNode ) 
  throws StandardException :
{
	ColumnReference column_name;
	TableName table_name = null;
}
{
	<COLOCATE> <WITH>
		<LEFT_PAREN>
		  table_name = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
		<RIGHT_PAREN>
	{
	    distributionNode.setColocatedTable(table_name);
    	return table_name;
   	}
}

void
redundancyAndMaxPartSizeDefinition(PartitionAttributesFactory pafact,
    DistributionDefinitionNode distributionNode) throws StandardException :
{
	int redundancy;
	int numBuckets;
	long recoveryDelay;
	long startupRecoveryDelay;
	int maxPartSize;
}
{
	  <REDUNDANCY> redundancy = simpleValueSpecification_int()
	  {
	  	pafact.setRedundantCopies(redundancy);
	  	pafact.setRecoveryDelay(GemFireXDUtils.getDefaultRecoveryDelay());
	  	pafact.setStartupRecoveryDelay(
	  		GemFireXDUtils.getDefaultStartupRecoveryDelay());
	  	distributionNode.setRedundancy(redundancy);
	  }
|
	  <BUCKETS> numBuckets = simpleValueSpecification_int()
	  {
	    if (numBuckets >= Short.MAX_VALUE)
	    {
	      throw StandardException.newException(SQLState.LANG_INVALID_COLUMN_LENGTH,
                " bucket numbers should be less than: " + Short.MAX_VALUE);
	    }
	    pafact.setTotalNumBuckets(numBuckets);
	  }
|
	  <RECOVERYDELAY> recoveryDelay = simpleValueSpecification_long()
	  {
	    pafact.setRecoveryDelay(recoveryDelay);
	  }
|
	  <STARTUPRECOVERYDELAY> startupRecoveryDelay = simpleValueSpecification_long()
	  {
	    pafact.setStartupRecoveryDelay(startupRecoveryDelay);
	  }
|
	  <MAXPARTSIZE> maxPartSize = simpleValueSpecification_int()
	  {
	  	pafact.setLocalMaxMemory(maxPartSize);
	  	distributionNode.setMaxPartSize(maxPartSize);
	  }
}

void
serverGroupDefinition(ServerGroupsTableAttribute serverGroups) throws StandardException :
{
	String serverGroup;
}
{
	<SERVER> <GROUPS> <LEFT_PAREN>
	serverGroup = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	{
	  serverGroups.addServerGroup(StringUtil.SQLToUpperCase(serverGroup));
	}
	(
	  <COMMA> serverGroup = 
	    identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	  {
	    serverGroups.addServerGroup(StringUtil.SQLToUpperCase(serverGroup));
	  }
	)*
	<RIGHT_PAREN>
}

void
initSizeDefinition(InitSizeTableAttribute initSize) throws StandardException :
{
	int val;
}
{
	<INITSIZE> val = simpleValueSpecification_int()
	{
		// TODO: SW: how will this work when there is no pass by reference?
		initSize = new InitSizeTableAttribute(val);
	}
}

/*
void
loaderDefinition(AttributesFactory afact, TableName tableName) throws StandardException :
{
	List loaderParamsList = new ArrayList();
	ValueNode param;
	Object tmp;
	String loaderStr;
}
{
	<LOADER> <LEFT_PAREN> 
	  loaderStr = javaClassName()
	  // TODO BELOW COMMA IS JUST FOR TESTING
	  [ param = simpleValueSpecification()
	  {
	  	tmp = ((ConstantNode)param).getValue().getObject();
	  	
	  	if (tmp != null) {
	        loaderParamsList.add(tmp);
	    }
	  }
	  (
	    <COMMA> param = simpleValueSpecification()
	    {
	      tmp = ((ConstantNode)param).getValue().getObject();
	      if (tmp != null) {
	        loaderParamsList.add(tmp);
	      }
	    }
	  )*
	  ]
	  <RIGHT_PAREN>
	  {
	  	  try {
	  	  // TODO Remove comments after testing
	  	  Method instanceGetter = ClassLoadUtil.methodFromName(loaderStr);
	  	  RowLoader ldr = (RowLoader)instanceGetter.invoke(null);
	  	  ldr.init(loaderParamsList.toArray());
	  	  String schemaName = Misc.getSchemaName(tableName.getSchemaName(),
	  	    getLanguageConnectionContext());
	  	  GfxdCacheLoader gemfireCacheLdr = new GfxdCacheLoader(schemaName,
	  	                          tableName.getTableName(), ldr);

	  	  afact.setCacheLoader(gemfireCacheLdr);
	  	  } catch (Exception e) {
	  	  	throw StandardException.newException
			  (SQLState.AM_NO_FACTORY_FOR_IMPLEMENTATION, e);
	  	  }
	  	} 
}
*/

void
evictionDefinition(AttributesFactory afact, boolean[] repPartPersFlags) throws StandardException :
{
    /*if(!Misc.isServer()) {
      return;
    }*/
	int valnode;
	int timeInterval = -1;
	EvictionTableAttribute evictAttr = new EvictionTableAttribute();
	EvictionAction evctAction = null;	
}
{
	(
	<LRUMEMSIZE> valnode = simpleValueSpecification_int()
	{
	    // I'd rather use the attributesFactory to determine if eviction was
	    // already specified, but it's read-only, and may not have all
	    // valid info to be created into a regionAttributes class.
	    // So, use a simple global flag.
	    if (evictionChoice != 0)
	    {
	         // Throw error, we already have an eviction clause
	   		 throw StandardException.newException(SQLState.LANG_DUPLICATE_PROPERTY, "EVICTION");    
	    }
	    // LRUMEMSIZE cannot be zero. If it is, hosting the data of this region
	    // throws an exception at connect time. Stop it here.
	    if (valnode == 0)
	    {
	    	throw StandardException.newException(SQLState.LANG_INVALID_COLUMN_LENGTH,
                "LRUMEMSIZE cannot be zero");
	    }
	    evictAttr.setType(EvictionTableAttribute.ID_MEMSIZE);
	    evictAttr.setValue(valnode); 
	    evictionChoice = 1;
	}
    |
    <LRUHEAPPERCENT>
	{
	    if (evictionChoice != 0)
	    {
	         // Throw error, we already have an eviction clause
	   		 throw StandardException.newException(SQLState.LANG_DUPLICATE_PROPERTY, "EVICTION");    
	    }
	    evictAttr.setType(EvictionTableAttribute.ID_HEAPPERCENT);
	    evictionChoice = 1;
	}
    |
    <LRUCOUNT> valnode = simpleValueSpecification_int()
	{
	    if (evictionChoice != 0)
	    {
	         // Throw error, we already have an eviction clause
	   		 throw StandardException.newException(SQLState.LANG_DUPLICATE_PROPERTY, "EVICTION");    
	    }
	    evictAttr.setType(EvictionTableAttribute.ID_COUNT);
	    evictAttr.setValue(valnode); 
	    evictionChoice = 1;
	}
	)
	[  evctAction = evictionActionDefinition(afact)  ]
	{
	    repPartPersFlags[4] = true;
	    evictAttr.setEvictionAction(evctAction);
	    evictAttr.setEvictionAttributes(afact);
	}
}

EvictionAction
evictionActionDefinition(AttributesFactory afact) throws StandardException :
{
	EvictionAction evctAction;
	CharConstantNode strNode = null;
	
}
{
	<EVICTACTION>
	(
	  <DESTROY>
	  {
	    // TODO : this is incompatible with REPLICATE region
	    // but not currently throwing syntax error, Gemfire layer
	    // throws IllegalStateException.
	  	evctAction = EvictionAction.LOCAL_DESTROY;
	  }
|
	  <OVERFLOW>
	  {
	  	evctAction = EvictionAction.OVERFLOW_TO_DISK;
	  }	
	  (
	     strNode = stringLiteral() | syncOrAsyncAttribute(afact)
	  )*
	 {
		if (strNode != null)
		{
		  //check if an explicit disk store is already set, if yes throw exception		  
		  if( prevDiskStore != null )
		  {
              throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, "Disk Store '"+ prevDiskStore
              +"' already set");		    
		  }		  
		  prevDiskStore = strNode.getString();
		  afact.setDiskStoreName(StringUtil.SQLToUpperCase(prevDiskStore));
		}
		else
		{
		  afact.setDiskStoreName(GfxdConstants.GFXD_DEFAULT_DISKSTORE_NAME);
		}
	 }     
	)
	{
		return evctAction;
	}
}


void
customEvictionDefinition(AttributesFactory afact,
    boolean[] repPartPersFlags) throws StandardException :
{
    ValueNode predNode;
    Token tok, leftParenToken, rightParenToken;
    long startMillis = 0;
    long intervalMillis = 0;
    java.sql.Timestamp startTime = null;
    BigDecimal[] interval = new BigDecimal[1];
}
{
	<CRITERIA> leftParenToken = <LEFT_PAREN>
	predNode = whereClause(leftParenToken)
	rightParenToken = <RIGHT_PAREN>
	(
	  <EVICTION> startTime = evictionFrequency(interval)
	|
	  <EVICT> <INCOMING>
	)
	{
	  if (interval[0] != null) {
	    if (startTime != null) {
	      startMillis = startTime.getTime();
	    }
	    intervalMillis = interval[0].longValue() * 1000L;
	  }
	  if (!Misc.getMemStoreBooting().isHadoopGfxdLonerMode()) {
	  	afact.setCustomEvictionAttributes(new GfxdEvictionCriteria(predNode,
	    	  statementSQLText, leftParenToken.endOffset + 1,
	      	rightParenToken.beginOffset), startMillis, intervalMillis);
	  	repPartPersFlags[6] = true;
	  }
	}
}

java.sql.Timestamp
evictionFrequency(BigDecimal[] interval) throws StandardException:
{
	ValueNode startTime = null;
	Token tok;
}
{
	<FREQUENCY>
	tok = <EXACT_NUMERIC>
	{
	  try {
	    interval[0] = new BigDecimal(tok.image);
	  } catch (NumberFormatException nfe) {
	    throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR,
	        nfe, nfe.toString());
	 }
	}
	(
	  <DAYS>
	  {
	    interval[0] = interval[0].multiply(new BigDecimal(3600L*24L));
	  }
	  | <HOURS>
	  {
	    interval[0] = interval[0].multiply(new BigDecimal(3600L));
	  }
	  | <MINUTES>
	  {
	    interval[0] = interval[0].multiply(new BigDecimal(60L));
	  }
	  | <SECONDS>
	)
	[ <START> startTime = escapedDateTimeLiteral() ]
	{
	  if (startTime != null) {
	    return ((DateTimeDataValue)startTime.getConstantValueAsObject())
	        .getTimestamp(java.util.Calendar.getInstance(
	            java.util.TimeZone.getTimeZone("GMT")));
	  }
	  else {
	    return null;
	  }
	}
}

NumericConstantNode
getIntervalInMins() throws StandardException:
{
   BigDecimal interval = null;
}
{
  {
    interval = new BigDecimal(getLongValue(getIntervalInMillis()));
    interval = interval.divide(new BigDecimal(1000L*60L));
    return getNumericNode(String.valueOf(interval.longValue()), true);
  }
}

NumericConstantNode
getIntervalInSecs() throws StandardException:
{
   BigDecimal interval = null;
}
{
  {
    interval = new BigDecimal(getLongValue(getIntervalInMillis()));
    interval = interval.divide(new BigDecimal(1000L));
    return getNumericNode(String.valueOf(interval.longValue()), true);
  }
}

NumericConstantNode
getIntervalInMillis() throws StandardException:
{
    BigDecimal interval = null;
}
{
  {
    interval = new BigDecimal(getIntValue(intLiteral()));
  }
  (
    <DAYS>
    {
       interval = interval.multiply(new BigDecimal(1000L*60L*60L*24L));
    }
    | <HOURS>
    {
       interval = interval.multiply(new BigDecimal(1000L*60L*60L));
    }
    | <MINUTES>
    {
       interval = interval.multiply(new BigDecimal(1000L*60L));
    }
    | <SECONDS>
    {
      interval = interval.multiply(new BigDecimal(1000L));
    }
    | <MILLISECONDS>
  )
  {
    return getNumericNode(String.valueOf(interval), true);
  }
}

void
syncOrAsyncAttribute(AttributesFactory afact) throws StandardException :
{
}
{
  {
    
   if(this.prevPersistenceModeSet != null)
   {
      throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, "Disk persistence mode already set to "
      + (this.prevPersistenceModeSet.equals("true")?"Synchronous":"Asynchronous"));	
   }
 }
  
	<SYNCHRONOUS>
	{
	    this.prevPersistenceModeSet ="true";
		afact.setDiskSynchronous(true);      
	}
|
   {
    
     if(this.prevPersistenceModeSet != null)
     {
        throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, "Disk persistence mode already set to "
        + (this.prevPersistenceModeSet.equals("true")?"Synchronous":"Asynchronous"));	
     }
   }
	<ASYNCHRONOUS>
	{
	    this.prevPersistenceModeSet ="false";
		afact.setDiskSynchronous(false);
	}	
}


void diskStoreAttribs(Map otherAttribs) throws StandardException : 
{
	Token tok;
	ValueNode val;
	Token bool ;
}
{   
	
	 (
	      
	(
	 tok= <MAXLOGSIZE>
    |
    tok = <COMPACTIONTHRESHOLD>
    |
    tok = <TIMEINTERVAL>
    |
    tok = <WRITEBUFFERSIZE>
    |
    tok = <QUEUESIZE>
    
   )
    val = intLiteral()
	{
	  if (getIntValue(val) < 0)
	  {
	     throw StandardException.newException(SQLState.LANG_INVALID_COLUMN_LENGTH,
                "Value "+getIntValue(val)+" is negative");
	  }
	  addToMapAllowOnce(otherAttribs,tok.image,val);
	}
   )  
   |
   (
     (         	
		tok = <AUTOCOMPACT>
		|
    	tok = <ALLOWFORCECOMPACTION>
     )   
     bool = booleanLiteral()
	{
	  addToMapAllowOnce(otherAttribs,tok.image,bool.image);
	}
   ) 

    
}
void autoCompaction(Map otherAttribs) throws StandardException : 
{	
	Token tok1;
	Token tok2;
}
{
	tok1 =<AUTOCOMPACT> tok2 = booleanLiteral()
	  {
	  	addToMapAllowOnce(otherAttribs,tok1.image,tok2.image);
	  }
}



   

void
expirationDefinition(AttributesFactory afact) throws StandardException :
{
	int expirationKind;
	ExpirationAttributes[] exprAttrs = new ExpirationAttributes[1];
}
{
	expirationKind = expirationKindDefinition(exprAttrs)
	{
		switch (expirationKind) {
		    // Only allow these to be set once - if already set, throw error
		    // using a static flag instead of creating attributes from factory
		    // because all valid settings for attributes in the factory
		    // may not currently exist (DDL clauses for CREATE TABLE can appear
		    // in any order). We need to catch these errors outside of Gemfire
		    // layer in order to throw an understandable SQL error.
			case GfxdAttributesMutator.EXPIRE_REGION_TIMETOLIVE:
			    if (expirationFlag == 1)
			    {
			   		 throw StandardException.newException(SQLState.LANG_DUPLICATE_PROPERTY, "TABLE TIME TO LIVE");    
			    }
				afact.setRegionTimeToLive(exprAttrs[0]);
				expirationFlag = 1;
				break;
			case GfxdAttributesMutator.EXPIRE_REGION_IDLETIME:
			    if (expirationFlag == 2)
			    {
			   		 throw StandardException.newException(SQLState.LANG_DUPLICATE_PROPERTY, "TABLE IDLETIME");    
			    }
				afact.setRegionIdleTimeout(exprAttrs[0]);
				expirationFlag = 2;
				break;
			case GfxdAttributesMutator.EXPIRE_ENTRY_TIMETOLIVE:
			    if (expirationFlag == 3)
			    {
			   		 throw StandardException.newException(SQLState.LANG_DUPLICATE_PROPERTY, "ENTRY TIME TO LIVE");    
			    }
				afact.setEntryTimeToLive(exprAttrs[0]);
				expirationFlag = 3;
				break;
			case GfxdAttributesMutator.EXPIRE_ENTRY_IDLETIME:
			    if (expirationFlag == 4)
			    {
			   		 throw StandardException.newException(SQLState.LANG_DUPLICATE_PROPERTY, "ENTRY IDLETIME");    
			    }
				afact.setEntryIdleTimeout(exprAttrs[0]);
				expirationFlag = 4;
				break;
		}
	}
}

int
expirationKindDefinition(ExpirationAttributes[] exprAttrs) throws StandardException :
{
	int expirationKind;
	int duration;
	ExpirationAttributes exprAttr;
	ExpirationAction action;
}
{
	<EXPIRE>
	(
		<TABLE> <WITH>
		(
			<TIMETOLIVE> duration = simpleValueSpecification_int()
				action = expirationActionDefinition()
			{
				expirationKind = GfxdAttributesMutator.EXPIRE_REGION_TIMETOLIVE;
			}
		|
			<IDLETIME> duration = simpleValueSpecification_int()
				action = expirationActionDefinition()
			{
				expirationKind = GfxdAttributesMutator.EXPIRE_REGION_IDLETIME;
			}
		)
	|
		<ENTRY> <WITH>
		(
			<TIMETOLIVE> duration = simpleValueSpecification_int()
				action = expirationActionDefinition()
			{
				expirationKind = GfxdAttributesMutator.EXPIRE_ENTRY_TIMETOLIVE;
			}
		|
			<IDLETIME> duration = simpleValueSpecification_int()
				action = expirationActionDefinition()
			{
				expirationKind = GfxdAttributesMutator.EXPIRE_ENTRY_IDLETIME;
			}
		)
	)
	{
		exprAttrs[0] = new ExpirationAttributes(duration, action);
		return expirationKind;
	}
}

ExpirationAction
expirationActionDefinition() throws StandardException :
{
	ExpirationAction action;
}
{
    // ACTION INVALIDATE is not supported for GemFireXD, removed from grammar
    // Only valid action is DESTROY
	<ACTION> <DESTROY>
	{
		action = ExpirationAction.DESTROY;
	}
	{
		return action;
	}
}

void
persistenceDiskDefinition(AttributesFactory afact, boolean[] repPartPersFlags)
  throws StandardException :
{
	CharConstantNode strNode = null;
}
{
	<PERSISTENT>
	( strNode = stringLiteral() | syncOrAsyncAttribute(afact))*
	{
		repPartPersFlags[2] = true;
		if (strNode != null)
		{
		  if (prevDiskStore != null)
		  {
		    throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR,
		      "Disk Store '"+ prevDiskStore + "' already set");
		  }
		  prevDiskStore = strNode.getString();
		  afact.setDiskStoreName(StringUtil.SQLToUpperCase(prevDiskStore));
		}
		else
		{
		  afact.setDiskStoreName(GfxdConstants.GFXD_DEFAULT_DISKSTORE_NAME);
		}
	}
}

void
persistenceHDFSDefinition(AttributesFactory afact, boolean[] repPartPersFlags)
  throws StandardException :
{
	String hdfsStoreName, prevHDFSStore = null;
}
{
	<HDFSSTORE><LEFT_PAREN>
	hdfsStoreName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	<RIGHT_PAREN>
	{
		repPartPersFlags[5] = true;
		if (hdfsStoreName != null) {
		  if (prevHDFSStore != null) {
		    throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR,
		      "HDFS Store '"+ prevHDFSStore +"' already set");
		  }
		  prevHDFSStore = hdfsStoreName;
		  afact.setHDFSStoreName(hdfsStoreName);
		}
	}
	[ <WRITEONLY> { afact.setHDFSWriteOnly(true); } ]
}

void
gatewaySenderRegionDefinition(AttributesFactory afact)
  throws StandardException :
{
   String gatewayId;
   CharConstantNode strNode = null;	   
   boolean isAsyncListener;
}
{

    (
	  <GATEWAYSENDER>
	  {
	    isAsyncListener = false;
	  }
	|
	  <ASYNCLISTENER>
	  {
	    isAsyncListener = true;
	  }
	)

	<LEFT_PAREN>
	(

	(
	gatewayId = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	{
	  afact.setEnableGateway(true);
	  if (isAsyncListener) {
	    afact.addAsyncEventQueueId(gatewayId);
	  }
	  else {
	    afact.addGatewaySenderId(gatewayId);
	  }
	}
	(
	  <COMMA> gatewayId = 
	    identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	  {
	    if (isAsyncListener) {
	      afact.addAsyncEventQueueId(gatewayId);
	    }
	    else {
	      afact.addGatewaySenderId(gatewayId);
	    }
	  }
	)*
  	)
	)
	<RIGHT_PAREN>
}

void
concurrencyLevelDefinition(AttributesFactory afact)
  throws StandardException :
{
  int level;
}
{
  <CONCURRENCY> <LEVEL> level = simpleValueSpecification_int()
  {
    afact.setConcurrencyLevel(level);
  }
}

void
memScaleDefinition(AttributesFactory afact)
  throws StandardException :
{
}
{
   <OFFHEAP>
   {
   	  if (!ServerGroupUtils.isDataStore()) {
   	  	afact.setEnableOffHeapMemory(false);
   	  }
   	  else {
	  	afact.setEnableOffHeapMemory(true);
	  }
   }
}

void
concurrencyChecksDefinition(AttributesFactory afact ,  boolean[] repPartPersFlags)
  throws StandardException :
{
}
{
  <ENABLE> <CONCURRENCY> <CHECKS>
  {
    afact.setConcurrencyChecksEnabled(true);
  }
  |
   <DISABLE> <CONCURRENCY> <CHECKS>
   {
   afact.setConcurrencyChecksEnabled(false);
   repPartPersFlags[7] = true;
   }
}

// GemStone changes END

ResultColumnList
tableColumnList() throws StandardException :
{
	ResultColumnList resultColumns = (ResultColumnList) nodeFactory.getNode(
											C_NodeTypes.RESULT_COLUMN_LIST,
											getContextManager());
}
{
	columnNameList(resultColumns)
	{
		return resultColumns;
	}
}

/*
 * This method is called when a comment starting with --gemfirexd-properties is found.
 * Such a comment is a special directive to Derby and allows a sql to pass optimizer
 * overrides. Derby looks for propertyName=value [,propertyName=value]* after
 * --gemfirexd-properties and returns these properties in a Properties object as a return 
 * value of this method.
 * The param propertiesUseAllowed true indicates that users are allowed to 
 * specify optimizer overrides in the given context. 
 * False means optimizer overrides in the given context are allowed internally 
 * only eg impl/load/import.java specifies property insertMode=replace/bulkInsert
 * in the insert statement. This same property will not be acceptable from an 
 * insert statement from a user sql.
 */
Properties
propertyList(boolean propertiesUseAllowed) throws StandardException :
{
	Properties properties = new FormatableProperties();
	StringTokenizer commaSeparatedProperties;
	StringTokenizer equalOperatorSeparatedProperty;
}
{
	<GEMFIREXDDASHPROPERTIES> {
		//first use StringTokenizer to get tokens which are delimited by ,s
		commaSeparatedProperties = new StringTokenizer(getToken(1).image,",");
		while (commaSeparatedProperties.hasMoreTokens()) {
			//Now verify that tokens delimited by ,s follow propertyName=value pattern
			String currentProperty = commaSeparatedProperties.nextToken();
			equalOperatorSeparatedProperty = new StringTokenizer(currentProperty,"=", true);
			if (equalOperatorSeparatedProperty.countTokens() != 3)
				throw StandardException.newException(SQLState.PROPERTY_SYNTAX_INVALID);
			else {
				String key = equalOperatorSeparatedProperty.nextToken().trim();
				if (!equalOperatorSeparatedProperty.nextToken().equals("="))
					throw StandardException.newException(SQLState.PROPERTY_SYNTAX_INVALID);
				String value = equalOperatorSeparatedProperty.nextToken().trim();
				verifyImageLength(value);
				/* Trim off the leading and trailing ', and compress all '' to ' */
				if (value.startsWith("'") && value.endsWith("'"))
					value = compressQuotes(value.substring(1, value.length() - 1), SINGLEQUOTES);
				/* Trim off the leading and trailing ", and compress all "" to " */
				else if (value.startsWith("\"") && value.endsWith("\""))
					value = compressQuotes(value.substring(1, value.length() - 1), DOUBLEQUOTES);
                                // GemStone changes BEGIN
                                // don't alter the value to upperCase as sizerHints are enumerations.
				// and statementAlias is user defined.
                                else if (key.equals(Constants.QueryHints.sizerHints.name()) 
                                      || key.equals(Constants.QueryHints.statementAlias.name())) 
                                {
                                        value = value.trim();
                                }
                                // GemStone changes END
				else {
					value = value.trim();
					value = value.toUpperCase();
					}
				// Do not allow user to specify multiple values for the same key
				if (properties.put(key, value) != null)
				{
					throw StandardException.newException(SQLState.LANG_DUPLICATE_PROPERTY, key);
				}
		}
	}
	//if this property override is supported in internal mode only, then do that verification here.
	if (!propertiesUseAllowed) 
		checkInternalFeature("GEMFIREXD-PROPERTIES");
	return properties;
	}
}

/*
 * <A NAME="DB2lockGranularityClause">DB2lockGranularityClause</A>
 */
char
DB2lockGranularityClause() throws StandardException :
{
	char lockGranularity;
}
{
	<LOCKSIZE> lockGranularity = lockGranularity()
	{
		return lockGranularity;
	}
}

/*
 * <A NAME="lockGranularity">lockGranularity</A>
 */
char
lockGranularity() throws StandardException :
{
}
{
	<TABLE>
	{
		return TableDescriptor.TABLE_LOCK_GRANULARITY;
	}
|
	<ROW>
	{
		return TableDescriptor.ROW_LOCK_GRANULARITY;
	}
}

/*
 * <A NAME="indexDefinition">indexDefinition</A>
 */
StatementNode
indexDefinition() throws StandardException :
{
	Boolean		unique = Boolean.FALSE;
// GemStone changes BEGIN
	boolean		globalHash = false;
// GemStone changes END
	Properties	properties = null;
	TableName	indexName;
	TableName	tableName;
	Vector	indexColumnList = new Vector();
	CompilerContext cc = getCompilerContext();
}
{
	/*
	** fyi: The INDEX keyword is pushed into the indexType()
	** production to get the grammar to work...
	*/
// GemStone changes BEGIN
	[ unique = unique() | <GLOBAL> <HASH> { globalHash = true; } ] <INDEX>
		indexName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH) <ON> tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
				<LEFT_PAREN> indexColumnList(indexColumnList, globalHash) <RIGHT_PAREN>
	[ properties = propertyList(true) <CHECK_PROPERTIES>]
	/*
	[ unique = unique() ] <INDEX>
		indexName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH) <ON> tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
				<LEFT_PAREN> indexColumnList(indexColumnList) <RIGHT_PAREN>
		[ properties = propertyList(false) <CHECK_PROPERTIES>]
	*/
// GemStone changes END
	{
   cc.setForcedDDLrouting(true);
		/* User allowed to specify schema name on table and index.
		 * If no schema name specified for index, then it "inherits" 
		 * its schema name from the table.
		 * If index has a schema name and table does not, then
		 * table "inherits" its schema name from the index.
		 * If schema names are specified for both objects, then the
		 * schema names must be the same.
		 */
		if (indexName.getSchemaName() == null)
		{
			indexName.setSchemaName(tableName.getSchemaName());
		}
		else if (tableName.getSchemaName() == null)
		{
			tableName.setSchemaName(indexName.getSchemaName());
		}
		else
		{
			/* schema name specified for both */
			if (! (indexName.getSchemaName().equals(
						tableName.getSchemaName())))
			{
				throw StandardException.newException(SQLState.LANG_INDEX_AND_TABLE_IN_DIFFERENT_SCHEMAS, 
							indexName,
							tableName);
			}
		}
		return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.CREATE_INDEX_NODE,
								unique,
// GemStone changes BEGIN
								globalHash ? GfxdConstants.GLOBAL_HASH_INDEX_TYPE
								  : DEFAULT_INDEX_TYPE,
								/* DEFAULT_INDEX_TYPE, */
// GemStone changes END
								indexName,
								tableName,
								indexColumnList,
								properties,
								getContextManager());
	}
}

/*
 * <A NAME="unique">unique</A>
 */
Boolean
unique() throws StandardException :
{
}
{
	<UNIQUE>
	{
		return Boolean.TRUE;
	}
}

/**
	CREATE PROCEDURE

	procedureElements contains the description of the procedure.
	(CREATE FUNCTIONS shares this lyout), see functionDefinition

	0 - Object[] 3 element array for parameters
	1 - TableName - specific name
	2 - Integer - dynamic result set count
	3 - String language (always java) - ignore
	4 - String external name (also passed directly to create alias node - ignore
	5 - Short parameter style (always java) - ignore 
	6 - Short - SQL allowed.
	7 - Boolean - CALLED ON NULL INPUT (always TRUE for procedures)
	8 - TypeDescriptor - return type (always NULL for procedures)
*/

StatementNode
procedureDefinition() throws StandardException :
{
	TableName procedureName;
	Object[] procedureElements = new Object[9];
}
{
		<PROCEDURE> procedureName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
		procedureElements[0] = procedureParameterList()
		( routineElement(true, false, procedureElements) ) +
		{
		    checkRequiredRoutineClause(JAVA_ROUTINE_CLAUSES, procedureElements);

			return getCreateAliasNode(
							procedureName,
							(String) procedureElements[4],
							procedureElements,
							AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR,
							Boolean.FALSE);
		}
}

void routineElement(boolean isProcedure, boolean isTableFunction, Object[] routineElements) throws StandardException :
{
	int drs;
	int clausePosition = -1;
	Object clauseValue = null;
}
{
	(
		<SPECIFIC> clauseValue = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
			{ clausePosition = 1; throw StandardException.newException(SQLState.NOT_IMPLEMENTED, "SPECIFIC identifier");}
	|
		[ <DYNAMIC> ] <RESULT> <SETS> drs = uint_value()
		{
			if (!isProcedure)
				throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, "RESULT SETS");
			clauseValue = ReuseFactory.getInteger(drs); clausePosition = 2;
		}
	|
		<LANGUAGE>  <JAVA> { clauseValue = "JAVA"; clausePosition = 3; }
	|
		<EXTERNAL> <NAME> clauseValue = string() { clausePosition = 4; }
	|
		<PARAMETER> <STYLE> clauseValue = parameterStyle( isTableFunction ) { clausePosition = 5; }

	|	<NO> <SQL>				{ clauseValue = ReuseFactory.getShort(RoutineAliasInfo.NO_SQL); clausePosition = 6; }
	|	<CONTAINS> <SQL>		{ clauseValue = ReuseFactory.getShort(RoutineAliasInfo.CONTAINS_SQL); clausePosition = 6; }
	|	<READS> <SQL> <DATA>	{ clauseValue = ReuseFactory.getShort(RoutineAliasInfo.READS_SQL_DATA); clausePosition = 6; }
	|	<MODIFIES> <SQL> <DATA>
		{
			if (!isProcedure)
				throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR, "MODIFIES SQL DATA");
			clauseValue = ReuseFactory.getShort(RoutineAliasInfo.MODIFIES_SQL_DATA); clausePosition = 6;
		}

	|   clauseValue = calledOnNullInput(isProcedure) { clausePosition = 7; }
	)

	{
		if (clausePosition != -1) {
			// check for repeated clause
			if (routineElements[clausePosition] != null) {

				String which = ROUTINE_CLAUSE_NAMES[clausePosition];
				throw StandardException.newException(SQLState.LANG_DB2_MULTIPLE_ELEMENTS, which);
			}
				
			routineElements[clausePosition] = clauseValue;
		}
	}
}

Boolean calledOnNullInput(boolean isProcedure) throws StandardException :
{
	Boolean calledOnNull;
}
{
	(
		<CALLED> { calledOnNull = Boolean.TRUE; }
		| <RETURNS> <NULL> {
		   if (isProcedure)
		     throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR,
		             "RETURNS NULL ON NULL INPUT");
		   
		   calledOnNull = Boolean.FALSE;
		}
		
	) <ON> <NULL> <INPUT>
	{
		return calledOnNull;
	}
}

Short parameterStyle( boolean isTableFunction ) throws StandardException :
{
}
{
	  <JAVA>
	  {
	      if ( isTableFunction )
	      { throw StandardException.newException( SQLState.LANG_MUST_BE_DJRS ); }

	      return ReuseFactory.getShort(RoutineAliasInfo.PS_JAVA);
	  }
|
	  <DERBY_JDBC_RESULT_SET>
	  {
	      if ( !isTableFunction )
	      { throw StandardException.newException( SQLState.LANG_NO_DJRS ); }

	      return ReuseFactory.getShort(RoutineAliasInfo.PS_DERBY_JDBC_RESULT_SET);
	  }
}

Object[]
procedureParameterList() throws StandardException :
{
	Vector[] list = new Vector[3];
	list[0] = new Vector(); // name
	list[1] = new Vector(); // type
	list[2] = new Vector(); // in/out
}
{
	<LEFT_PAREN>
		[ procedureParameterDefinition(list)
				( <COMMA> procedureParameterDefinition(list) )* ]
	<RIGHT_PAREN>
	{
		return list;
	}
}

/*
 * <A NAME="Definition">procedureParameterDefinition</A>
 */
void
procedureParameterDefinition(Vector[] list) throws StandardException :
{
	DataTypeDescriptor	typeDescriptor;
	String				parameterName = "";
	Integer				inout;
}
{
	inout = inoutParameter()
	
	// Lookahead needed because token could satisfy identifier and dataTypeDDL
	[   LOOKAHEAD( { dataTypeCheck(2) })
	    parameterName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	]
	typeDescriptor = dataTypeDDL()
	{
		list[0].addElement(parameterName);
		list[1].addElement(typeDescriptor.getCatalogType());
		list[2].addElement(inout);
	}
}

Integer
inoutParameter() :
{
	int mode = JDBC30Translation.PARAMETER_MODE_IN;
}
{
	[
		  <IN> { }
		| <OUT> { mode = JDBC30Translation.PARAMETER_MODE_OUT; }
		| <INOUT> { mode = JDBC30Translation.PARAMETER_MODE_IN_OUT; }
	]
	{ return ReuseFactory.getInteger(mode); }
}

/**
	CREATE FUNCTION

	functionElements contains the description of the function.

	0 - Object[] 3 element array for parameters
	1 - TableName - specific name
	2 - Integer - dynamic result set count - always 0
	3 - String language (always java) - required to be set
	4 - String external name (also passed directly to create alias node - ignore
	5 - Short parameter style (always java) - required to be set 
	6 - Short - SQL allowed.
	7 - Boolean - CALLED ON NULL INPUT
	8 - TypeDescriptor - return type
*/

StatementNode
functionDefinition() throws StandardException :
{
	TableName functionName;
	TypeDescriptor  returnType;
	Object[] functionElements = new Object[9];
}
{
		<FUNCTION> functionName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
		functionElements[0] = functionParameterList()
		<RETURNS> returnType = functionReturnDataType() 
		( routineElement(false, returnType.isRowMultiSet(), functionElements) ) +
		{
		    functionElements[8] = returnType;
		    checkRequiredRoutineClause(JAVA_ROUTINE_CLAUSES, functionElements);
		    
			return getCreateAliasNode(
							functionName,
							(String) functionElements[4],
							functionElements,
							AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR,
							Boolean.FALSE);
		}
}

Object[]
functionParameterList() throws StandardException :
{
	Vector[] list = new Vector[3];
	list[0] = new Vector(); // name
	list[1] = new Vector(); // type
	list[2] = new Vector(); // in/out - ALWAYS IN
}
{
	<LEFT_PAREN>
		[ functionParameterDefinition(list)
				( <COMMA> functionParameterDefinition(list) )* ]
	<RIGHT_PAREN>
	{
		return list;
	}
}

/*
 * <A NAME="Definition">functionParameterDefinition</A>
 */
void
functionParameterDefinition(Vector[] list) throws StandardException :
{
	DataTypeDescriptor	typeDescriptor;
	String				parameterName = "";
}
{
	// Lookahead needed because token could satisfy identifier and dataTypeDDL
	[   LOOKAHEAD( { dataTypeCheck(2) })
	    parameterName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	]
	typeDescriptor = dataTypeDDL() 
	{
		list[0].addElement(parameterName);
		list[1].addElement(typeDescriptor.getCatalogType());
		list[2].addElement(ReuseFactory.getInteger(JDBC30Translation.PARAMETER_MODE_IN));
	}
}


/*
 * <A NAME="functionReturnDataType">functionReturnDataType</A>
 */
TypeDescriptor
functionReturnDataType() throws StandardException :
{
    TypeDescriptor	typeDescriptor;
}
{
    (
        typeDescriptor = catalogType()
         |
        typeDescriptor = functionTableType()
    )
    {
        return typeDescriptor;
    }
}

/*
 * <A NAME="functionTableType">functionTableType</A>
 */
TypeDescriptor
functionTableType() throws StandardException :
{
	ArrayList                       names = new ArrayList();
	ArrayList                         types = new ArrayList();
	String[]                          nameArray;
	TypeDescriptor[]        typeArray;
	int                                     columnCount;
}
{
	<TABLE>
	<LEFT_PAREN>
	    functionTableReturnColumn( names, types )
	    ( <COMMA> functionTableReturnColumn( names, types ) ) *
	<RIGHT_PAREN>
	{
        checkVersion( DataDictionary.DD_VERSION_DERBY_10_4, "CREATE FUNCTION...RETURNS TABLE");

		columnCount = names.size();
		nameArray = new String[ columnCount ];
		names.toArray( nameArray );
		typeArray = new TypeDescriptor[ columnCount ];
		types.toArray( typeArray );

		//
		// We do not allow XML as a column datatype because
		// Derby does not yet support the streaming JDBC4
		// interfaces to XML values.
		//
		for ( int i = 0; i < columnCount; i++ )
		{
		    if ( typeArray[ i ].getJDBCTypeId() == JDBC40Translation.SQLXML )
		    { throw StandardException.newException( SQLState.LANG_XML_NOT_ALLOWED_DJRS ); }
		}

		return DataTypeDescriptor.getRowMultiSet( nameArray, typeArray );
	}
}

/*
 * <A NAME="functionTableReturnColumn">functionTableReturnColumn</A>
 */
void
functionTableReturnColumn
(
    ArrayList names,
    ArrayList types
)
throws StandardException :
{
	String                          name;
	DataTypeDescriptor	typeDescriptor;
}
{
	name = identifier( Limits.MAX_IDENTIFIER_LENGTH, true )
	typeDescriptor = dataTypeDDL()
	{
		names.add( name );
		types.add( typeDescriptor.getCatalogType() );
	}
}

/**
	CREATE TYPE
*/

StatementNode
udtDefinition() throws StandardException :
{
	TableName udtName;
	String externalName;
}
{
		<TYPE> udtName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
		<EXTERNAL> <NAME> externalName = string()
		<LANGUAGE>  <JAVA>
		{
			checkVersion(DataDictionary.DD_VERSION_DERBY_10_4, "CREATE TYPE");
			return getCreateAliasNode(
							udtName,
							externalName,
							null,
							AliasInfo.ALIAS_TYPE_UDT_AS_CHAR,
							Boolean.FALSE);
		}
}

StatementNode
viewDefinition(Token beginToken) throws StandardException :
{
	int					checkOptionType;
	ResultColumnList	resultColumns = null;
	ResultSetNode		queryExpression;
	TableName			tableName;
	Token				checkTok = null;
	Token				endToken;
}
{
	<VIEW>
	{
		CompilerContext cc = getCompilerContext();
		cc.markAsDDLForSnappyUse(true);
		cc.setForcedDDLrouting(true);
	}
	tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
		[ <LEFT_PAREN> resultColumns = viewColumnList() <RIGHT_PAREN> ]
		<AS> queryExpression = queryExpression(null, NO_SET_OP)
	{
		checkOptionType = ViewDescriptor.NO_CHECK_OPTION;
		endToken = getToken(0);
		/* Parameters not allowed in create view */
		HasNodeVisitor visitor = new HasNodeVisitor(ParameterNode.class);
		queryExpression.accept(visitor);
		if (visitor.hasNode())
		{
			throw StandardException.newException(SQLState.LANG_NO_PARAMS_IN_VIEWS);
		}

		return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.CREATE_VIEW_NODE,
								tableName, 
								resultColumns, 
								queryExpression,
								ReuseFactory.getInteger(checkOptionType),
								StringUtil.slice(statementSQLText,
												beginToken.beginOffset,
												endToken.endOffset,false),
								getContextManager());
	}
}

ResultColumnList
viewColumnList() throws StandardException :
{
	ResultColumnList	resultColumns = (ResultColumnList) nodeFactory.getNode(
											C_NodeTypes.RESULT_COLUMN_LIST,
											getContextManager());
}
{
	/* RESOLVE: Passing null parameter for now just to keep Java happy */
	columnNameList(resultColumns)
	{
		return resultColumns;
	}
}

StatementNode
triggerDefinition() throws StandardException :
{
	Boolean				isBefore;
	Boolean				isRow = Boolean.FALSE;  // STATEMENT implicit by default
	TableName			tableName;
	TableName			triggerName;
	Token[]				tokenHolder = new Token[1];
	Token				beginToken;
	Token				checkTok = null;
	Token				endToken;
	int					actionBegin;
	int					actionEnd;
	int					triggerEvent;
	QueryTreeNode		actionNode;
	ResultColumnList	triggerColumns = (ResultColumnList) nodeFactory.getNode(
											C_NodeTypes.RESULT_COLUMN_LIST,
											getContextManager());
	Vector				refClause = null;
}
{
	<TRIGGER> triggerName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
	isBefore = beforeOrAfter()
		triggerEvent = triggerEvent(triggerColumns)		// { INSERT | DELETE | UPDATE [ colList	] }
		<ON> tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
		[ refClause = triggerReferencingClause() ]		// REFERENCING OLD/NEW AS 	
		[ <FOR> <EACH> isRow = rowOrStatement() ]
		[ <MODE> <DB2SQL> ]
		//we are not top level statement
		actionNode = proceduralStatement(tokenHolder)
		// the trigger body
	{
	  //Gemstone changes BEGIN
      if (!isRow)
      {
        throw StandardException.newException(SQLState.NOT_IMPLEMENTED,
          "Statement triggers not supported yet");
      }
      //Gemstone changes END
		actionEnd = getToken(0).endOffset;
		actionBegin = tokenHolder[0].beginOffset;

		// No DML in action node for BEFORE triggers.
		if (isBefore.booleanValue() && (actionNode instanceof DMLModStatementNode)) {
				throw StandardException.newException(
					SQLState.LANG_UNSUPPORTED_TRIGGER_STMT,
					((StatementNode) actionNode).statementToString(), "BEFORE");
					}


		// no params in trigger action
 		HasNodeVisitor visitor = new HasNodeVisitor(ParameterNode.class);
		actionNode.accept(visitor);
		if (visitor.hasNode())
		{
			throw StandardException.newException(SQLState.LANG_NO_PARAMS_IN_TRIGGER_ACTION);
		}

		return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.CREATE_TRIGGER_NODE,
								triggerName, 
								tableName,
								ReuseFactory.getInteger(triggerEvent),
								triggerColumns,
								isBefore,	
								isRow,
								Boolean.TRUE, 				// enabled
								refClause,			// referencing clause
								null,// when clause node
								null, 		// when clause text
								ReuseFactory.getInteger(0),
											// when clause begin offset
								actionNode,
								StringUtil.slice(statementSQLText,
									actionBegin,
									actionEnd,false),
								ReuseFactory.getInteger(actionBegin),
								getContextManager());
	}
}

StatementNode
synonymDefinition() throws StandardException :
{
	TableName synonymName;
	TableName targetName;
}
{
    <SYNONYM> synonymName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH) <FOR>
		 targetName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
	{
		checkVersion(DataDictionary.DD_VERSION_DERBY_10_1,
			     "CREATE SYNONYM");

		return  (StatementNode) getNodeFactory().getCreateAliasNode
			(
				synonymName,
				targetName,
				null,
				AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR,
				Boolean.FALSE,
				getContextManager()
			);
	}
}

//Gemstone changes Begin

StatementNode
aliasDefinition() throws StandardException :
{
	TableName aliasName;
	String targetName;
}
{
    <ALIAS> aliasName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH) <FOR>
		 targetName = string()
	{
		checkVersion(DataDictionary.DD_VERSION_DERBY_10_1,
			     "CREATE ALIAS");

		return  (StatementNode) getNodeFactory().getCreateAliasNode
			(
				aliasName,
				targetName,
				null,
				AliasInfo.ALIAS_TYPE_RESULT_PROCESSOR_AS_CHAR,
				Boolean.FALSE,
				getContextManager()
			);
	}
}
//Gemstone changes End

Boolean
beforeOrAfter() :
{}
{
	<NO> <CASCADE> <BEFORE> 
	{
		return Boolean.TRUE;
	}
| 	<AFTER>
	{
		return Boolean.FALSE;
	}
}

int
triggerEvent(ResultColumnList rcl) throws StandardException :
{}
{
	<INSERT> 
	{
		return TriggerDescriptor.TRIGGER_EVENT_INSERT;
	}
| 	<DELETE>
	{
		return TriggerDescriptor.TRIGGER_EVENT_DELETE;
	}
|	<UPDATE> [ <OF> columnNameList(rcl) ]
	{
		return TriggerDescriptor.TRIGGER_EVENT_UPDATE;
	}
}

Boolean
rowOrStatement() :
{
}
{
	token = <ROW> 
	{
		return Boolean.TRUE;
	}
| 	token = <STATEMENT>
	{
		return Boolean.FALSE;
	}
}

Vector
triggerReferencingClause() throws StandardException :
{
	Vector vector = new Vector();
}
{
	<REFERENCING> triggerReferencingExpression(vector) ( triggerReferencingExpression(vector) )*
	{
		return vector;
	}
}

void
triggerReferencingExpression(Vector vector) throws StandardException :
{
	String	identifier;
	boolean isNew = true;
	boolean	isRow = true;
}
{
	(
	  <NEW> [ <ROW> | <TABLE> { isRow = false;} ]
	  |
	  <OLD> {isNew = false;} [ <ROW> | <TABLE> { isRow = false;} ]
	  |
	  <NEW_TABLE> { isRow = false;}
	  |
	  <OLD_TABLE> { isNew = false; isRow = false;}
	)

	<AS> identifier = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	{
		vector.addElement(new TriggerReferencingStruct(isRow, isNew, identifier));
	}
}
 

/*
 * <A NAME="defaultClause">defaultClause</A>
 */
ValueNode
defaultClause(long[] autoIncrementInfo, String columnName) throws StandardException :
{
	ValueNode	value;
	Token		beginToken;
	Token		endToken;
}
{
	[ <WITH> ] beginToken = <_DEFAULT> value = defaultOption(beginToken, autoIncrementInfo, columnName)
	{
		return value;
	}
|
	value = generatedColumnOption(autoIncrementInfo,
		columnName /* GemStoneAddition */)
	{
		return value;
	}
}

/*
 * <A NAME="defaultNullOnlyClause">defaultNullOnlyClause</A>
 */
ValueNode
defaultNullOnlyClause() throws StandardException :
{
}

{
	 <_DEFAULT> <NULL>
	 {
		return (ValueNode) nodeFactory.getNode(
									C_NodeTypes.UNTYPED_NULL_CONSTANT_NODE,
									getContextManager());
	 }
}

/*
 * <A NAME="generatedColumnOption">generatedColumnOption</A>
 */

//ToCleanUp
//A specific class not such long[] should exists for autoIncrementInfo ...

ValueNode
// GemStone changes BEGIN
generatedColumnOption(long[] autoIncrementInfo, String columnName)
throws StandardException :
/* (original code)
generatedColumnOption(long[] autoIncrementInfo) throws StandardException :
*/
// GemStone changes END
{
	ValueNode	value = null;
}
{
    {
	autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_START_INDEX] = 1;
	autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_INC_INDEX] = 1;
	autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_IS_AUTOINCREMENT_INDEX] = 1;
	autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_CREATE_MODIFY] = ColumnDefinitionNode.CREATE_AUTOINCREMENT;
// GemStone changes BEGIN
	autoIncrementInfo[QueryTreeNode.HAS_AUTOINCREMENT_INC] = 0;
// GemStone changes END
    }

	<GENERATED> 
	(
	 <ALWAYS>  {
		value = null;
	}|
	 <BY> <_DEFAULT>
	 {
		checkVersion(DataDictionary.DD_VERSION_DERBY_10_1,
			     "GENERATED BY DEFAULT");
  		value = (ValueNode) nodeFactory.getNode(C_NodeTypes.DEFAULT_NODE,
  							getContextManager()) ;
  		// GemStone changes BEGIN
  		autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_IS_GENERATED_BY_DEFAULT] = 1;
  	    // GemStone changes END
  	 }
	)
	<AS> <IDENTITY> [<LEFT_PAREN> autoIncrementBeginEnd(autoIncrementInfo) <RIGHT_PAREN>]
    {
		return value;
    }
}

/*
 * <A NAME="autoIncrementBeginEnd">autoIncrementBeginEnd</A>
 */
void 
autoIncrementBeginEnd(long[] autoIncrementInfo) throws StandardException :
{
	long		autoIncrementInitial = 1;
	long		autoIncrementIncrement = 1;
}
{

        <INCREMENT> <BY> autoIncrementIncrement = exactNumber()
    {
		autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_INC_INDEX] = autoIncrementIncrement;
		autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_CREATE_MODIFY] = ColumnDefinitionNode.CREATE_AUTOINCREMENT;
// GemStone changes BEGIN
		autoIncrementInfo[QueryTreeNode.HAS_AUTOINCREMENT_INC] = 1;
		// GemFireXD does not currently support these clauses on a GENERATED ALWAYS column
		if (autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_IS_GENERATED_BY_DEFAULT] == 0)
    	{
        	throw StandardException.newException(SQLState.NOT_IMPLEMENTED, "INCREMENT BY/START WITH not supported on GENERATED ALWAYS columns");
    	}
		
// GemStone changes END
		return;
    }
|
		<START> <WITH> autoIncrementInitial = exactNumber() [<COMMA> <INCREMENT> <BY> autoIncrementIncrement = exactNumber()
// GemStone changes BEGIN
	{
		autoIncrementInfo[QueryTreeNode.HAS_AUTOINCREMENT_INC] = 1;
	}
// GemStone changes END
		]
    {
        // GemFireXD does not currently support these clauses on a GENERATED ALWAYS column
    	if (autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_IS_GENERATED_BY_DEFAULT] == 0)
    	{
        	throw StandardException.newException(SQLState.NOT_IMPLEMENTED, "INCREMENT BY/START WITH not supported on GENERATED ALWAYS columns");
    	}
		autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_START_INDEX] = autoIncrementInitial;
		autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_INC_INDEX] = autoIncrementIncrement;
		autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_CREATE_MODIFY] = ColumnDefinitionNode.CREATE_AUTOINCREMENT;
		return;
    }
}

/*
 * <A NAME="defaultOption">defaultOption</A>
 */
ValueNode
defaultOption(Token beginToken, long[] autoIncrementInfo,
	String columnName) throws StandardException :
{
	Token		endToken;
	Token		errorTok = null;
	Token		initialTok = null;
	ValueNode	value;
}
{
	//Look ahead required to tell NULL from a class name which starts with
	// NULL (e.g., NULL::)
	LOOKAHEAD( {getToken(1).kind == NULL && !(getToken(2).kind == PERIOD ||
			getToken(2).kind == DOUBLE_COLON)})
	<NULL>
	{
		return (ValueNode) nodeFactory.getNode(
									C_NodeTypes.UNTYPED_NULL_CONSTANT_NODE,
									getContextManager());
	}
|
	value = DB2DefaultOption(columnName)
	{
		endToken = getToken(0);
		value.setBeginOffset( beginToken.beginOffset );
		value.setEndOffset( endToken.endOffset );
		value = (ValueNode) nodeFactory.getNode(
								C_NodeTypes.DEFAULT_NODE,
								value,
								StringUtil.slice(statementSQLText,
									beginToken.beginOffset + 7,
									endToken.endOffset,true),
								getContextManager()
							);
		return value;
	}
}

/*
 * <A NAME="DB2DefaultOption">DB2DefaultOption</A>
 */
ValueNode
DB2DefaultOption(String columnName) throws StandardException :
{
	ValueNode	value;
}
{
	// DB2 spec says default can only be one of the
	// following: <constant>, <datetime-special-register> (ex.
	// "current time"), CURRENT SCHEMA, USER, NULL, or
	// <cast-function>.  We currently support all of these
	// except the 'blob' function that is part of the DB2 valid
	// <cast-function> grammar.  See beetle 5281 for plans
	// support 'blob' function in future.

	LOOKAHEAD({getToken(2).kind == SCHEMA || getToken(2).kind == SQLID}) 
	<CURRENT> (<SCHEMA> | <SQLID>)
	{
		return (ValueNode) nodeFactory.getNode(
						C_NodeTypes.CURRENT_SCHEMA_NODE,
						getContextManager());
	}
|
	/* Revert DB2 restriction: DERBY-3013. Accept standard SQL CURRENT_USER,
	 * SESSION_USER in addition to USER.
	 */
	value = userNode()
	{
		return value;
	}
|
	value = currentRoleNode()
	{
		return value;
	}
|
	LOOKAHEAD({
				getToken(1).kind == DATE ||
                getToken(1).kind == TIME ||
                getToken(1).kind == TIMESTAMP
			})
	value = miscBuiltins()
	{ // these functions are allowed as valid <cast-function> defaults.
	  // Once "BLOB" is allowed as a cast-function (5281), a case should be
	  // added for that, as well.
		return value;
	}
|
	LOOKAHEAD( {getToken(2).kind == LEFT_PAREN ||
		       (getToken(4).kind == LEFT_PAREN && 
		        getToken(2).kind != COMMA)} ) 
		// Check against comma: see Derby-331 
		// Before adding this, the following was erroneously
		// flagged as invalid: 
		//	   create table foo(.., b int default 0, unique (a))
	value = miscBuiltins()
	{
		// If we have a function (as indicated by an open paren,
		// which can be either the 2nd token (w/ normal function name)
		// or the 4th token (w/ qualified function name)), then
		// it's not valid.  Catch it here and throw an "invalid
		// default" error (42894) instead of letting it go as
		// a syntax error (this matches DB2 UDB behavior).
		throw StandardException.newException(
			SQLState.LANG_DB2_INVALID_DEFAULT_VALUE,
			columnName);
	}
|
	value = datetimeValueFunction()
	{
		return value;
	}
|
	// Only (valid) thing left is literals (i.e. actual constants).
	value = literal()
	{
		return value;
	}

}

//GemStone changes BEGIN
/*
* <A NAME="optimizedliteral">optimizedliteral</A>
*/
// [sb] indirection added to wrap constants with parameterized consts. 
ValueNode
optimizedliteral() throws StandardException :
{
  ValueNode constantNode = null;
 Token beginToken;
  Token endToken;
}
{
 { beginToken = getToken(1); }  constantNode = literal()  { endToken = getToken(0); }
  {
      CompilerContext cc = getCompilerContext();
      if (!cc.isOptimizeLiteralAllowed()) {
        return constantNode;
      }

      if (!cc.canOptimizeLiteral()) {
        return constantNode;
      }

      if (Misc.getMemStore().getDatabase()
          .disableStatementOptimizationToGenericPlan()) {
        return constantNode;
      }
      ConstantNode origNode = (ConstantNode)constantNode;
      origNode.setBeginOffset(beginToken.beginOffset);
      origNode.setEndOffset(endToken.endOffset+1);
      //temporarily disable following types untill handled properly.
      switch(beginToken.kind) {
        case HEX_STRING:
          return constantNode;
      }

      Integer constantInteger = ReuseFactory.getInteger(constantNumber);
     
     constantNode = (ValueNode) nodeFactory.getNode(
                           C_NodeTypes.PARAMETERIZED_CONSTANT_NODE,
                           constantInteger,
                           constantNode,
                           getContextManager());
                           
      constantNode.setBeginOffset( beginToken.beginOffset );
      constantNode.setEndOffset  ( endToken.endOffset+1 );
    
      if(this.subqueryParamCount != null && !this.subqueryParamCount.isEmpty())
      {
         Iterator<List<Integer>> itr = this.subqueryParamCount.iterator();
         while( itr.hasNext()) {                   
           itr.next().add(constantInteger);
        }
        
        Iterator<List<ConstantNode>> itr1 = this.subqueryParams.iterator();
         while( itr1.hasNext()) {                   
           itr1.next().add(origNode);
        }
                  
      }
      parameterList.addElement(constantNode);
      constantNumber++;

     return constantNode;
  }
}
//GemStone changes END


/*
 * <A NAME="literal">literal</A>
 */
ValueNode
literal() throws StandardException :
{
	String	sign = "";
	Token	tok;
	String  datetimeString;
	String  bitString;
	ValueNode		constantNode;
}
{
	[ sign = sign() ] constantNode = numericLiteral(sign)
	{
		return constantNode;
	}
|
	constantNode = stringLiteral()
	{
		return	constantNode;
	}
|
	constantNode = hexLiteral()
	{
		return	constantNode;
	}
|
	constantNode = dateTimeLiteral()
	{
		return constantNode;
	}
|
	tok = booleanLiteral()
	{
		// checkInternalFeature(tok.image);
		return (ValueNode) nodeFactory.getNode(
									C_NodeTypes.BOOLEAN_CONSTANT_NODE,
									StringUtil.SQLEqualsIgnoreCase(tok.image, "true") ?
										Boolean.TRUE : Boolean.FALSE,
 									getContextManager());
	}
/*
	JDBC and ODBC do not support the interval type, so let's not do it
	ourselves for now.
|
	tok = <INTERVAL_LITERAL>
	{
		return nodeFactory.getIntervalNode(tok.image,
					getTypeCompilationFactory(),
					getContextManager());
	}
*/
}


/*
 * <A NAME="int">intLiteral</A>
 */
NumericConstantNode
intLiteral() throws StandardException :
{
    NumericConstantNode result;
}
{
    result = integral(true)
    {
        return result;
    }
}

/*
 * <A NAME="int">integral</A>
 */
NumericConstantNode integral(boolean intsOnly) throws StandardException :
{
    Token   tok;
    String sign = null;
    NumericConstantNode result;
}
{
    [ sign = sign() ] tok = <EXACT_NUMERIC>
    {
        /*
        ** The various java parse utilities can't handle leading +,
        ** so only concatenate leading -.
        */

        String num = tok.image;

        if (sign != null && sign.equals("-"))
            num = sign.concat(num);

        try {
            result = getNumericNode(num, intsOnly);
        } catch (NumberFormatException e) {
            throw StandardException.newException(
                SQLState.LANG_INTEGER_LITERAL_EXPECTED);
        }

        return result;
    }
}



/*
 * <A NAME="numericLiteral">numericLiteral</A>
 */
ValueNode
numericLiteral(String sign) throws StandardException :
{
	Token	tok;
}
{
	tok = <EXACT_NUMERIC>
	{
		/*
		** The various java parse utilities can't handle leading +,
		** so only concatenate leading -.
		*/

		String num = tok.image;

		if (sign.equals("-"))
			num = sign.concat(num);

		return getNumericNode(num, false);
	}
|
	tok = <APPROXIMATE_NUMERIC>
	{
		StringBuilder doubleImage;
		String doubleString;
		int ePosn, dotPosn; // Position of letter e and '.' in value
		Double		doubleValue;
		
		doubleImage = new StringBuilder(sign);
		doubleImage.append(tok.image);
		doubleString = doubleImage.toString();

		ePosn = doubleString.indexOf('E');
		if (ePosn == -1)
			ePosn = doubleString.indexOf('e');
		if (SanityManager.DEBUG)
			SanityManager.ASSERT(ePosn != -1, "no E or e in approximate numeric");

		// there is a limit on the length of a floatingpoint literal in DB2
		if (doubleString.length() > Limits.DB2_MAX_FLOATINGPOINT_LITERAL_LENGTH)
			throw StandardException.newException(SQLState.LANG_DB2_TOO_LONG_FLOATING_POINT_LITERAL, doubleString, TypeId.DOUBLE_NAME);
		// if there is no '.' before the e, put one in
		dotPosn = doubleString.substring(0,ePosn).indexOf('.');
		if (dotPosn == -1) {
			doubleImage.insert(ePosn,'.');
			doubleString = doubleImage.toString();
			ePosn++;
		}

		try
		{
			doubleValue = Double.valueOf(doubleString);

		}
		catch (NumberFormatException nfe)
		{
			throw StandardException.newException(SQLState.LANG_FORMAT_EXCEPTION, TypeId.DOUBLE_NAME, (String)null);
		}

		double dv = doubleValue.doubleValue();

		// When the value is 0 it's possible rounded, try to detect it by checking if the mantissa is 0.0
		//   "proof of correctness": any nonzero value (mantissa) with less than 30 characters will not be
		//                           rounded to 0.0 by a float/real. This correctly detects the case when
		//                           the radix/exponent being "too small" (1e-900) giving a value rounded to zero.
		if ( (dv == 0.0d) && (Double.parseDouble(doubleString.substring(0, ePosn-1)) != 0.0d) )
		{
			throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, TypeId.DOUBLE_NAME);
		}

		if (Double.isNaN(dv) || Double.isInfinite(dv))
			throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, TypeId.DOUBLE_NAME);

		return (ValueNode) nodeFactory.getNode(
									C_NodeTypes.DOUBLE_CONSTANT_NODE,
									doubleValue,
									getContextManager());
	}
}

/*
 * <A NAME="dateTimeLiteral">dateTimeLiteral</A>
 */
ValueNode
dateTimeLiteral() throws StandardException :
{
	ValueNode	constantNode;
}
{
// RESOLVE: There is an incompatibility between Derby and DB2 here. The DB2 SQL parser does not recognize
// JDBC date/time escapes. They are handled in a JDBC pre-processor. However embedded Derby does not have
// a separate pre-processor. JDBC date/time escapes are handled by the Derby SQL parser. This will only
// be visible if Derby is accessed through a non-JDBC pathway. (ODBC?) In that case Derby will allow
// the JDBC date/time escape while DB2 will not.
	(
		( <LEFT_BRACE> constantNode = escapedDateTimeLiteral() <RIGHT_BRACE> )
	)
	{
		return constantNode;
	}
}

/*
 * <A NAME="escapedDateTimeLiteral">escapedDateTimeLiteral</A>
 */
ValueNode
escapedDateTimeLiteral() throws StandardException :
{
	ValueNode constantNode;
}
{
	<D> constantNode = bareDateLiteral()
	{
		return constantNode;
	}
|
	<T> constantNode = bareTimeLiteral()
	{
		return constantNode;
	}
|
	<TS> constantNode = bareTimestampLiteral()
	{
		return constantNode;
	}
}

/*
 * <A NAME="bareDateLiteral">bareDateLiteral</A>
 */
ValueNode
bareDateLiteral() throws StandardException :
{
	String dateString;
}
{
	dateString = string()
	{
		return (ValueNode) nodeFactory.getNode(
						C_NodeTypes.USERTYPE_CONSTANT_NODE,
						getLanguageConnectionContext().getDataValueFactory().getDateValue(dateString, true),
						getContextManager());
	}
}

/*
 * <A NAME="bareTimeLiteral">bareTimeLiteral</A>
 */
ValueNode
bareTimeLiteral() throws StandardException :
{
	String timeString;
}
{
	timeString = string()
	{
		return (ValueNode) nodeFactory.getNode(
						C_NodeTypes.USERTYPE_CONSTANT_NODE,
						getLanguageConnectionContext().getDataValueFactory().getTimeValue(timeString, true),
						getContextManager());
	}
}

/*
 * <A NAME="bareTimestampLiteral">bareTimestampLiteral</A>
 */
ValueNode
bareTimestampLiteral() throws StandardException :
{
	String timestampString;
}
{
	timestampString = string()
	{
		return (ValueNode) nodeFactory.getNode(
						C_NodeTypes.USERTYPE_CONSTANT_NODE,
						getLanguageConnectionContext().getDataValueFactory().getTimestampValue(timestampString, true),
						getContextManager());
	}
}

/*
 * <A NAME="string">string</A>
 */
String
string() throws StandardException :
{
	Token	tok;
}
{
	tok = <STRING>
	{
		verifyImageLength(tok.image);
		/* Trim off the leading and trailing ', and compress all '' to ' */
		//GemStone changes BEGIN
        return compressQuotes(tok.image,
                              SINGLEQUOTES);
		//originally return compressQuotes(tok.image.substring(1, tok.image.length() - 1),
		//					  SINGLEQUOTES);
        //GemStone changes END
	}
}

/*
 * <A NAME="stringLiteral">stringLiteral</A>
 */
CharConstantNode
stringLiteral() throws StandardException :
{
	Token	tok;
	String	string;
}
{
	tok = <STRING>
	{
		//there is a maximum limit on the length of the string
		if (tok.image.length() > Limits.DB2_MAX_CHARACTER_LITERAL_LENGTH)//-2 is for the beginning and ending quote
			throw StandardException.newException(SQLState.LANG_DB2_STRING_CONSTANT_TOO_LONG, StringUtil.formatForPrint(tok.image));
        //GemStone changes BEGIN
		string = compressQuotes(tok.image, SINGLEQUOTES); //originally tok.image.substring(1, tok.image.length() - 1), SINGLEQUOTES);
        //GemStone changes END
		/* Trim quotes from string. */
		return (CharConstantNode) nodeFactory.getNode(
								C_NodeTypes.CHAR_CONSTANT_NODE,
								string,
								getContextManager());
	}
}

/*
 * <A NAME="hexLiteral">hexLiteral</A>
 */
ValueNode
hexLiteral() throws StandardException :
{
	Token	tok;
}
{
	tok = <HEX_STRING>
	{
		String hexLiteral = tok.image;

		//there is a maximum limit on the length of the hex constant
		if (hexLiteral.length()-3 > Limits.DB2_MAX_HEX_LITERAL_LENGTH)//-3 is for X' at the beginning and ' at the end
			throw StandardException.newException(SQLState.LANG_DB2_STRING_CONSTANT_TOO_LONG, StringUtil.formatForPrint(hexLiteral));
		if ((hexLiteral.length()-3)%2 == 1)
			throw StandardException.newException(SQLState.LANG_DB2_INVALID_HEXADECIMAL_CONSTANT, StringUtil.formatForPrint(hexLiteral));

		int bitLength = ((hexLiteral.length() - 3) / 2);
		return (ValueNode)
				nodeFactory.getNode(C_NodeTypes.VARBIT_CONSTANT_NODE,
									hexLiteral.substring(2, hexLiteral.length() - 1), ReuseFactory.getInteger(bitLength),
									getContextManager());
	}
}


TableName
constraintNameDefinition() throws StandardException :
{
	TableName constraintName;
}
{
	/* changed constraintName() to qualifiedName() for compaction */
	<CONSTRAINT> constraintName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
	{
		return constraintName;
	}
}

/*
 * DB2 requires column check constraints to refer to only that column. Derby
 * doesn't care if check constraints are column level or table level. For DB2 compatibility
 * check that column check constraints only refer to that column.
 */
ConstraintDefinitionNode
checkConstraintDefinition(TableName constraintName, String columnName)
							throws StandardException :
{  
	Token		beginToken;
	Token		endToken;
	ValueNode	value;
	ResultColumnList rclList = null;
}
{
	/* valueExpression() was searchCondition() */
	<CHECK>  beginToken = 
		<LEFT_PAREN> value = valueExpression(false) endToken = <RIGHT_PAREN>
	{
		if (columnName != null)
		{
			/* Column check constraint */
			rclList = (ResultColumnList) nodeFactory.getNode(
									C_NodeTypes.RESULT_COLUMN_LIST,
									getContextManager());
			rclList.addElement((ResultColumn) nodeFactory.getNode(
									C_NodeTypes.RESULT_COLUMN,
									columnName,
									null,
									getContextManager()));
		}

		value.setBeginOffset( beginToken.beginOffset );
		value.setEndOffset( endToken.endOffset );
		return (ConstraintDefinitionNode) nodeFactory.getNode(
					C_NodeTypes.CONSTRAINT_DEFINITION_NODE,
					constraintName,
					ReuseFactory.getInteger(DataDictionary.CHECK_CONSTRAINT),
					rclList,
					null,
					value,
					StringUtil.slice(statementSQLText,
						beginToken.beginOffset,
						endToken.endOffset,true),
					getContextManager()
					);
	}
}


/*
 * <A NAME="spsRenameStatement">spsRenameStatement</A>
 */
StatementNode
spsRenameStatement() throws StandardException :
{
	StatementNode qtn;
}
{
	<RENAME> (
		qtn = renameTableStatement() |
		qtn = renameIndexStatement() |
		qtn = renameColumnStatement()
		)
	{
		return qtn;
	}
}

/*
 * <A NAME="renameTableStatement">renameTableStatement</A>
 */
StatementNode
renameTableStatement() throws StandardException :
{
	StatementNode qtn;
	TableName tableName;
	String newTableName;
}
{
	<TABLE> tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH) <TO> newTableName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	{
		return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.RENAME_NODE,
								tableName,
								null,
								newTableName,
								Boolean.FALSE,
								ReuseFactory.getInteger(StatementType.RENAME_TABLE),
								getContextManager());
	}
}

/*
 * <A NAME="renameIndexStatement">renameIndexStatement</A>
 */
 // GemStone changes BEGIN
StatementNode
renameIndexStatement() throws StandardException :
{
	TableName oldIndexName;
	String  newIndexName;
}
{
	<INDEX> oldIndexName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH) <TO> newIndexName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	{
		StatementNode qtn = (StatementNode) nodeFactory.getNode(
								C_NodeTypes.RENAME_NODE,
								null,
								oldIndexName,
								newIndexName,
								Boolean.FALSE,
ReuseFactory.getInteger(StatementType.RENAME_INDEX),
								getContextManager());

		return qtn;

	}
}
// GemStone changes END
StatementNode
renameColumnStatement() throws StandardException :
{
	String newColumnName;
        ColumnReference oldColumnReference;
}
{
	<COLUMN> oldColumnReference = columnReference()
		<TO> newColumnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	{
		if (oldColumnReference.getTableNameNode() == null)
			throw StandardException.newException(
				SQLState.LANG_OBJECT_DOES_NOT_EXIST,
				"RENAME COLUMN",
				oldColumnReference.getColumnName());
		return (StatementNode) nodeFactory.getNode(
			C_NodeTypes.RENAME_NODE,
			oldColumnReference.getTableNameNode(),
			oldColumnReference.getColumnName(),
			newColumnName,
			Boolean.FALSE,
			ReuseFactory.getInteger(StatementType.RENAME_COLUMN),
				getContextManager());
	}
}


StatementNode
lockStatement() throws StandardException :
{
	Boolean						exclusiveMode;
	TableName					tableName;
}
{
	<LOCK> <TABLE> tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH) <IN> exclusiveMode = lockMode() <MODE>
	{
		return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.LOCK_TABLE_NODE,
								tableName,
								exclusiveMode,
								getContextManager());
	}
}

Boolean
lockMode() :
{
}
{
	<EXCLUSIVE>
	{
		return Boolean.TRUE;
	}
|
	<SHARE>
	{
		return Boolean.FALSE;
	}
}

StatementNode
execStatement() throws StandardException :
{
	TableName	stmtName;
}
{
	<EXECUTE> <STATEMENT> stmtName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH) 
	{
		return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.EXEC_SPS_NODE,
								stmtName,
								getContextManager());
	}
}

// GemStone changes BEGIN
StatementNode
explainStatement() throws StandardException :
{
   //StatementNode userQuery = null;
  String userQuery = null;
  Token explainToken = null;
  XPLAINUtil.XMLForms xmlform = XPLAINUtil.XMLForms.none;
  boolean withQueryResult = false;
  ArrayList<ArrayList<Object>> listOfValueList = null;
  CompilerContext cc = getCompilerContext();
  int parameterOffset = -1;
  CharConstantNode embedXSLFileName = null;
}
{
	<EXPLAIN> 
	{
		cc.setPreparedStatement();
		explainToken = token;
	}
   
	[       
		LOOKAHEAD( { getToken(1).kind == AS && (getToken(2).kind == XML || getToken(2).kind == XMLFRAGMENTS) } )
		<AS>
		( 
			<XML> 
			{
			   explainToken = token;
			   xmlform = XPLAINUtil.XMLForms.asXML;
			}
			
	        [
	           LOOKAHEAD( { getToken(1).kind == EMBED && getToken(2).kind == STRING } )
			   <EMBED> embedXSLFileName = stringLiteral()
			   {
			     explainToken = token;
			   }
			]
		|
			<XMLFRAGMENTS>
			{
				explainToken = token;
				xmlform = XPLAINUtil.XMLForms.asXMLFragments;
			}
		) 
	]
	
   (
		preparableSQLDataStatement()
		[ 
			<PARAMETER>
			{
			  parameterOffset = token.beginOffset;
			} 
			listOfValueList = multipleValueListSpecification() 
		]

    |
       <UUID_LITERAL>  
       {
         userQuery = token.image.trim();
       }
   )
   
   {
       int beginIdx = explainToken.endOffset + 1;
       
       if (parameterOffset > 0) {
          userQuery = statementSQLText.substring(beginIdx, parameterOffset);
       }
       else {
          userQuery = statementSQLText.substring(beginIdx);
       }
       
       return (StatementNode) nodeFactory.getNode(
                                                  C_NodeTypes.EXPLAIN_NODE,
                                                  userQuery,
                                                  listOfValueList,
                                                  xmlform,
                                                  embedXSLFileName,
                                                  getContextManager());
   }
}

ArrayList<ArrayList<Object>>
multipleValueListSpecification() throws StandardException :
{
  ArrayList<Object> valueList;
  ArrayList listOfValueList;
}
{
      <VALUES> valueList = singleValueListSpecification()
      {
        listOfValueList = new ArrayList();
        listOfValueList.add(valueList);
      }
      [
		<COMMA> 
		( 
			valueList = singleValueListSpecification() 
			{
			  listOfValueList.add(valueList);
			}
		)+
	  ]
      
      {
        return listOfValueList;
      }
}

ArrayList<Object>
singleValueListSpecification() throws StandardException :
{
  ValueNode value;
  ArrayList<Object> valueList = new ArrayList<Object>();
}
{
         <LEFT_PAREN>
            value = additiveExpression(null, 0, false) 
            {
              Object o = value.getConstantValueAsObject();
              if (o == null) {
                 StandardException.newException(SQLState.LANG_NO_NON_CONSTANT_PARAMETER_ALLOWED, value);
              }
              valueList.add(o);
            }
         
            ( 
				<COMMA> additiveExpression(null, 0, false) 
	            {
	              o = value.getConstantValueAsObject();
	              if (o == null) {
	                 StandardException.newException(SQLState.LANG_NO_NON_CONSTANT_PARAMETER_ALLOWED, value);
	              }
	              valueList.add(o);
	            }
            )* 
         <RIGHT_PAREN>
         {
           return valueList;
         } 
}

// GemStone changes END

TransactionStatementNode
setIsolationStatement() throws StandardException :
{
	TransactionStatementNode tranNode;
}
{
	setIsolationHeader() [ ( <EQUALS_OPERATOR> | <TO> ) ] tranNode = transactionMode()
	{
		return tranNode;
	}
}

void
setIsolationHeader() throws StandardException :
{}
{
	<ISOLATION>
|
        LOOKAHEAD( { getToken(1).kind == CURRENT && getToken(2).kind == ISOLATION } )
	<CURRENT> <ISOLATION>
}


TransactionStatementNode
transactionMode() throws StandardException :
{
	int isolationLevel;
}
{
	isolationLevel = isolationLevelDB2OrReset() 
	{
		return (TransactionStatementNode) nodeFactory.getNode(
								C_NodeTypes.SET_TRANSACTION_ISOLATION_NODE,
								ReuseFactory.getInteger(isolationLevel),
								getContextManager());
	}
}

int
isolationLevelDB2OrReset() :
{
	int isolationLevel;
}
{
        (
                <RESET> { return ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL; }
                | isolationLevel = isolationLevelDB2() { return isolationLevel; }
        )
}

int
isolationLevelDB2() :
{
        int isolationLevel;
}
{
	(
                isolationLevel = isolationLevelDB2Abbrev() { return isolationLevel; }
// GemStone changes BEGIN
                // interpret REPEATABLE READ as SQL REPEATABLE_READ
                | <SERIALIZABLE>
                        { return ExecutionContext.SERIALIZABLE_ISOLATION_LEVEL; }
                | <REPEATABLE> <READ>
                        { return ExecutionContext.REPEATABLE_READ_ISOLATION_LEVEL; }
                /* (original code)
                | ( ( <REPEATABLE> <READ> ) | <SERIALIZABLE> )
                        { return ExecutionContext.SERIALIZABLE_ISOLATION_LEVEL; }
                */
// GemStone changes END
		| <CURSOR> <STABILITY>
                        { return ExecutionContext.READ_COMMITTED_ISOLATION_LEVEL; }

		| <DIRTY> <READ>
                        { return ExecutionContext.READ_UNCOMMITTED_ISOLATION_LEVEL; }

		|
                        LOOKAHEAD( { getToken(1).kind == READ && getToken(2).kind == COMMITTED } )
                        <READ> <COMMITTED>
                        { return ExecutionContext.READ_COMMITTED_ISOLATION_LEVEL; }

		|
                        LOOKAHEAD( { getToken(1).kind == READ && getToken(2).kind == UNCOMMITTED } )
                        <READ> <UNCOMMITTED>
                        { return ExecutionContext.READ_UNCOMMITTED_ISOLATION_LEVEL; }
	)
}

int
isolationLevelDB2Abbrev() :
{
}
{
	(
		<RR>
                        { return ExecutionContext.SERIALIZABLE_ISOLATION_LEVEL; }

		| <RS> { return ExecutionContext.REPEATABLE_READ_ISOLATION_LEVEL; }

		| <CS>
                        { return ExecutionContext.READ_COMMITTED_ISOLATION_LEVEL; }

		| <UR>
                        { return ExecutionContext.READ_UNCOMMITTED_ISOLATION_LEVEL; }
	)
}


int
isolationLevel() :
{
	int isolationLevel;
}
{
	<ISOLATION> <LEVEL> isolationLevel = levelOfIsolation()
	{
		return isolationLevel;
	}
}

int
levelOfIsolation() :
{
}
{
	<READ>
	{
		return levelOfIsolationRead();
	}
| 
    <REPEATABLE> <READ>
    {
		return ExecutionContext.REPEATABLE_READ_ISOLATION_LEVEL;
    }
|
	<SERIALIZABLE>
	{
		return ExecutionContext.SERIALIZABLE_ISOLATION_LEVEL;
	}
}

int
levelOfIsolationRead() :
{
}
{
	<UNCOMMITTED> 
	{
		return ExecutionContext.READ_UNCOMMITTED_ISOLATION_LEVEL;
	}
|
	<COMMITTED> 
	{
		return ExecutionContext.READ_COMMITTED_ISOLATION_LEVEL;
	}
}


/*
 * <A NAME="simpleValueSpecification">simpleValueSpecification</A>
 */
ValueNode
simpleValueSpecification() throws StandardException :
{
	ValueNode	value;
}
{
	value = literal()
	{
		return value;
	}
}

// GemStone changes BEGIN
int
simpleValueSpecification_int() throws StandardException :
{
	ValueNode	value;
}
{
	value = intLiteral()
	{
	    // Negative numbers are always illegal for all tokens that require int values
	    // But sometimes zero is legal
	    // Throw errors here for negative numbers
	    if (getIntValue(value) < 0)
	    {
	       throw StandardException.newException(SQLState.LANG_INVALID_COLUMN_LENGTH,
                "Value "+getIntValue(value)+" is negative");
	    }
		return getIntValue(value);
	}
}

long
simpleValueSpecification_long() throws StandardException :
{
	ValueNode	value;
}
{
	value = integral(false)
	{
	    // A negative number is valid for this value
	    // Currently only used for RECOVERYDELAY and STARTUPRECOVERYDELAY
	    // in CREATE TABLE partitioning. If another value needs this
	    // and cannot take negative numbers, please make another function
		return getLongValue(value);
	}
}
// GemStone changes END

/*
 * <A NAME="setRoleStatement">setRoleStatement</A>
 */
StatementNode
setRoleStatement() throws StandardException :
{
	StatementNode role;
}
{
	/*
	 * SET ROLE { <rolename> | NONE | ? }
	 *
	 * Can also be prepared with ? argument, cf. SET SCHEMA.
	 */
	<ROLE> role = setRoleSpecification()
	{
		if (parameterList != null && parameterList.size() > 0)
		{
			setUpAndLinkParameters();
			// set the type of parameter node, it should be a varchar
			// max Limits.MAX_IDENTIFIER_LENGTH - non nullable
			ParameterNode p = (ParameterNode)parameterList.elementAt(0);
			p.setType(new DataTypeDescriptor
					  (TypeId.getBuiltInTypeId(Types.VARCHAR),
					   false,
					   Limits.MAX_IDENTIFIER_LENGTH));
		}
		return role;
	}
}


/*
 * <A NAME="setRoleSpecification">setRoleSpecification</A>
 */
StatementNode
setRoleSpecification() throws StandardException :
{
	String roleName = null;
	boolean quiesceCompilerUnreachableStatement = true;
	if (quiesceCompilerUnreachableStatement) {
		throw StandardException.newException
			(SQLState.NOT_IMPLEMENTED, "ROLES");
	}
        checkVersion( DataDictionary.DD_VERSION_DERBY_10_4, "ROLES");
        checkSqlStandardAccess("SET ROLE");
}
{
	<NONE>
	{
		return (StatementNode) nodeFactory.getNode
			(C_NodeTypes.SET_ROLE_NODE,
			 roleName,
			 null,
			 getContextManager());
	}
|
	roleName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	{
		return (StatementNode) nodeFactory.getNode
			(C_NodeTypes.SET_ROLE_NODE,
			 roleName,
			 null,
			 getContextManager());
	}
|
	dynamicParameterSpecification()
	{
		return (StatementNode) nodeFactory.getNode
			(C_NodeTypes.SET_ROLE_NODE,
			 null,
			 ReuseFactory.getInteger(StatementType.SET_ROLE_DYNAMIC),
			 getContextManager());
	}
|
	roleName = string()
	{
		checkIdentifierLengthLimit(roleName, Limits.MAX_IDENTIFIER_LENGTH);
		return (StatementNode) nodeFactory.getNode(
			C_NodeTypes.SET_ROLE_NODE,
			roleName,
			null,
			getContextManager());
	}
}


StatementNode
setSchemaStatement() throws StandardException :
{
	StatementNode setSchema;
}
{
	setSchemaHeader() [<EQUALS_OPERATOR>] setSchema = setSchemaValues()
	{
		if (parameterList != null && parameterList.size() > 0)
		{
			setUpAndLinkParameters();
			// set the type of parameter node, it should be a varchar max Limits.MAX_IDENTIFIER_LENGTH - non nullable
			ParameterNode p = (ParameterNode)parameterList.elementAt(0);
			p.setType(new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.VARCHAR), false, Limits.MAX_IDENTIFIER_LENGTH));
		}
		return setSchema;
	}
}

void 
setSchemaHeader() throws StandardException :
{}
{
	<SCHEMA>
|
        LOOKAHEAD( { getToken(1).kind == CURRENT && ( getToken(2).kind == SCHEMA ||  getToken(2).kind == SQLID ) } )
	<CURRENT> ( <SCHEMA>  | <SQLID> )
}

StatementNode
setSchemaValues() throws StandardException :
{
	String schemaName;
}
{
	schemaName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	{
		return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.SET_SCHEMA_NODE,
								schemaName,
								null,
								getContextManager());
	}
|
	<_DEFAULT>
	{
		return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.SET_SCHEMA_NODE,
								"DEFAULT",
								null,
								getContextManager());
	}
|
	<USER>
	{
		return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.SET_SCHEMA_NODE,
								null,
								ReuseFactory.getInteger(StatementType.SET_SCHEMA_USER),
								getContextManager());
	}
|   dynamicParameterSpecification()
	{
		return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.SET_SCHEMA_NODE,
								null,
								ReuseFactory.getInteger(StatementType.SET_SCHEMA_DYNAMIC),
								getContextManager());
	}
|	schemaName = string()
	{
		/* Max length for schema name is Limits.MAX_IDENTIFIER_LENGTH */
		checkIdentifierLengthLimit(schemaName, Limits.MAX_IDENTIFIER_LENGTH);
		return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.SET_SCHEMA_NODE,
								schemaName,
								null,
								getContextManager());
	}
}



// Set the locale for messages coming from the database system. This
// is for support only, so we can get messages in our preferred language
// (usually English). I didn't want to create all the execution wiring
// to do this, so this command executes in the parser
StatementNode
setMessageLocaleStatement() throws StandardException :
{
	String messageLocale;
}
{
	<MESSAGE_LOCALE> messageLocale = string()
	{
		getContextManager().setMessageLocale(messageLocale);

		return (StatementNode) nodeFactory.getNode(
											C_NodeTypes.NOP_STATEMENT_NODE,
											getContextManager());
	}
}

/*
 * <A NAME="valueSpecification">valueSpecification</A>
 */
ValueNode
valueSpecification() throws StandardException :
{
	ValueNode	   value;
	ValueNode	   leftExpression;
	ValueNode	   rightExpression;
}
{
  //GemStone changes BEGIN
	/*originally value = literal() */
	value = optimizedliteral()
  //GemStone changes END
	{
		return value;
	}
|
	value = generalValueSpecification()
	{
		return value;
	}
|
	<NULLIF> <LEFT_PAREN> leftExpression = additiveExpression(null, 0, false) <COMMA> rightExpression = additiveExpression(null, 0, false) <RIGHT_PAREN>
	{
		// "NULLIF(L, R)" is the same as "L=R ? untyped NULL : L"
		// An impl assumption here is that Derby can promote CHAR to any comparable datatypes such as numeric
		ContextManager cm = getContextManager();
		ValueNodeList thenElseList = (ValueNodeList) nodeFactory.getNode(C_NodeTypes.VALUE_NODE_LIST, cm);

		//Use untyped null for then clause at this point. At the bind time, we will cast it to the datatype of L 
		thenElseList.addElement((ValueNode) nodeFactory.getNode(
									C_NodeTypes.UNTYPED_NULL_CONSTANT_NODE,
									cm));
		thenElseList.addElement(leftExpression);

		return (ValueNode) nodeFactory.getNode(
											C_NodeTypes.CONDITIONAL_NODE,
											(ValueNode) nodeFactory.getNode(
														C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE,
														leftExpression,
														rightExpression,
														cm),
											thenElseList,
											Boolean.TRUE,//this node is for nullif 
											cm);
	}
|
	// CASE WHEN P1 THEN [T1 | NULL] (WHEN Pi THEN [Ti | NULL])* [ELSE E | NULL] END
	<CASE> value = whenThenExpression()
	{
		return value;
	}
}

/*
 * <A NAME="caseExpression">caseExpression</A>
 */
ValueNode
caseExpression() throws StandardException :
{
	ValueNode	   expr;
}
{
	<END>
	{
		ValueNode value = (ValueNode) nodeFactory.getNode(
										C_NodeTypes.CAST_NODE,
										(ValueNode) nodeFactory.getNode(C_NodeTypes.UNTYPED_NULL_CONSTANT_NODE,
																		getContextManager()),
										DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, 1),	
										getContextManager());
		((CastNode) value).setForExternallyGeneratedCASTnode();
		return value;
	}
|
	<ELSE> expr = thenElseExpression() <END>
	{
		return expr;
	}
|
	expr = whenThenExpression()
	{
		return expr;
	}
}

/*
 * <A NAME="whenThenExpression">whenThenExpression</A>
 */
ValueNode
whenThenExpression() throws StandardException :
{
	ValueNode	   expr;
	ValueNode	   thenExpr;
	ValueNode	   elseExpr;
}
{
	<WHEN> expr = orExpression(null, false) 
		   (<OR> expr = orExpression(expr, false) )*
	<THEN> thenExpr = thenElseExpression()
	elseExpr = caseExpression()
	{
		ContextManager cm = getContextManager();
		ValueNodeList thenElseList = (ValueNodeList) nodeFactory.getNode(C_NodeTypes.VALUE_NODE_LIST, cm);
		thenElseList.addElement(thenExpr); // then
		thenElseList.addElement(elseExpr); // else

		return((ValueNode) nodeFactory.getNode(C_NodeTypes.CONDITIONAL_NODE,
												expr,
												thenElseList,
												Boolean.FALSE,
												cm));
	}
}

/*
 * <A NAME="thenElseExpression">thenElseExpression</A>
 */
ValueNode
thenElseExpression() throws StandardException :
{
	ValueNode	   expr;
	CompilerContext cc = getCompilerContext();
}
{	
	LOOKAHEAD ( {getToken(1).kind == NULL} )
	<NULL>
	{
		ValueNode value = (ValueNode) nodeFactory.getNode(
										C_NodeTypes.CAST_NODE,
										(ValueNode) nodeFactory.getNode(C_NodeTypes.UNTYPED_NULL_CONSTANT_NODE,
																		getContextManager()),
										DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, 1),	
										getContextManager());
		((CastNode) value).setForExternallyGeneratedCASTnode();
		return value;
	}
|
	// GemStone changes BEGIN
	{cc.setConvertCharConstToVarchar(true);} 
	expr = additiveExpression(null, 0, false)
	{cc.setConvertCharConstToVarchar(false);}
	// GemStone changes END 
	{
		return expr;
	}
}

TableElementNode
tableConstraintDefinition() throws StandardException :
{
	Properties properties = null;
	ConstraintDefinitionNode tcdn;
	TableName		constraintName = null;
	//initialize following two booleans before handling table level constraints
	explicitNotNull = false;
	explicitNull = false;
}
{
	[ constraintName = constraintNameDefinition() ] 
		tcdn = tableConstraint(constraintName) 
		[ properties = propertyList(false) <CHECK_PROPERTIES>]
	{
		if (properties != null)
		{
			tcdn.setProperties(properties);
		}
		return tcdn;
	}
}

ConstraintDefinitionNode
tableConstraint(TableName constraintName) throws StandardException :
{
	ConstraintDefinitionNode tcdn;
}
{
	tcdn = uniqueConstraintDefinition(constraintName) 
	{
		return tcdn;
	}
|
	tcdn = referentialConstraintDefinition(constraintName) 
	{
		return tcdn;
	}
|
	tcdn = checkConstraintDefinition(constraintName, null)
	{
		return tcdn;
	}
}

ConstraintDefinitionNode
uniqueConstraintDefinition(TableName constraintName) throws StandardException :
{
	int constraintType;
	ResultColumnList uniqueColumnList;
}
{
	//for table level constraint, parameter will be null
	constraintType = uniqueSpecification(null) 
		<LEFT_PAREN> uniqueColumnList = uniqueColumnList() <RIGHT_PAREN>
	{
		//go through the unique columns list and if any of the columns in the
		//list is explicitly defined null, throw an exception for this. Columns
		//for which no nullability is defined are by default nullable. But in
		//case of create table, there nullability changes automatically to 
		//non-nullable if primary key is defined on it. But if user explicitly
		//defines the nullability, then defining a primary key on it in create
		//table will result in an exception.
		if (constraintType ==  DataDictionary.PRIMARYKEY_CONSTRAINT)
		{
			for (int index = 0; index < uniqueColumnList.size(); index++)
			{
				String primaryKeyColumnName = ((ResultColumn) uniqueColumnList.elementAt(index)).getName();
				if (explicitlyNullableColumnsList.contains(primaryKeyColumnName))
				{
					String errorState = SQLState.LANG_DB2_ADD_UNIQUE_OR_PRIMARY_KEY_ON_NULL_COLS;
					throw StandardException.newException(errorState, primaryKeyColumnName);
				}
			}
		}
		return (ConstraintDefinitionNode) nodeFactory.getNode(
						C_NodeTypes.CONSTRAINT_DEFINITION_NODE,
						constraintName,
						ReuseFactory.getInteger(constraintType),
						uniqueColumnList,
						null,
						null,
						null,
						getContextManager()
						);
	}
}

//the second parameter to the following method will always be null for a table level
//constraint but not for a column level constraint
int
uniqueSpecification(String columnName) throws StandardException :
{
}
{
	<UNIQUE> 
	{
		return DataDictionary.UNIQUE_CONSTRAINT;
	}
|
	<PRIMARY> <KEY>
	{
		//explicitNull can be true only if it's column level constraint and
		//that column has null constraint defined on it. In that case, defining
		//a column-level constraint of primary key on it will result in an error.
		if (explicitNull) 
		{
			String errorState = SQLState.LANG_DB2_ADD_UNIQUE_OR_PRIMARY_KEY_ON_NULL_COLS;
			throw StandardException.newException(errorState, columnName);
		}
		return DataDictionary.PRIMARYKEY_CONSTRAINT;
	}
}

ResultColumnList
uniqueColumnList() throws StandardException :
{
	ResultColumnList	resultColumns = (ResultColumnList) nodeFactory.getNode(
											C_NodeTypes.RESULT_COLUMN_LIST,
											getContextManager());
}
{
	columnNameList(resultColumns)
	{
		return resultColumns;
	}
}

ConstraintDefinitionNode
referentialConstraintDefinition(TableName constraintName) throws StandardException :
{
	ResultColumnList fkRcl = (ResultColumnList) nodeFactory.getNode(
										C_NodeTypes.RESULT_COLUMN_LIST,
										getContextManager());
	ResultColumnList refRcl = (ResultColumnList) nodeFactory.getNode(
										C_NodeTypes.RESULT_COLUMN_LIST,
										getContextManager());
	TableName referencedTable;
	int[] refActions = {StatementType.RA_NOACTION, 
			    StatementType.RA_NOACTION}; //default values
}
{
	<FOREIGN> <KEY> <LEFT_PAREN> columnNameList(fkRcl) <RIGHT_PAREN>
		referencedTable = referencesSpecification(refRcl, refActions)
	{
		return (ConstraintDefinitionNode) nodeFactory.getNode(
						C_NodeTypes.FK_CONSTRAINT_DEFINITION_NODE,
						constraintName,
						referencedTable,
						fkRcl,
						refRcl,
						refActions,
						getContextManager());
	}
}

TableName
referencesSpecification(ResultColumnList rcl, int[] refActions) throws StandardException :
{
	TableName tableName = null;
}
{
	<REFERENCES> tableName = referencedTableAndColumns(rcl)
		// not supporting MATCH or referential actions beyond syntax for default
		[ <ON> referentialTriggeredAction(refActions) ]
	{
		return tableName;
	}
}

TableName
referencedTableAndColumns(ResultColumnList rcl) throws StandardException :
{
	TableName	tableName = null;
}
{
	tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH) [ <LEFT_PAREN> columnNameList(rcl) <RIGHT_PAREN> ]
	{
		return tableName;
	}
}

void
referentialTriggeredAction(int [] refActions) throws StandardException :
{}
{
	( refActions[1] = updateRule() [<ON> refActions[0] = deleteRule() ] |
	refActions[0] = deleteRule() [<ON> refActions[1] = updateRule() ] )
}

int
updateRule() :
{
	int action;
}
{
	<UPDATE> action = updateReferentialAction()
	{
		return action;
	}
}

int
// GemStone changes BEGIN
deleteRule() throws StandardException :
/* (original code)
deleteRule()  :
*/
// GemStone changes END
{
	int action;
}
{
	<DELETE> action = deleteReferentialAction()
	{
		return action;
	}

}

int
updateReferentialAction() :
{}
{
	
	  <RESTRICT> {return StatementType.RA_RESTRICT;}
	| <NO> <ACTION> {return StatementType.RA_NOACTION;}

}

int
// GemStone changes BEGIN
deleteReferentialAction() throws StandardException :
/* (original code)
deleteReferentialAction() :
*/
// GemStone changes END
{}
{
// GemStone changes BEGIN
	<CASCADE>
	{
		throw StandardException.newException(SQLState.NOT_IMPLEMENTED, "cascade delete");
	}
	/* (original code)
	<CASCADE> {return StatementType.RA_CASCADE;}
	*/
// GemStone changes END
	| <RESTRICT> {return StatementType.RA_RESTRICT;} 
	| <NO> <ACTION> {return StatementType.RA_NOACTION;}
	| <SET> 
	   (  <NULL> {return StatementType.RA_SETNULL;}    
              |<_DEFAULT>  {return StatementType.RA_SETDEFAULT;}
	   )
}

/*
 * <A NAME="columnConstraintDefinition">columnConstraintDefinition</A>
 */
void
columnConstraintDefinition(DataTypeDescriptor[] dataTypeDescriptor,
						   TableElementList tableElementList,
						   String columnName) throws StandardException :
{
	int constraintType;
	TableElementNode tcdn;
	TableName constraintName = null;
}
{
	[ constraintName = constraintNameDefinition() ]
		tcdn = columnConstraint(constraintName, dataTypeDescriptor, columnName)
	{
		/* NOT NULL constraints are handled by marking the dataTypeDescriptor
		 * as being non-nullable.
		 */
		if (tcdn == null)
		{
			return;
		}

		/* All other constraints, whether column or table will be added as
		 * table constraints.  We do this to facilitate the handling of
		 * multiple column constraints on the same column.
		 */
		tableElementList.addTableElement(tcdn);
	}
}

/*
 * <A NAME="columnConstraint">columnConstraint</A>
 */
ConstraintDefinitionNode
columnConstraint(TableName constraintName,
				 DataTypeDescriptor[] dataTypeDescriptor,
				 String columnName) throws StandardException :
{
	int constraintType;
	Properties properties = null;
	ConstraintDefinitionNode tcdn;
	ResultColumnList refRcl = (ResultColumnList) nodeFactory.getNode(
										C_NodeTypes.RESULT_COLUMN_LIST,
										getContextManager());
	TableName referencedTable;
	int[] refActions = {StatementType.RA_NOACTION,
                            StatementType.RA_NOACTION} ; //default: NO ACTION
}
{
	<NOT> <NULL>
	{
		//If NOT NULL specified more than once, throw syntax error
	    if (explicitNotNull)
	    {
	   		 throw StandardException.newException(SQLState.LANG_DUPLICATE_PROPERTY, "NOT NULL");
	    }
		//if column is explicitly defined not nullable, set following flag
		explicitNotNull = true;
		//if both null and not null constraints are defined for a column,
		//throw an exception
		if (explicitNull) 
                   throw StandardException.newException(SQLState.LANG_ADDING_COLUMN_WITH_NULL_AND_NOT_NULL_CONSTRAINT, columnName); 
		dataTypeDescriptor[0] = dataTypeDescriptor[0].getNullabilityType(false);
		return null;
	}
|
//GemStone changes BEGIN
        //enable JDBC compliannce for explicit NULL.
	<NULL>
	{
		//If NULL specified more than once, throw syntax error
	    if (explicitNull)
	    {
	   		 throw StandardException.newException(SQLState.LANG_DUPLICATE_PROPERTY, "NULL");
	    }
		//if column is explicitly defined nullable, set following flag
		explicitNull = true;
		//if both null and not null constraints are defined for a column,
		//throw an exception
		if (explicitNotNull) 
                   throw StandardException.newException(SQLState.LANG_ADDING_COLUMN_WITH_NULL_AND_NOT_NULL_CONSTRAINT, columnName); 
		dataTypeDescriptor[0] = dataTypeDescriptor[0].getNullabilityType(true);
                //Add to explicitlyNullable column vector, checked if PK is added on this column
                explicitlyNullableColumnsList.add(columnName);
		return null;
	}
|
//GemStone changes END
	//pass the columnname as the second parameter. It will be used to throw an
	//exception if null constraint is defined for this column-level primary 
	//key constraint
	constraintType = uniqueSpecification(columnName)
		[ properties = propertyList(false) <CHECK_PROPERTIES>]
	{
		ResultColumnList uniqueColumnList =
										(ResultColumnList) nodeFactory.getNode(
												C_NodeTypes.RESULT_COLUMN_LIST,
												getContextManager());
		uniqueColumnList.addElement(
			(ResultColumn) nodeFactory.getNode(
							C_NodeTypes.RESULT_COLUMN,
							columnName,
							null,
							getContextManager()));

		return (ConstraintDefinitionNode) nodeFactory.getNode(
						C_NodeTypes.CONSTRAINT_DEFINITION_NODE,
						constraintName,
						ReuseFactory.getInteger(constraintType),
						uniqueColumnList,
						properties,
						null,
						null,
						getContextManager()
						);
	}
|	
	referencedTable = referencesSpecification(refRcl, refActions)
		[ properties = propertyList(false)<CHECK_PROPERTIES>] 
	{
		ResultColumnList fkRcl = (ResultColumnList) nodeFactory.getNode(
											C_NodeTypes.RESULT_COLUMN_LIST,
											getContextManager());
		fkRcl.addElement(
					(ResultColumn) nodeFactory.getNode(
									C_NodeTypes.RESULT_COLUMN,
									columnName,
									null,
									getContextManager())
				);
		tcdn = (ConstraintDefinitionNode) nodeFactory.getNode(
						C_NodeTypes.FK_CONSTRAINT_DEFINITION_NODE,
						constraintName,
						referencedTable,
						fkRcl,
						refRcl,
						refActions,
						getContextManager());
		if (properties != null)
		{
			tcdn.setProperties(properties);
		}
		return tcdn;
	}
|
	tcdn = checkConstraintDefinition(constraintName, columnName)
	{
		return tcdn;
	}
}


/*
 * <A NAME="dropRoleStatement">dropRoleStatement</A>
 */
StatementNode
dropRoleStatement() throws StandardException :
{
	String roleName;
}
{
	/*
	 * DROP ROLE <rolename>
	 */
	<ROLE> roleName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	{
		throw StandardException.newException
            (SQLState.NOT_IMPLEMENTED, "ROLES");
		checkVersion( DataDictionary.DD_VERSION_DERBY_10_4, "ROLES");
		checkSqlStandardAccess("DROP ROLE");

		return (StatementNode) nodeFactory.getNode(
			C_NodeTypes.DROP_ROLE_NODE,
			roleName,
			getContextManager());
	}
}


StatementNode
dropSchemaStatement() throws StandardException :
{
	String schemaName;
	// GemStone changes BEGIN
        Boolean onlyIfExists = Boolean.FALSE;
        // GemStone changes END
}
{
	// GemStone changes BEGIN
	( <SCHEMA> | <DATABASE> )
	{
		CompilerContext cc = getCompilerContext();
		cc.markAsDDLForSnappyUse(true);
		cc.setForcedDDLrouting(true);
	}
  	[<IF> <EXISTS>  	{
  	  onlyIfExists = Boolean.TRUE;  	}]
  	schemaName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true) <RESTRICT>
  	// GemStone changes END
	
  	/* ORIGINAL CODE
	<SCHEMA> schemaName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true) <RESTRICT>
	/*/
	{
		StatementNode stmt =  (StatementNode) nodeFactory.getNode(
							C_NodeTypes.DROP_SCHEMA_NODE,
							schemaName,
// GemStone changes BEGIN
							onlyIfExists,
							// changed to use Integer.valueOf()
							Integer.valueOf(StatementType.DROP_RESTRICT),
// GemStone changes END
							getContextManager());

		return stmt;
	}
}



StatementNode
alterTableStatement() throws StandardException :
{
	StatementNode		node;
	TableName			tableName;
}
{
	<TABLE> tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH) node = alterTableBody(tableName)
	{
		return node;
	}
}

StatementNode
alterTableBody(TableName tableName) throws StandardException :
{
	StatementNode qtn;
	char				lockGranularity = '\0';
	String               newTableName;
	TableElementList	tableElementList =
									(TableElementList) nodeFactory.getNode(
												C_NodeTypes.TABLE_ELEMENT_LIST,
												getContextManager());
	Token				tok = null;
	int[]				changeType = new int[1];
	int[]				behavior = new int[1];
	boolean[]			sequential = new boolean[1];
	boolean[]           isSet = new boolean[1];
	int[] rowLevelSecurityAction = new int[1];
// GemStone changes BEGIN
	GfxdAttributesMutator mutator = new GfxdAttributesMutator();
// GemStone changes END
}
{
//insert special key before compress so that only internal SP can know
	<COMPRESS> [ tok = <SEQUENTIAL> ]
	{		
		checkInternalFeature("COMPRESS");
		return (StatementNode) nodeFactory.getNode(
							C_NodeTypes.ALTER_TABLE_NODE,
							tableName,
// GemStone changes BEGIN
							// changed to use valueOf()
							Boolean.valueOf(tok != null),
							/* (original code)
							new Boolean(tok != null),
							*/
// GemStone changes END
							getContextManager());
	}
|
// GemStone changes BEGIN
	lockGranularity = alterTableAction( tableName, tableElementList, mutator,
		changeType, isSet, behavior, sequential, rowLevelSecurityAction)
	/* lockGranularity = alterTableAction( tableElementList, changeType, behavior, sequential ) */
// GemStone changes END
	{
		return (StatementNode) nodeFactory.getNode(
							C_NodeTypes.ALTER_TABLE_NODE,
							tableName,
							tableElementList,
// GemStone changes BEGIN
							mutator,
							// changed to use valueOf()
							Character.valueOf(lockGranularity),
// GemStone changes END
							changeType,
							// GemStone changes BEGIN
							isSet,
							// GemStone changes END		
							behavior,
							sequential,
							Integer.valueOf(rowLevelSecurityAction[0]),
							getContextManager());
	}
}

/*
 * <A NAME="alterTableRenameTableStatement">alterTableRenameTableStatement</A>
 */
/*
StatementNode
alterTableRenameTableStatement(TableName tableName) throws StandardException :
{
	String newTableName;
}
{
	<TO> newTableName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	{
		return (StatementNode) nodeFactory.getNode(
							C_NodeTypes.RENAME_NODE,
							tableName,
							null,
							newTableName,
							Boolean.TRUE,
ReuseFactory.getInteger(StatementType.RENAME_TABLE),
							getContextManager());
	}
}
*/

/*
 * <A NAME="alterTableRenameColumnStatement">alterTableRenameColumnStatement</A>
 */
/*
StatementNode
alterTableRenameColumnStatement(TableName tableName) throws StandardException :
{
	String oldColumnName;
	String newColumnName;
}
{
	oldColumnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true) <TO> newColumnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	{
		return (StatementNode) nodeFactory.getNode(
							C_NodeTypes.RENAME_NODE,
							tableName,
							oldColumnName,
							newColumnName,
							Boolean.TRUE,
ReuseFactory.getInteger(StatementType.RENAME_COLUMN),
							getContextManager());
	}
}
*/
// GemStone changes BEGIN
char
alterTableAction(TableName tableName, TableElementList tableElementList,
	GfxdAttributesMutator mutator, int[] changeType, boolean[] isSet, int[] behavior,
	boolean[] sequential, int[] rowLevelSecurityAction) throws StandardException :
{
	int					evictionLimit;
	int					expirationKind;
	boolean enableRLS = false;
	ExpirationAttributes[] exprAttrs = new ExpirationAttributes[1];
	String gatewayId = null;
	String hdfsStoreName = null;
	java.sql.Timestamp startTime = null;
	BigDecimal[] interval = new BigDecimal[1];
	long startMillis = 0, intervalMillis = 0;
/*
char
alterTableAction(TableElementList tableElementList, int[] changeType, int[] behavior,
boolean[] sequential, int[] rowLevelSecurityAction) throws StandardException :
{
*/
// GemStone changes END
	char				lockGranularity = '\0';
	TableElementNode	tableElement;
	DataTypeDescriptor	typeDescriptor;
	Token				tok = null;
	String				columnName;
// GemStone changes BEGIN
	long[]				autoIncrementInfo = new long[7];
	/* (original code)
	long[]				autoIncrementInfo = new long[4];
	*/
// GemStone changes END
}
{
	<ADD>
	(
		tableElement = addColumnDefinition(tableElementList)
		|
		tableElement = tableConstraintDefinition()
	)
	{
		if (tableElement instanceof ColumnDefinitionNode)
		{
			//bug 5724 - auto increment columns not allowed in ALTER TABLE statement
			ColumnDefinitionNode cdn = (ColumnDefinitionNode) tableElement;
			if ( cdn.isAutoincrementColumn())
				throw StandardException.newException(SQLState.LANG_ALTER_TABLE_AUTOINCREMENT_COLUMN_NOT_ALLOWED);
		}
		changeType[0] = DDLStatementNode.ADD_TYPE;
		tableElementList.addTableElement(tableElement);
		return lockGranularity;
	}
|
	<ALTER> [ <COLUMN> ] columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true) 
		tableElement = columnAlterClause(columnName)
	{
		changeType[0] = DDLStatementNode.MODIFY_TYPE;
		tableElementList.addTableElement(tableElement);
		isSet[0]=true;
		return lockGranularity;
	}
|
	<DROP>
	(
		tableElement = dropColumnDefinition(behavior)
		|
		tableElement = dropTableConstraintDefinition()
	)
	{
		changeType[0] = DDLStatementNode.DROP_TYPE;
		tableElementList.addTableElement(tableElement);
		return lockGranularity;
	}
|
   (
     <ENABLE>
     {
       enableRLS = true;
     }
     |
     <DISABLE>
     {
       enableRLS = false;
     }
   ) <ROW> <LEVEL> <SECURITY>
   {
     if (enableRLS) {
       rowLevelSecurityAction[0] =
       com.pivotal.gemfirexd.internal.impl.sql.execute.AlterTableConstantAction.ROW_LEVEL_SECURITY_ENABLED;
     } else {
       rowLevelSecurityAction[0] =
       com.pivotal.gemfirexd.internal.impl.sql.execute.AlterTableConstantAction.ROW_LEVEL_SECURITY_DISABLED;
     }
     changeType[0] = DDLStatementNode.MODIFY_TYPE;
     return lockGranularity;
   }


// GemStone changes BEGIN
|
	<SET>
	(
		<EVICTION>
		(
		  <MAXSIZE> evictionLimit = simpleValueSpecification_int()
		  {
			  mutator.setEvictionMaximum(evictionLimit);
			  changeType[0] = DDLStatementNode.MODIFY_TYPE;
			  isSet[0]=true;
			  return lockGranularity;
		  }
	    |
	      startTime = evictionFrequency(interval)
	      {
	        if (startTime != null) {
	          startMillis = startTime.getTime();
	        }
	        intervalMillis = interval[0].longValue() * 1000L;
	        if (!Misc.getMemStoreBooting().isHadoopGfxdLonerMode()) 
	        	mutator.setCustomEvictionAttributes(startMillis, intervalMillis);
	        changeType[0] = DDLStatementNode.MODIFY_TYPE;
	        isSet[0] = true;
	        return lockGranularity;
	      }
	    )
	|
	  (
	  <GATEWAYSENDER> 
		<LEFT_PAREN>
	    [
	        gatewayId = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	        {
	            mutator.addGatewaySenderId(gatewayId);
	        }
	        (
	          <COMMA> gatewayId =  identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	          {
	              mutator.addGatewaySenderId(gatewayId);
	           }
	        )*
  	    ]
	    <RIGHT_PAREN>
	    {
	      mutator.setIsAlterGatewaySender(true);
	      changeType[0] = DDLStatementNode.MODIFY_TYPE;
	      isSet[0]=true;
          return lockGranularity;
	    }
	  )
	  |
	  (
	    <ASYNCLISTENER>
		<LEFT_PAREN>
	    [
	        gatewayId = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	        {
	            mutator.addAsyncEventQueueId(gatewayId);
	        }
	        (
	          <COMMA> gatewayId =  identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	          {
	              mutator.addAsyncEventQueueId(gatewayId);
	           }
	        )*
  	    ]
	    <RIGHT_PAREN>
	    {
	      mutator.setIsAlterAsyncEventListener(true);
	      changeType[0] = DDLStatementNode.MODIFY_TYPE;
	      isSet[0]=true;
          return lockGranularity;
	    }
	  )
	  | 
		expirationKind = expirationKindDefinition(exprAttrs)
		{
			mutator.setExpirationKind(expirationKind);
			mutator.setExpirationAttributes(exprAttrs[0]);
			changeType[0] = DDLStatementNode.MODIFY_TYPE;
			isSet[0]=true;
			return lockGranularity;
		}
	)

	  /* TODO: HDFS: We want to allow adding HDFS store when there was none
	     before and table has no data. However, it requires more work
	     w.r.t. DDL persistence in HDFS where ALTER TABLE will need
	     to be handled too.
	  |
	  (
	    <HDFSSTORE><LEFT_PAREN>
	      [ hdfsStoreName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true) ]
	    <RIGHT_PAREN>
	    {
	      if (hdfsStoreName == null) {
	        hdfsStoreName = "";
	      }
	      mutator.setHDFSStoreName(hdfsStoreName);
	      changeType[0] = DDLStatementNode.MODIFY_TYPE;
	      isSet[0] = true;
	      return lockGranularity;
	    }
	  )
	  */
/*|
	lockGranularity = DB2lockGranularityClause()
	{
		changeType[0] = DDLStatementNode.LOCKING_TYPE;
		return lockGranularity;
}*/

// GemStone changes END
}

/*
 * Handle
 *
 *    ALTER TABLE tablename DROP [ COLUMN ] columnname [ CASCADE | RESTRICT ]
 */
TableElementNode
dropColumnDefinition(int []behavior) throws StandardException :
{
	String columnName;
	TableElementNode tableElement;
}
{
	[ <COLUMN> ] columnName = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
				 dropColumnReferentialAction(behavior)
	{
		return (TableElementNode) nodeFactory.getNode(
						C_NodeTypes.DROP_COLUMN_NODE,
						columnName, null,
						null, null,
						getContextManager());
	}
}
void
dropColumnReferentialAction(int []behavior) :
{
	int refBehavior = StatementType.DROP_RESTRICT;
}
{
	[ <CASCADE> {	refBehavior = StatementType.DROP_CASCADE;}
	  | <RESTRICT> {refBehavior = StatementType.DROP_RESTRICT;} 
    ]
	{
		behavior[0] = refBehavior;
	}
}

TableElementNode
addColumnDefinition(TableElementList tableElementList) throws StandardException :
{
	TableElementNode	tableElement;
}
{
	[ <COLUMN> ] tableElement = columnDefinition(tableElementList)
	{
		return tableElement;
	}
}

/*
 * Various variants of the ALTER TABLE ALTER COLUMN statement.
 *
 * By the type we get here, we've parsed
 *    ALTER TABLE tablename ALTER [COLUMN] columnname
 * and here we parse the remainder of the ALTER COLUMN clause, one of:
 *		SET DATA TYPE data_type
 *		SET INCREMENT BY increment_value
 *		RESTART WITH increment_restart_value
 *		[WITH] DEFAULT default_value
 *      [NOT] NULL
 */
TableElementNode
columnAlterClause(String columnName) throws StandardException :
{
	ValueNode	defaultNode;
// GemStone changes BEGIN
	long[]				autoIncrementInfo = new long[7];
	/* (original code)
	long[]				autoIncrementInfo = new long[4];
	*/
	
// GemStone changes END
	long				autoIncrementIncrement = 1;
	long				autoIncrementRestartWith = 1;
	DataTypeDescriptor	typeDescriptor = null;
}
{
	LOOKAHEAD( {getToken(2).kind == DATA} )
	<SET> <DATA> <TYPE> typeDescriptor = dataTypeDDL()
	{
		return (TableElementNode) nodeFactory.getNode(
						C_NodeTypes.MODIFY_COLUMN_TYPE_NODE,
						columnName, null,
						typeDescriptor, null,
						getContextManager());
	}
|
	LOOKAHEAD( {getToken(2).kind == INCREMENT} )
	<SET> <INCREMENT> <BY> autoIncrementIncrement = exactNumber()
	{
		autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_INC_INDEX] = autoIncrementIncrement;
		autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_CREATE_MODIFY] = ColumnDefinitionNode.MODIFY_AUTOINCREMENT_INC_VALUE;
		autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_IS_GENERATED_BY_DEFAULT] = 1;
		return (TableElementNode) nodeFactory.getNode(
						C_NodeTypes.MODIFY_COLUMN_DEFAULT_NODE,
						columnName,
						null, null, autoIncrementInfo,
						getContextManager());
	}
// GemStone changes BEGIN
|
	LOOKAHEAD( {getToken(2).kind == GENERATED} )
	<SET> <GENERATED> <ALWAYS> <AS> <IDENTITY>
	{
     	autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_START_INDEX] = 1;
	    autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_INC_INDEX] = 1;	  
		autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_IS_AUTOINCREMENT_INDEX] = 1;
		autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_CREATE_MODIFY] = ColumnDefinitionNode.CREATE_AUTOINCREMENT;
		autoIncrementInfo[QueryTreeNode.SET_AUTOINCREMENT] = 1;
		return (TableElementNode) nodeFactory.getNode(
						C_NodeTypes.MODIFY_COLUMN_DEFAULT_NODE,
						columnName,
						null, null, autoIncrementInfo,
						getContextManager());
	}
// GemStone changes END
|
	<RESTART> <WITH> autoIncrementRestartWith = exactNumber()
	{
		autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_START_INDEX] = autoIncrementRestartWith;
		autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_CREATE_MODIFY] = ColumnDefinitionNode.MODIFY_AUTOINCREMENT_RESTART_VALUE;
		autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_IS_GENERATED_BY_DEFAULT] = 1;
		return (TableElementNode) nodeFactory.getNode(
						C_NodeTypes.MODIFY_COLUMN_DEFAULT_NODE,
						columnName,
						null, null, autoIncrementInfo,
						getContextManager());
	}
|
	LOOKAHEAD( {getToken(1).kind == WITH || getToken(1).kind == _DEFAULT })
	defaultNode = defaultClause(autoIncrementInfo, columnName)
	{
		if (autoIncrementInfo[QueryTreeNode.AUTOINCREMENT_IS_AUTOINCREMENT_INDEX]
				 == 0)
		{
			autoIncrementInfo = null;
		}

		return (TableElementNode) nodeFactory.getNode(
								C_NodeTypes.MODIFY_COLUMN_DEFAULT_NODE,
								columnName,
								defaultNode, null, autoIncrementInfo,
								getContextManager());
	}
|
	LOOKAHEAD ({getToken(1).kind == NULL })
	<NULL>
	{
		// for a MODIFY column NULL clause form a modify_column node
		// with all null values. In a column definition a [NOT] NULL
		// column constraint is specified by setting the right value
		// in the nullability field of the data type but we don't have
		// a datatype here.
		return (TableElementNode) nodeFactory.getNode(
								C_NodeTypes.MODIFY_COLUMN_CONSTRAINT_NODE,
								columnName, null, null, null,
								getContextManager());
	}
|
	LOOKAHEAD({getToken(1).kind == NOT})
	<NOT> <NULL>
	{
		// for a MODIFY column NOT NULL clause form a modify_column node
		// with all null values. In a column definition a [NOT] NULL
		// column constraint is specified by setting the right value
		// in the nullability field of the data type but we don't have
		// a datatype here.
		return (TableElementNode) nodeFactory.getNode(
								C_NodeTypes.MODIFY_COLUMN_CONSTRAINT_NOT_NULL_NODE,
								columnName, null, null, null,
								getContextManager());
	}
}


TableElementNode
dropTableConstraintDefinition() throws StandardException :
{
	TableName		 constraintName;
}
{
	LOOKAHEAD( {getToken(1).kind == CONSTRAINT} )
	/* changed constraintName() to qualifiedName() for compaction */
	<CONSTRAINT> constraintName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
	{
		return (TableElementNode) nodeFactory.getNode(
						C_NodeTypes.CONSTRAINT_DEFINITION_NODE,
						constraintName,
						ReuseFactory.getInteger(DataDictionary.DROP_CONSTRAINT),
						null,
						null,
						null,
						null,
						ReuseFactory.getInteger(StatementType.DROP_DEFAULT),
						getContextManager()
						);
	}
|
	LOOKAHEAD( {getToken(1).kind == PRIMARY} )
	<PRIMARY> <KEY>
	{
		return (TableElementNode) nodeFactory.getNode(
						C_NodeTypes.CONSTRAINT_DEFINITION_NODE,
						null,
						ReuseFactory.getInteger(DataDictionary.DROP_CONSTRAINT),
						null,
						null,
						null,
						null,
						ReuseFactory.getInteger(StatementType.DROP_DEFAULT),
						getContextManager()
						);
	}
|
	LOOKAHEAD( {getToken(1).kind == FOREIGN} )
        <FOREIGN> <KEY> constraintName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
	{
		return (TableElementNode) nodeFactory.getNode(
						C_NodeTypes.CONSTRAINT_DEFINITION_NODE,
						constraintName,
						ReuseFactory.getInteger(DataDictionary.DROP_CONSTRAINT),
						null,
						null,
						null,
						null,
						ReuseFactory.getInteger(StatementType.DROP_DEFAULT),
						ReuseFactory.getInteger(DataDictionary.FOREIGNKEY_CONSTRAINT),
						getContextManager()
						);
	}
|
	LOOKAHEAD( {getToken(1).kind == UNIQUE} )
        <UNIQUE> constraintName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
	{
		return (TableElementNode) nodeFactory.getNode(
						C_NodeTypes.CONSTRAINT_DEFINITION_NODE,
						constraintName,
						ReuseFactory.getInteger(DataDictionary.DROP_CONSTRAINT),
						null,
						null,
						null,
						null,
						ReuseFactory.getInteger(StatementType.DROP_DEFAULT),
						ReuseFactory.getInteger(DataDictionary.UNIQUE_CONSTRAINT),
						getContextManager()
						);
	}
|
        <CHECK> constraintName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
	{
		return (TableElementNode) nodeFactory.getNode(
						C_NodeTypes.CONSTRAINT_DEFINITION_NODE,
						constraintName,
						ReuseFactory.getInteger(DataDictionary.DROP_CONSTRAINT),
						null,
						null,
						null,
						null,
						ReuseFactory.getInteger(StatementType.DROP_DEFAULT),
						ReuseFactory.getInteger(DataDictionary.CHECK_CONSTRAINT),
						getContextManager()
						);
	}
}

/*
 * <A NAME="dropTableStatement">dropTableStatement</A>
 */
StatementNode
dropTableStatement() throws StandardException :
{
	TableName tableName;
// GemStone changes BEGIN
	Boolean onlyIfExists = Boolean.FALSE;
	CompilerContext cc = getCompilerContext();
// GemStone changes END
}
{
// GemStone changes BEGIN
	<TABLE>
	{
	  cc.markAsDDLForSnappyUse(true);
	  cc.setForcedDDLrouting(true);
	}
	[ <IF> <EXISTS> { onlyIfExists = Boolean.TRUE; } ]
	tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
	/* (original code)
	<TABLE> tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH) 
	*/
// GemStone changes END
	{
		// DB2 does not support a drop behaviour
		return (StatementNode) nodeFactory.getNode(
											C_NodeTypes.DROP_TABLE_NODE,
											tableName,
// GemStone changes BEGIN
											onlyIfExists,
											// changed to use Integer.valueOf()
											Integer.valueOf(StatementType.DROP_DEFAULT),
// GemStone changes END
											getContextManager());
	}
}

/*
 * <A NAME="dropIndexStatement">dropIndexStatement</A>
 */
StatementNode
dropIndexStatement() throws StandardException :
{
	TableName indexName;
// GemStone changes BEGIN
	Boolean onlyIfExists = Boolean.FALSE;
}
{
	<INDEX>
	{
		CompilerContext cc = getCompilerContext();
		cc.markAsDDLForSnappyUse(true);
		cc.setForcedDDLrouting(true);
	}
	[ <IF> <EXISTS> { onlyIfExists = Boolean.TRUE; } ]    
  indexName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
// GemStone changes END
  	/* (original code)
	<INDEX> indexName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
	*/
	{
		return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.DROP_INDEX_NODE,
								indexName,
// GemStone changes BEGIN								
								onlyIfExists,
// GemStone changes END								
								getContextManager());
	}
}

/*
 * <A NAME="dropAliasStatement">dropAliasStatement</A>
 */
StatementNode
dropAliasStatement() throws StandardException :
{
	Object aliasName;
// GemStone changes BEGIN
	Boolean onlyIfExists = Boolean.FALSE;
// GemStone changes END
}
{
  	<PROCEDURE> 
// GemStone changes BEGIN
	[ <IF> <EXISTS> { onlyIfExists = Boolean.TRUE; } ]
// GemStone changes END
	aliasName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH) 
	{
		return dropAliasNode(aliasName, AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR
// GemStone changes BEGIN
					,onlyIfExists
// GemStone changes END
					);
	}  
|  	<FUNCTION> 
// GemStone changes BEGIN
	[ <IF> <EXISTS> { onlyIfExists = Boolean.TRUE; } ]
// GemStone changes END
    aliasName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
	{
		return dropAliasNode(aliasName, AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR
// GemStone changes BEGIN
					,onlyIfExists
// GemStone changes END
					);
	}  
|	<SYNONYM>
// GemStone changes BEGIN
	[ <IF> <EXISTS> { onlyIfExists = Boolean.TRUE; } ]
// GemStone changes END
	aliasName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
	{
		checkVersion(DataDictionary.DD_VERSION_DERBY_10_1, "DROP SYNONYM");

		return dropAliasNode(aliasName, AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR
// GemStone changes BEGIN
					,onlyIfExists
// GemStone changes END
					);
	}
|	<TYPE>
// GemStone changes BEGIN
	[ <IF> <EXISTS> { onlyIfExists = Boolean.TRUE; } ]
// GemStone changes END
	aliasName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH) <RESTRICT>
	{
		checkVersion(DataDictionary.DD_VERSION_DERBY_10_4, "DROP TYPE");

		return dropAliasNode(aliasName, AliasInfo.ALIAS_TYPE_UDT_AS_CHAR
// GemStone changes BEGIN
					,onlyIfExists
// GemStone changes END
					);
	}
// GemStone changes BEGIN
|	<ALIAS>
	[ <IF> <EXISTS> { onlyIfExists = Boolean.TRUE; } ]
	aliasName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
	{
		return dropAliasNode(aliasName,
			AliasInfo.ALIAS_TYPE_RESULT_PROCESSOR_AS_CHAR,
					onlyIfExists);
	}
// GemStone changes END
}

StatementNode
dropViewStatement() throws StandardException :
{
	TableName viewName;
// GemStone changes BEGIN
	Boolean onlyIfExists = Boolean.FALSE;
// GemStone changes END
}
{
	<VIEW>
// GemStone changes BEGIN
	{
		CompilerContext cc = getCompilerContext();
		cc.markAsDDLForSnappyUse(true);
		cc.setForcedDDLrouting(true);
	}
	[ <IF> <EXISTS> { onlyIfExists = Boolean.TRUE; } ]
// GemStone changes END
	viewName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
	{
		return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.DROP_VIEW_NODE,
								viewName,
// GemStone changes BEGIN								
								onlyIfExists,
// GemStone changes END								
								getContextManager());
	}
}

StatementNode
dropTriggerStatement() throws StandardException :
{
	TableName triggerName;
// GemStone changes BEGIN
	Boolean onlyIfExists = Boolean.FALSE;
// GemStone changes END
}
{
	<TRIGGER>
// GemStone changes BEGIN
	[ <IF> <EXISTS> { onlyIfExists = Boolean.TRUE; } ]
// GemStone changes END
	triggerName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH) 
	{
		return (StatementNode) nodeFactory.getNode(
								C_NodeTypes.DROP_TRIGGER_NODE,
								triggerName,
// GemStone changes BEGIN								
								onlyIfExists,
// GemStone changes END								
								getContextManager());
	}
}


StatementNode
truncateTableStatement() throws StandardException :
{
	TableName tableName;
}
{
	<TRUNCATE> <TABLE>
// GemStone changes BEGIN
	{
		CompilerContext cc = getCompilerContext();
		cc.markAsDDLForSnappyUse(true);
		cc.setForcedDDLrouting(true);
	}
// GemStone changes END
	tableName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
	{
		return (StatementNode) nodeFactory.getNode(
							C_NodeTypes.ALTER_TABLE_NODE,
							tableName,
							getContextManager());
	}
}

/*
 * <A NAME="grantStatement">grantStatement</A>
 */
StatementNode
grantStatement() throws StandardException :
{
	StatementNode node;
}
{
	/* TRIGGER is a non-reserved word, so it is allowed as role
	 * identifier.	This gives a parser problem in determining if
	 * a grant statement is a grant role or grant privilege
	 * statement. In a grant privilege statement, all the other
	 * grantable privileges are reserved keywords, except
	 * TRIGGER. So, if we encounter GRANT TRIGGER, we need to look
	 * one or two more tokens ahead to determine what kind of
	 * grant statement we are seeing:
	 *
	 * privilege grant:
	 *	  grant trigger , <any of rest of privilege keywords>
	 *	  grant trigger on ..
	 *	  grant <any of rest of privilege keywords>
	 * role grant:
	 *	  grant trigger to ..
	 *	  grant trigger, <NOT any of  rest of privilege keywords>
	 *	  grant <NOT any of rest of privilege keywords>
	 */
	LOOKAHEAD( { getToken(1).kind == GRANT &&
				((getToken(2).kind == TRIGGER &&
				  ((getToken(3).kind == COMMA &&
					isPrivilegeKeywordExceptTrigger(getToken(4).kind)) ||
				   getToken(3).kind == ON)) ||
				 isPrivilegeKeywordExceptTrigger(getToken(2).kind)) } )
	<GRANT>
	{
		checkVersion( DataDictionary.DD_VERSION_DERBY_10_2, "GRANT");
		checkSqlStandardAccess( "GRANT");
	}
	( node = tableGrantStatement() | node = routineGrantStatement() )
	{
		return node;
	}
|
	LOOKAHEAD( { getToken(1).kind == GRANT &&
				((getToken(2).kind == TRIGGER &&
				  ((getToken(3).kind == COMMA &&
					!isPrivilegeKeywordExceptTrigger(getToken(4).kind)) ||
				   getToken(3).kind == TO)) ||
				 !isPrivilegeKeywordExceptTrigger(getToken(2).kind)) } )
	<GRANT>
	( node = roleGrantStatement() )
	{
		return node;
	}
}

/*
 * <A NAME="tableGrantStatement">tableGrantStatement</A>
 */
StatementNode
tableGrantStatement() throws StandardException :
{
    PrivilegeNode privileges;
    List grantees;
}
{
       privileges = tablePrivileges()
       <TO> grantees = granteeList()
    {
        return (StatementNode) nodeFactory.getNode( C_NodeTypes.GRANT_NODE,
                                    privileges, grantees,
                                    getContextManager());
    }
}// end of tableGrantStatement

/*
 * <A NAME="tablePrivileges">tablePrivileges</A>
 */
PrivilegeNode tablePrivileges() throws StandardException :
{
    TablePrivilegesNode tablePrivilegesNode = null;
    TableName objectName = null;
}
{
    tablePrivilegesNode = tableActions()
      <ON> [ <TABLE> ] objectName = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
    {
        return (PrivilegeNode) nodeFactory.getNode( C_NodeTypes.PRIVILEGE_NODE,
                                                    ReuseFactory.getInteger( PrivilegeNode.TABLE_PRIVILEGES),
                                                    objectName, tablePrivilegesNode,
                                                    getContextManager());
    }
} // end of   tablePrivilege                               

/*
 * <A NAME="tableActions">tableActions</A>
 */
TablePrivilegesNode tableActions() throws StandardException :
{
    TablePrivilegesNode tableActionsNode = (TablePrivilegesNode)
      nodeFactory.getNode( C_NodeTypes.TABLE_PRIVILEGES_NODE, getContextManager());
}
{
    <ALL> <PRIVILEGES>
    {
        tableActionsNode.addAll();
        return tableActionsNode;
    }
|
    tableAction( tableActionsNode) ( <COMMA> tableAction( tableActionsNode) )*
    {
        return tableActionsNode;
    }
} // end of tableActions

/*
 * <A NAME="routineGrantStatement">routineGrantStatement</A>
 */
StatementNode
routineGrantStatement() throws StandardException :
{
    List grantees;
    RoutineDesignator routine;
}
{
    <EXECUTE> <ON> routine = routineDesignator()
    <TO> grantees = granteeList()
    {
        PrivilegeNode routinePrivilege = (PrivilegeNode)
          nodeFactory.getNode( C_NodeTypes.PRIVILEGE_NODE,
                               ReuseFactory.getInteger( PrivilegeNode.ROUTINE_PRIVILEGES),
                               routine, null,
                               getContextManager());
        return (StatementNode) nodeFactory.getNode( C_NodeTypes.GRANT_NODE,
                                    routinePrivilege, grantees,
                                    getContextManager());
    }
}// end of routineGrantStatement

/*
 * <A NAME="routineAlias">routineAlias</A>
 */
RoutineDesignator routineDesignator() throws StandardException :
{
    Token procOrFunction;
    TableName name;
    List paramTypeList = null;
}
{
    ( procOrFunction = <FUNCTION> | procOrFunction = <PROCEDURE> )
      name = qualifiedName(Limits.MAX_IDENTIFIER_LENGTH)
      [ <LEFT_PAREN> paramTypeList = parameterTypeList() <RIGHT_PAREN> ]
    {
        return new RoutineDesignator( false,
                                      name,
                                      (procOrFunction.kind == FUNCTION),
                                      paramTypeList);
    }
} // end of routineDesignator


/*
 * <A NAME="parameterTypeList">parameterTypeList</A>
 */
List/*<TypeDescriptor>*/ parameterTypeList( ) throws StandardException :
{
    ArrayList list = new ArrayList();
    TypeDescriptor type;
}
{
    [ type = catalogType()
        {
            list.add(type);
        }
      ( <COMMA> type = catalogType()
        {
            list.add(type);
        }
      ) * ]
    {
        return list;
    }
} // end of parameterTypeList


/*
 * <A NAME="tableAction">tableAction</A>
 */
void tableAction( TablePrivilegesNode tablePrivilegesNode)  throws StandardException :
{
    ResultColumnList columnList = null;
}
{
    <SELECT> [ columnList = privilegeColumnList() ]
    {
        tablePrivilegesNode.addAction( TablePrivilegeInfo.SELECT_ACTION, columnList);
    }
|
    <DELETE>
    {
        tablePrivilegesNode.addAction( TablePrivilegeInfo.DELETE_ACTION, (ResultColumnList) null);
    }
|
    <INSERT>
    {
        tablePrivilegesNode.addAction( TablePrivilegeInfo.INSERT_ACTION, (ResultColumnList) null);
    }
|
    <UPDATE> [ columnList = privilegeColumnList() ]
    {
        tablePrivilegesNode.addAction( TablePrivilegeInfo.UPDATE_ACTION, columnList);
    }
|
    <REFERENCES> [ columnList = privilegeColumnList() ]
    {
        tablePrivilegesNode.addAction( TablePrivilegeInfo.REFERENCES_ACTION, columnList);
    }
|
    <TRIGGER>
    {
        tablePrivilegesNode.addAction( TablePrivilegeInfo.TRIGGER_ACTION, (ResultColumnList) null);
    }
|
    <ALTER>
    {
        tablePrivilegesNode.addAction( TablePrivilegeInfo.ALTER_ACTION, (ResultColumnList) null);
    }
} // end of tableAction

/*
 * <A NAME="privilegeColumnList">privilegeColumnList</A>
 */
ResultColumnList privilegeColumnList() throws StandardException :
{
    ResultColumnList cl = (ResultColumnList) nodeFactory.getNode( C_NodeTypes.RESULT_COLUMN_LIST,
                                                                  getContextManager());
}
{
    <LEFT_PAREN> columnNameList( cl) <RIGHT_PAREN>
    {
        return cl;
    }
} // end of privilegeColumnList

/*
 * <A NAME="granteeList">granteeList</A>
 */
List granteeList() throws StandardException :
{
    ArrayList list = new ArrayList();
}
{
    grantee( list) ( <COMMA> grantee( list) ) *
    {
        return list;
    }
}

void
grantee( List list)  throws StandardException :
{
    String str;
}
{
// GemStone changes BEGIN
    <LDAPGROUP> <COLON>
    str = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
    {
        list.add(Constants.LDAP_GROUP_PREFIX + str);
    }
|
// GemStone changes END
    str = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
    {
        list.add(str);
    }
|
    <PUBLIC>
    {
        list.add( Authorizer.PUBLIC_AUTHORIZATION_ID);
    }
}


/*
 * <A NAME="roleGrantStatement">roleGrantStatement</A>
 */
StatementNode
roleGrantStatement() throws StandardException :
{
	List rolesGranted;
	List grantees;
}
{
	/*
	 * GRANT <rolename> {, <rolename>}* TO <authentication identifier>
	 *									{, <authentication identifier>}*
	 *
	 * not implemented: WITH ADMIN OPTION, GRANTED BY clauses
	 */
	rolesGranted = roleList()
	<TO>
	grantees = granteeList()
	{
		checkSqlStandardAccess("GRANT <role>");
		checkVersion( DataDictionary.DD_VERSION_DERBY_10_4, "ROLES");

		return (StatementNode) nodeFactory.getNode
			(C_NodeTypes.GRANT_ROLE_NODE,
			 rolesGranted,
			 grantees,
			 getContextManager());
	}
}


/*
 * <A NAME="roleList">roleList</A>
 */
List roleList() throws StandardException :
{
    ArrayList list = new ArrayList();
}
{
    roleElement(list) ( <COMMA> roleElement(list) ) *
    {
        return list;
    }
}


/*
 * <A NAME="roleElement">roleElement</A>
 */
void
roleElement( List list)  throws StandardException :
{
    String str;
}
{
    str = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
    {
        list.add(str);
    }
}


/*
 * <A NAME="revokeStatement">revokeStatement</A>
 */
StatementNode
revokeStatement() throws StandardException :
{
    StatementNode node;
}
{
	/* See look-ahead explanation in grantStatement.
	 *
	 * privilege revoke:
	 *	  revoke trigger , <any of rest of privilege keywords>
	 *	  revoke trigger on ..
	 *	  revoke <any of rest of privilege keywords>
	 * role revoke:
	 *	  revoke trigger from ..
	 *	  revoke trigger, <NOT any of  rest of privilege keywords>
	 *	  revoke <NOT any of rest of privilege keywords>
	 */
	LOOKAHEAD( { getToken(1).kind == REVOKE &&
				((getToken(2).kind == TRIGGER &&
				  ((getToken(3).kind == COMMA &&
					isPrivilegeKeywordExceptTrigger(getToken(4).kind)) ||
				   getToken(3).kind == ON)) ||
				 isPrivilegeKeywordExceptTrigger(getToken(2).kind)) } )
	<REVOKE>
	{
		checkVersion( DataDictionary.DD_VERSION_DERBY_10_2, "REVOKE");
		checkSqlStandardAccess( "REVOKE");
	}
	( node = tableRevokeStatement() | node = routineRevokeStatement() )
	{
		return node;
	}
|
	LOOKAHEAD( { getToken(1).kind == REVOKE &&
				((getToken(2).kind == TRIGGER &&
				  ((getToken(3).kind == COMMA &&
					!isPrivilegeKeywordExceptTrigger(getToken(4).kind)) ||
				   getToken(3).kind == FROM)) ||
				 !isPrivilegeKeywordExceptTrigger(getToken(2).kind)) } )
	<REVOKE>
	{
		throw StandardException.newException
            (SQLState.NOT_IMPLEMENTED, "ROLES");
		checkVersion( DataDictionary.DD_VERSION_DERBY_10_4, "ROLES");
		checkSqlStandardAccess("REVOKE <role>");
	}
	( node = roleRevokeStatement() )
	{
		return node;
	}
}

/*
 * <A NAME="tableRevokeStatement">tableRevokeStatement</A>
 */
StatementNode
tableRevokeStatement() throws StandardException :
{
    PrivilegeNode privileges = null;
    List grantees;
}
{
       privileges = tablePrivileges()
       <FROM> grantees = granteeList()
    {
        return (StatementNode) nodeFactory.getNode( C_NodeTypes.REVOKE_NODE,
                                    privileges, grantees,
                                    getContextManager());
    }
}// end of tableRevokeStatement

/*
 * <A NAME="routineRevokeStatement">routineRevokeStatement</A>
 */
StatementNode
routineRevokeStatement() throws StandardException :
{
    List grantees;
    RoutineDesignator routine = null;
}
{
    <EXECUTE> <ON> routine = routineDesignator()
    <FROM> grantees = granteeList() <RESTRICT>
    {
        PrivilegeNode routinePrivilege = (PrivilegeNode)
          nodeFactory.getNode( C_NodeTypes.PRIVILEGE_NODE,
                               ReuseFactory.getInteger( PrivilegeNode.ROUTINE_PRIVILEGES),
                               routine, null,
                               getContextManager());
        return (StatementNode) nodeFactory.getNode( C_NodeTypes.REVOKE_NODE,
                                    routinePrivilege, grantees,
                                    getContextManager());
    }
}// end of routineRevokeStatement


/*
 * <A NAME="roleRevokeStatement">roleRevokeStatement</A>
 */
StatementNode
roleRevokeStatement() throws StandardException :
{
	List rolesRevokeed;
	List grantees;
}
{
	rolesRevokeed = roleList()
	<FROM>
	grantees = granteeList()
	{
		return (StatementNode) nodeFactory.getNode
			(C_NodeTypes.REVOKE_ROLE_NODE,
			 rolesRevokeed,
			 grantees,
			 getContextManager());
	}
}

/*
 * <A NAME="identifier">identifier</A>
 */
String
internalIdentifier( int id_length_limit, boolean checkLength) throws StandardException :
{
	String	str;
	Token 	tok;
}
{
	tok = <IDENTIFIER>
	{
        str = StringUtil.SQLToUpperCase(tok.image);
 
 		if (checkLength) {//if checkLength false, then calling method would do the length limit checks
			//limit the identifier to the id length limit passed to this method
			checkIdentifierLengthLimit(str, id_length_limit);
		}
		// Remember whether last token was a delimited identifier
		nextToLastTokenDelimitedIdentifier = lastTokenDelimitedIdentifier;
		lastTokenDelimitedIdentifier = Boolean.FALSE;
		nextToLastIdentifierToken = lastIdentifierToken;
		lastIdentifierToken = tok;
		return str;
	}
|
	str = delimitedIdentifier()
	{
		if (checkLength) {//if checkLength false, then calling method would do the length limit checks
			//limit the identifier to the id length limit passed to this method
			checkIdentifierLengthLimit(str, id_length_limit);
		} 
		return str;
	}
|
	str = nonReservedKeyword()
	{
		return StringUtil.SQLToUpperCase(str);
	}
}

String
identifier(int id_length_limit, boolean checkLength) throws StandardException :
{
	String	id;
}
{
    id = internalIdentifier( id_length_limit, checkLength)
    {
        return id;
    }
}

/*
 * <A NAME="delimitedIdentifier">delimitedIdentifier</A>
 */
String
delimitedIdentifier() :
{
	String	str;
	Token	tok;
}
{
	( tok = <DELIMITED_IDENTIFIER> | tok = <BACKQUOTED_IDENTIFIER> )
	{
        //GemStone changes BEGIN
        str = tok.image;
        //originally str = tok.image.substring(1, tok.image.length() -1);
        //GemStone changes END
		str = normalizeDelimitedID(str, tok.kind == BACKQUOTED_IDENTIFIER);
		// Remember whether last token was a delimited identifier
		nextToLastTokenDelimitedIdentifier = lastTokenDelimitedIdentifier;
		lastTokenDelimitedIdentifier = Boolean.TRUE;
		nextToLastIdentifierToken = lastIdentifierToken;
		lastIdentifierToken = tok;

		return str;
	}
}

/*
 * <A NAME="reservedKeyword">reservedKeyword</A>
 */
String
reservedKeyword() :
{
	Token	tok;
}
{
	/*
		All reserved keywords have to be repeated here,
		so that they may be used as normal identifiers.

		NOTE: The same ones are commented out here as above in the token
		rule, for the same reason.
		
		Derby-139 - LOCAL removed as reserved word as most other
		databases do not enforce it. LOCAL not used at all in grammar so token removed.
	 */
	(
 	/* SQL92 reserved Keywords */
	tok = <ADD>
|	tok = <ALL>
|	tok = <ALLOCATE>
|	tok = <ALTER>
|	tok = <AND>
|	tok = <ANY>
|	tok = <ARE>
|	tok = <AS>
|	tok = <ASC>
|	tok = <ASSERTION>
|	tok = <AT>
|	tok = <AUTHORIZATION>
|	tok = <AVG>
|	tok = <BEGIN>
|	tok = <BETWEEN>
|	tok = <BIT>
|	tok = <BOTH>
|	tok = <BY>
|	tok = <BYTE>
|	tok = <CASCADE>
|	tok = <CASCADED>
|	tok = <CASE>
|	tok = <CAST>
|	tok = <CHAR>
|	tok = <CHARACTER>
|	tok = <CHECK>
|	tok = <CLOSE>
|	tok = <COLLATE>
|	tok = <COLLATION>
|	tok = <COLUMN>
|	tok = <COMMIT>
|	tok = <CONNECT>
|	tok = <CONNECTION>
|	tok = <CONSTRAINT>
|	tok = <CONSTRAINTS>
|	tok = <CONTINUE>
|	tok = <CONVERT>
|	tok = <CORRESPONDING>
|	tok = <CREATE>
|	tok = <CURRENT>
|	tok = <CURRENT_DATE>
|	tok = <CURRENT_TIME>
|	tok = <CURRENT_TIMESTAMP>
|	tok = <CURRENT_USER>
|	tok = <CURSOR>
|	tok = <DEALLOCATE>
|	tok = <DEC>
|	tok = <DECIMAL>
|	tok = <DECLARE>
|	tok = <_DEFAULT>
|	tok = <DEFERRABLE>
|	tok = <DEFERRED>
|	tok = <DELETE>
|	tok = <DESC>
|	tok = <DESCRIBE>
|	tok = <DIAGNOSTICS>
|	tok = <DISCONNECT>
|	tok = <DISTINCT>
|	tok = <DOUBLE>
|	tok = <DROP>
|	tok = <ELSE>
|	tok = <END>
|	tok = <ENDEXEC>
|	tok = <ESCAPE>
|	tok = <EXCEPT>
|	tok = <EXCEPTION>
|	tok = <EXEC>
|	tok = <EXECUTE>
|	tok = <EXISTS>
|	tok = <EXTERNAL>
|	tok = <FALSE>
|	tok = <FETCH>
|	tok = <FIRST>
|	tok = <FLOAT>
|	tok = <FOR>
|	tok = <FOREIGN>
|	tok = <FOUND>
|	tok = <FROM>
|	tok = <FULL>
|	tok = <FUNCTION>
|	tok = <GET>
|	tok = <GET_CURRENT_CONNECTION>
|	tok = <GLOBAL>
|	tok = <GO>
|	tok = <GOTO>
|	tok = <GRANT>
|	tok = <GROUP>
|	tok = <HAVING>
|	tok = <IDENTITY>
|	tok = <IF>
|	tok = <IMMEDIATE>
|	tok = <IN>
|	tok = <INDICATOR>
|	tok = <INITIALLY>
|	tok = <INNER>
|   tok = <INOUT>
|	tok = <INPUT>
|	tok = <INSENSITIVE>
|	tok = <INSERT>
|	tok = <INT>
|	tok = <INTEGER>
|	tok = <INTERSECT>
// SQL92 says it is reserved, but we want it to be non-reserved.
|	tok = <INTO>
|	tok = <IS>
|	tok = <ISOLATION>
|	tok = <JOIN>
|	tok = <KEY>
|	tok = <LAST>
|	tok = <LEADING>
|	tok = <LEFT>
|	tok = <LIKE>
|	tok = <LOWER>
|	tok = <MATCH>
|	tok = <MAX>
|	tok = <MIN>
// SQL92 says it is reserved, but we want it to be non-reserved.
|	tok = <NATIONAL>
|	tok = <NATURAL>
|	tok = <NCHAR>
|	tok = <NVARCHAR> 
|	tok = <NEXT>
|	tok = <NO>
|   tok = <NONE>
|	tok = <NOT>
|	tok = <NULL>
|	tok = <NULLIF>
|	tok = <NUMERIC>
|	tok = <OF>
|	tok = <ON>
|	tok = <ONLY>
|	tok = <OPEN>
|	tok = <OPTION>
|	tok = <OR>
|	tok = <ORDER>
|   tok = <OUT>
|	tok = <OUTER>
|	tok = <OUTPUT>
|	tok = <OVERLAPS>
|	tok = <PAD>
|	tok = <PARTIAL>
|	tok = <PREPARE>
|	tok = <PRESERVE>
|	tok = <PRIMARY>
|	tok = <PRIOR>
|	tok = <PRIVILEGES>
|	tok = <PROCEDURE>
|	tok = <PUBLIC>
|	tok = <READ>
|	tok = <REAL>
|	tok = <REFERENCES>
|	tok = <RELATIVE>
|	tok = <RESTRICT>
|	tok = <REVOKE>
|	tok = <RIGHT>
|	tok = <ROLLBACK>
|	tok = <ROWS>
|	tok = <SCHEMA>
|	tok = <SCROLL>
|	tok = <SELECT>
|	tok = <SESSION_USER>
|	tok = <SET>
|	tok = <SHORT>
|	tok = <SMALLINT>
|	tok = <SOME>
|	tok = <SPACE>
|	tok = <SQL>
|	tok = <SQLCODE>
|	tok = <SQLERROR>
|	tok = <SQLSTATE>
|	tok = <SUBSTRING>
|	tok = <SUM>
|	tok = <SYSTEM_USER>
|	tok = <TABLE>
|	tok = <TEMPORARY>
|	tok = <TIMEZONE_HOUR>
|	tok = <TIMEZONE_MINUTE>
|	tok = <TINYINT>
|	tok = <TO>
|	tok = <TRAILING>
|	tok = <TRANSACTION>
|	tok = <TRANSLATE>
|	tok = <TRANSLATION>
|	tok = <TRUE>
|	tok = <UNION>
|	tok = <UNIQUE>
|	tok = <UNKNOWN>
|	tok = <UPDATE>
|	tok = <UPPER>
|	tok = <USER>
|	tok = <USING>
|	tok = <VALUES>
|	tok = <VARCHAR>
|	tok = <VARYING>
|	tok = <VIEW>
|	tok = <WHENEVER>
|	tok = <WHERE>
|	tok = <WITH>
|	tok = <WORK>
|	tok = <WRITE>
	/* Additional JSQL reserved keywords -- non-SQL92 reserved Keywords */
|	tok = <BOOLEAN>
|	tok = <CALL>
|   tok = <CURRENT_ROLE>
|	tok = <EXPLAIN>
|	tok = <LONGINT>
|	tok = <LTRIM>
|	tok = <RTRIM>
|	tok = <TRIM>
|	tok = <SUBSTR>
|	tok = <XML>
|	tok = <XMLPARSE>
|	tok = <XMLSERIALIZE>
|	tok = <XMLEXISTS>
|	tok = <XMLQUERY>
)
	{
		// Remember whether last token was a delimited identifier
		nextToLastTokenDelimitedIdentifier = lastTokenDelimitedIdentifier;
		lastTokenDelimitedIdentifier = Boolean.FALSE;
		return tok.image;
	}
}

/*
 * <A NAME="nonReservedKeyword">nonReservedKeyword</A>
 */
String
nonReservedKeyword()  :
{
	Token	tok;
}
{
	/*
		All non-reserved keywords have to be repeated here,
		so that they may be used as normal identifiers.

		NOTE: The same ones are commented out here as above in the token
		rule, for the same reason.
	 */
	(
        tok = <ABS>  
	|	tok = <ABSVAL>  
	|	tok = <ACTION>
	|	tok = <AFTER>
	|	tok = <ALWAYS>
	|	tok = <BEFORE>
	|	tok = <BINARY>
	|	tok = <BLOB>
	|	tok = <C>
	|	tok = <CALLED>
	|	tok = <CLASS>
	|	tok = <CLOB>
|	tok = <COALESCE>
	|	tok = <COBOL>
	|	tok = <COMMITTED>
	|	tok = <COMPRESS>
	|	tok = <CONCAT>
	|	tok = <CONTAINS>
	|	tok = <CONTENT>
	|	tok = <COUNT>
	|   tok = <CS>
	|	tok = <CURDATE>
	|	tok = <CURTIME>
	|	tok = <D>
	|	tok = <DATA>
	|	tok = <DATE>
	|	tok = <DAY>
        |	tok = <DIRTY>
	|	tok = <DYNAMIC>
    |   tok = <DATABASE>
	|	tok = <DB2SQL>
	|	tok = <DERBY_JDBC_RESULT_SET>
	|	tok = <DOCUMENT>
	|	tok = <EACH>
	|	tok = <EMPTY>
	|	tok = <EXCLUSIVE>
	|	tok = <FN>
	|	tok = <FORTRAN>
	|	tok = <GENERATED>
// mark HOUR as non-reserved (SNAP-1179)
	|	tok = <HOUR>
	|	tok = <IDENTITY_VAL_LOCAL>
	|	tok = <INCREMENT>
	|	tok = <INDEX>
	|	tok = <INITIAL>
// SQL92 says it is reserved, but we want it to be non-reserved.
	|	tok = <INTERVAL>
	|   tok = <JAVA>
	|	tok = <LANGUAGE>
	|	tok = <LARGE>
    |   tok = <LCASE>
	|	tok = <LENGTH>
	|	tok = <LEVEL>
    |   tok = <LOCATE>
	|	tok = <LOCK>
	|	tok = <LOCKS>
	|	tok = <LOCKSIZE>
	|	tok = <LOGGED>
	|	tok = <LONG>
	|	tok = <MESSAGE_LOCALE>
	|	tok = <METHOD>
// mark MINUTE as non-reserved (SNAP-1179)
	|	tok = <MINUTE>
	|	tok = <MOD>
	|	tok = <MODE>
	|	tok = <MODIFIES>
	|	tok = <MODIFY>
// SQL92 says it is reserved, but we want it to be non-reserved.
	|	tok = <MODULE>
	|	tok = <MONTH>
	|	tok = <_MORE>
	|	tok = <MUMPS>
	|	tok = <NAME>
	|	tok = <NCLOB>
	|	tok = <NEW>
	|   tok = <NEW_TABLE>
	|	tok = <NULLABLE>
	|	tok = <NULLS>
	|	tok = <NUMBER>
	|	tok = <OBJECT>
	|	tok = <OFF>
    |   LOOKAHEAD({
            getToken(1).kind == OFFSET &&
            !seeingOffsetClause()
        })
        tok = <OFFSET>	
	|	tok = <OLD>
	|	tok = <OLD_TABLE>
	|	tok = <OJ>
	|	tok = <OVER>
	|	tok = <PASCAL>
	|	tok = <PASSING>
	|	tok = <PLI>
	|	tok = <PRECISION>
	|	tok = <PROPERTIES>
	|	tok = <READS>
	|	tok = <REF>
// SQL92 says it is reserved, but we want it to be non-reserved.
	|	tok = <RELEASE>
	|	tok = <RENAME>
	|	tok = <REPEATABLE>
	|	tok = <REFERENCING>
	|	tok = <RESET>
	|	tok = <RESTART>
	|	tok = <RESULT>
	|	tok = <RETAIN>
	|	tok = <RETURNING>
	|	tok = <RETURNS>
	|	tok = <ROLE>
	|	tok = <ROW>
//	|	tok = <ROW_COUNT>
	|	tok = <ROW_NUMBER>
	|   tok = <RR>
	|   tok = <RS>
	|	tok = <SCALE>
	|	tok = <SAVEPOINT>
// mark SECOND as non-reserved (SNAP-1179)
	|	tok = <SECOND>
	|	tok = <SECURITY>
	|	tok = <SEQUENCE>
	|	tok = <SEQUENTIAL>
	|	tok = <SERIALIZABLE>
	|	tok = <SETS>
	|	tok = <SHARE>
	|   tok = <SPECIFIC>
	|	tok = <SQLID>
	|	tok = <SQL_TSI_FRAC_SECOND>
	|	tok = <SQL_TSI_SECOND>
	|	tok = <SQL_TSI_MINUTE>
	|	tok = <SQL_TSI_HOUR>
	|	tok = <SQL_TSI_DAY>
	|	tok = <SQL_TSI_WEEK>
	|	tok = <SQL_TSI_MONTH>
	|	tok = <SQL_TSI_QUARTER>
	|	tok = <SQL_TSI_YEAR>
    |   tok = <SQRT>
    |       tok = <STABILITY>
	|	tok = <START>
	|	tok = <STATEMENT>
	|	tok = <STRIP>
	|	tok = <SYNONYM>
	|	tok = <STYLE>
	|	tok = <T>
	|	tok = <THEN>
	|	tok = <TIME>
	|	tok = <TIMESTAMP>
	|	tok = <TIMESTAMPADD>
	|	tok = <TIMESTAMPDIFF>
    |   tok = <TRIGGER>
	|	tok = <TRUNCATE>
	|	tok = <TS>
	|	tok = <TYPE>
    |   tok = <UCASE>
	|	tok = <UNCOMMITTED>
	|   tok = <UR>
	|	tok = <USAGE>
// SQL92 says VALUE is reserved, but we want it to be nonreserved.
	|	tok = <VALUE>
	|	tok = <VARBINARY>
	|	tok = <PARAMETER>
	|	tok = <WHEN>
	|	tok = <WHITESPACE>
// GemStone changes BEGIN
// mark YEAR as non-reserved (SNAP-1179)
	|	tok = <YEAR>
	|   tok = <ALIAS>
	|   tok = <ARRAY>
	|   tok = <ASYNCHRONOUS>
	|   tok = <BUCKETS>	
	|   tok = <COLOCATE>
	|   tok = <CRITERIA>
	|   tok = <DECODE>
	|   tok = <DESTROY>
	|   tok = <DISKDIR>
	|   tok = <ENCODER>
	|   tok = <ENTRY>
	|   tok = <EVICT>
	|   tok = <EVICTACTION>
	|   tok = <EVICTION>
	|   tok = <EXPIRE>
	|   tok = <FREQUENCY>
	|   tok = <DAYS>
	|   tok = <HOURS>
	|   tok = <MINUTES>
	|   tok = <SECONDS>
	|   tok = <MILLISECONDS>
	|   tok = <LAST_MODIFIED_DURATION>
	|   tok = <LAST_MODIFIED_TIME>
	|   tok = <LAST_MODIFIED_TIME_MILLIS>
	|   tok = <ROWID>
	|   tok = <GROUPS>
	|   tok = <HASH> // for CREATE INDEX GLOBAL HASH extension
	|   tok = <IDLETIME>
	|   tok = <INCOMING>
	|   tok = <INITSIZE>
	|   tok = <INFINITY>
	|   tok = <LDAPGROUP>
	|   tok = <LIST>
	|   tok = <LOADER>
	|   tok = <LRUCOUNT>
	|   tok = <LRUHEAPPERCENT>
	|   tok = <LRUMEMSIZE>	
	|   tok = <MAXPARTSIZE>
	|   tok = <MAXSIZE>
	|   tok = <NVL>
	|   tok = <OVERFLOW>
	|   tok = <RANGE>
	|   tok = <RECOVERYDELAY>
	|   tok = <REDUNDANCY>
	|   tok = <REPLICATE>	
	|   tok = <PARTITION>
	|   tok = <PARTITIONER>
	|   tok = <PERSISTENT>
	|   tok = <ASYNCLISTENER>
	|   tok = <SERVER> // also for CREATE SCHEMA
	|   tok = <PROCESSOR>  // for data aware procedure
	|   tok = <COHORT>     //for data aware procedure
	|   tok = <NOWAIT>     //for data aware procedure
	|   tok = <LOCAL>
	|   tok = <STARTUPRECOVERYDELAY>
	|   tok = <SYNCHRONOUS>
	|   tok = <TIMETOLIVE>
	|   tok = <DISKSTORE>
    |	tok = <HDFSSTORE>
    | 	tok = <NAMENODE>
    | 	tok = <HOMEDIR>	
    | 	tok = <BLOCKCACHESIZE>
    | 	tok = <CLIENTCONFIGFILE>
	|   tok = <COMPACTIONTHRESHOLD>
	|   tok = <AUTOCOMPACT>
	|   tok = <ALLOWFORCECOMPACTION>
	|   tok = <TIMEINTERVAL>
	|   tok = <WRITEBUFFERSIZE>
	|   tok = <QUEUESIZE>
	|   tok = <MAXLOGSIZE>
	|   tok = <GATEWAYSENDER>
	|   tok = <REMOTEDSID>
	|   tok = <SOCKETBUFFERSIZE>
	|   tok = <MANUALSTART>
	|   tok = <SOCKETREADTIMEOUT>
	|   tok = <ENABLEBATCHCONFLATION>
	|   tok = <BATCHSIZE>
	|   tok = <DISPATCHERTHREADS>
	|   tok = <BATCHTIMEINTERVAL>
	|   tok = <ENABLEPERSISTENCE>
	|   tok = <DISKSTORENAME>
	|   tok = <MAXQUEUEMEMORY>
	| 	tok = <QUEUEPERSISTENT>
	|	tok = <DISKSYNCHRONOUS>
	|   tok = <ALERTTHRESHOLD>
	|   tok = <LISTENERCLASS>
	|   tok = <INITPARAMS>
	|   tok = <GATEWAYRECEIVER>
	|   tok = <STARTPORT>
	|   tok = <ENDPORT>
	|   tok = <ISPARALLEL>
	|   tok = <MAXTIMEBETWEENPINGS>
	|   tok = <BINDADDRESS>
	|	tok = <OFFHEAP>
	|	tok = <MINORCOMPACT>
	|	tok = <MAJORCOMPACT>
	|	tok = <MAXINPUTFILESIZE>
	|	tok = <MININPUTFILECOUNT>
	|	tok = <MAXINPUTFILECOUNT>
	|	tok = <MINORCOMPACTIONTHREADS>
	|	tok = <MAJORCOMPACTIONINTERVAL>
	|	tok = <MAJORCOMPACTIONTHREADS>
	|	tok = <PURGEINTERVAL>
	|	tok = <WRITEONLY>
	|   tok = <ENABLE>
	|   tok = <DISABLE>
	|   tok = <CONCURRENCY>
	|   tok = <CHECKS>	
	|   tok = <MAXWRITEONLYFILESIZE>
 	|   tok = <WRITEONLYFILEROLLOVERINTERVAL>
 	|	tok = <PUT>
	|   tok = <JSON>
	|   tok = <SPARKHASH>
	|   tok = <CLOB_STRING>
	|   tok = <USE>

// GemStone changes END
	)
	{
		// Remember whether last token was a delimited identifier
		nextToLastTokenDelimitedIdentifier = lastTokenDelimitedIdentifier;
		lastTokenDelimitedIdentifier = Boolean.FALSE;
		nextToLastIdentifierToken = lastIdentifierToken;
		lastIdentifierToken = tok;
		return tok.image;
	}
}

/*
 * <A NAME="caseSensitiveIdentifierPlusReservedWords">caseSensitiveIdentifinonerPlusReservedWords</A>
 */
String
caseSensitiveIdentifierPlusReservedWords() :
{
	String str;
}
{
	str = caseSensitiveIdentifier()
	{
		return str;
	}
|
	str = reservedKeyword()
	{
		return str;
	}
}

/*
 * <A NAME="caseInsensitiveIdentifierPlusReservedWords">caseInsensitiveIdentifierPlusReservedWords</A>
 */
String
caseInsensitiveIdentifierPlusReservedWords() throws StandardException :
{
	String str;
}
{
	str = identifier(Limits.MAX_IDENTIFIER_LENGTH, true)
	{
		return str;
	}
|
	str = reservedKeyword()
	{
		return StringUtil.SQLToUpperCase(str);
	}
}

/*
 * <A NAME="caseSensitiveIdentifier">caseSensitiveIdentifier</A>
 */
String
caseSensitiveIdentifier() :
{
	String	str;
	Token 	tok;
}
{
	tok = <IDENTIFIER>
	{
		// Remember whether last token was a delimited identifier
		nextToLastTokenDelimitedIdentifier = lastTokenDelimitedIdentifier;
		lastTokenDelimitedIdentifier = Boolean.FALSE;
		return tok.image;
	}
|
	str = delimitedIdentifier()
	{
		return str;
	}
|
	str = nonReservedKeyword()
	{
		return str;
	}
}
