/*
 * Copyright (c) 2010-2015 Pivotal Software, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you
 * may not use this file except in compliance with the License. You
 * may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License. See accompanying
 * LICENSE file.
 */

package com.pivotal.gemfirexd.jdbc;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.util.HashSet;
import java.util.Properties;
import java.util.StringTokenizer;

import com.gemstone.gemfire.cache.persistence.PartitionOfflineException;
import com.gemstone.gemfire.distributed.internal.DistributionConfig;
import com.gemstone.gemfire.internal.AvailablePort;
import com.gemstone.gemfire.internal.shared.NativeCalls;
import com.pivotal.gemfirexd.TestUtil;
import com.pivotal.gemfirexd.internal.engine.GemFireXDQueryObserverAdapter;
import com.pivotal.gemfirexd.internal.engine.GemFireXDQueryObserverHolder;
import com.pivotal.gemfirexd.internal.engine.GfxdConstants;
import com.pivotal.gemfirexd.internal.engine.access.index.OpenMemIndex;
import com.pivotal.gemfirexd.internal.engine.distributed.metadata.DMLQueryInfo;
import com.pivotal.gemfirexd.internal.engine.distributed.metadata.SelectQueryInfo;
import com.pivotal.gemfirexd.internal.engine.distributed.utils.GemFireXDUtils;
import com.pivotal.gemfirexd.internal.engine.sql.execute.GemFireDistributedResultSet;
import com.pivotal.gemfirexd.internal.engine.store.GemFireContainer;
import com.pivotal.gemfirexd.internal.iapi.error.DerbySQLException;
import com.pivotal.gemfirexd.internal.iapi.sql.conn.LanguageConnectionContext;
import com.pivotal.gemfirexd.internal.impl.sql.GenericPreparedStatement;
import com.pivotal.gemfirexd.internal.shared.common.sanity.SanityManager;
import com.sun.jna.Platform;
import junit.framework.TestSuite;
import junit.textui.TestRunner;

public class BugsTest extends JdbcTestBase {

  public static void main(String[] args) {
    TestRunner.run(new TestSuite(SimpleAppTest.class));
  }

  public BugsTest(String name) {
    super(name);
  }

  public static Integer maxFunc(Integer val1, Integer val2) throws SQLException {
    return val1 > val2 ? val1 : val2;
  }

  public void testGEMXD_3_IndexRecoveryNPE() throws Exception {
    Connection conn = TestUtil.getConnection();
    Statement st = conn.createStatement();
    st.execute("Create table ODS.POSTAL_ADDRESS("
        + "cntc_id bigint NOT NULL,"
        + "pstl_addr_id bigint GENERATED BY DEFAULT AS IDENTITY  NOT NULL,"
        + "ver bigint NOT NULL,"
        + "client_id bigint NOT NULL,"
        + "str_ln1 varchar(100),"
        + "str_ln2 varchar(100),"
        + "str_ln3 varchar(100),"
        + "cnty varchar(50),"
        + "pstl_cd varchar(20),"
        + "cntry varchar(100),"
        + "vldtd SMALLINT,"
        + "vldtn_dt DATE,"
        + "vld_frm_dt TIMESTAMP NOT NULL,"
        + "vld_to_dt TIMESTAMP,"
        + "src_sys_ref_id varchar(10) NOT NULL,"
        + "src_sys_rec_id varchar(150),"
        + "PRIMARY KEY (client_id,cntc_id,pstl_addr_id)) "
        + "PARTITION BY COLUMN (cntc_id) "
        + "REDUNDANCY 1 EVICTION BY LRUHEAPPERCENT EVICTACTION "
        + "OVERFLOW PERSISTENT ASYNCHRONOUS");

    for (int i = 200; i < 250; i++) {
      st.execute("insert into ODS.POSTAL_ADDRESS(cntc_id, ver, client_id, "
          + "str_ln2, cnty, vld_frm_dt, src_sys_ref_id) values (" + (i * 74)
          + ", " + (i + 14) + ", " + (i + 20) + ", 'STR_LN2', 'CNTY"
          + (i * 42) + "', CURRENT_TIMESTAMP, 'REFID" + i + "')");
    }

    st.execute("ALTER TABLE ODS.POSTAL_ADDRESS ADD COLUMN cty varchar(75)");
    st.execute("CREATE INDEX IX_POSTAL_ADDRESS_02 ON ODS.POSTAL_ADDRESS "
        + "(CTY, CLIENT_ID) -- GEMFIREXD-PROPERTIES caseSensitive=false");
    for (int i = 150; i < 200; i++) {
      st.execute("insert into ODS.POSTAL_ADDRESS(cntc_id, ver, client_id, "
          + "str_ln2, cty, cnty, vld_frm_dt, src_sys_ref_id) values ("
          + (i * 74) + ", " + (i + 14) + ", " + (i + 20) + ", 'STR_LN2', 'CTY"
          + (i + 20) + "', 'CNTY" + (i * 42) + "', CURRENT_TIMESTAMP, 'REFID"
          + i + "')");
    }

    st.execute("ALTER TABLE ODS.POSTAL_ADDRESS ADD COLUMN st varchar(50) default ''");
    st.execute("CREATE INDEX IX_POSTAL_ADDRESS_03 ON ODS.POSTAL_ADDRESS "
        + "(ST, CLIENT_ID) -- GEMFIREXD-PROPERTIES caseSensitive=false");
    for (int i = 100; i < 150; i++) {
      st.execute("insert into ODS.POSTAL_ADDRESS(cntc_id, ver, client_id, "
          + "str_ln2, cnty, st, vld_frm_dt, src_sys_ref_id) values ("
          + (i * 74) + ", " + (i + 14) + ", " + (i + 20)
          + ", 'STR_LN2', 'CNTY" + (i * 42) + "', 'ST" + (i + 20) + "', "
          + "CURRENT_TIMESTAMP, 'REFID" + i + "')");
    }
    for (int i = 0; i < 100; i++) {
      st.execute("insert into ODS.POSTAL_ADDRESS(cntc_id, ver, client_id, "
          + "str_ln2, cty, cnty, st, vld_frm_dt, src_sys_ref_id) values ("
          + (i * 74) + ", " + (i + 14) + ", " + (i + 20) + ", 'STR_LN2', 'CTY"
          + (i + 20) + "', 'CNTY" + (i * 42) + "', 'ST" + (i + 20) + "', "
          + "CURRENT_TIMESTAMP, 'REFID" + i + "')");
    }
    // shutdown and restart for index recovery
    shutDown();

    setupConnection();
    conn = TestUtil.getConnection();
    st = conn.createStatement();
    ResultSet rs;
    for (int i = 0; i < 250; i++) {
      logger.info("Testing index 02 query for i = " + i);
      rs = st.executeQuery("select st, cty, client_id from ODS.POSTAL_ADDRESS "
          + "where CTY='CTY" + (i + 20) + "' AND CLIENT_ID=" + (i + 20));
      if ((i >= 200 && i < 250) || (i >= 100 && i < 150)) {
        assertFalse(rs.next());
      } else {
        assertTrue(rs.next());
        if (i >= 0 && i < 150) {
          assertEquals("ST" + (i + 20), rs.getString(1));
        } else {
          assertEquals("", rs.getString(1));
        }
        assertEquals("CTY" + (i + 20), rs.getString(2));
      }
      rs.close();
    }
    for (int i = 0; i < 250; i++) {
      logger.info("Testing index 03 query for i = " + i);
      rs = st.executeQuery("select st, cty, client_id from ODS.POSTAL_ADDRESS "
          + "where ST='ST" + (i + 20) + "' AND CLIENT_ID=" + (i + 20));
      if (i >= 0 && i < 150) {
        assertTrue("failed to find result for " + i, rs.next());
        assertEquals("ST" + (i + 20), rs.getString(1));
        if (i < 100) {
          assertEquals("CTY" + (i + 20), rs.getString(2));
        } else {
          assertNull(rs.getString(2));
        }
      } else {
        assertFalse(rs.next());
      }
      rs.close();
    }
  }

  public void testBug51188() throws Exception {
    DMLQueryInfo.setTestFlagIgnoreSingleVMCriteria(true);
    Connection conn = TestUtil.getConnection();
    Statement st = conn.createStatement();
    ResultSet rs = null;

    GemFireXDQueryObserverAdapter observer = new GemFireXDQueryObserverAdapter() {
      public void afterResultSetOpen(GenericPreparedStatement stmt,
          LanguageConnectionContext lcc,
          com.pivotal.gemfirexd.internal.iapi.sql.ResultSet resultSet) {
        if (resultSet != null) {
          assertTrue(resultSet.getClass().getSimpleName().compareTo(
              "HashJoinResultSet") == 0
              || resultSet instanceof GemFireDistributedResultSet);
        }
      }
    };

    st.execute("CREATE TABLE t1 (c1 BIGINT NOT NULL) PARTITION BY COLUMN (c1)");
    st.execute("CREATE TABLE t2 (c1 BIGINT NOT NULL) PARTITION BY COLUMN (c1) COLOCATE WITH (t1)");
    
    PreparedStatement ps1 = conn.prepareStatement("insert into t1 values (?)");
    int i = 0;
    for (i = 0; i < 100000; i++) {
      ps1.setLong(1, i);
      ps1.addBatch();
      if (i % 1000 == 0)
        ps1.executeBatch();
    }
    if (i % 1000 == 0)
      ps1.executeBatch();

    PreparedStatement ps2 = conn.prepareStatement("insert into t2 values (?)");
    for (i = 0; i < 100000; i++) {
      ps2.setLong(1, i);
      ps2.addBatch();
      if (i % 1000 == 0)
        ps2.executeBatch();
    }
    if (i % 1000 == 0)
      ps2.executeBatch();

    st.execute("select count(*) from t1");
    rs = st.getResultSet();
    rs.next();
    assertTrue(rs.getLong(1) == 100000);
    st.execute("select count(*) from t2");
    rs = st.getResultSet();
    rs.next();
    assertTrue(rs.getLong(1) == 100000);

    GemFireXDQueryObserverHolder.setInstance(observer);
    st.execute("SELECT t1.c1, t2.c1 FROM t1 JOIN t2 ON t1.c1 = t2.c1");
    GemFireXDQueryObserverHolder.clearInstance();

    rs = st.getResultSet();
    long count = 0;
    while (rs.next()) {
      count++;
    }
    assertTrue(count == 100000);
  }

  public void testBug51284() throws Exception {
    // reducing batch DML size to force putAll be broken into 1-2 rows
    System.setProperty(GfxdConstants.DML_MAX_CHUNK_SIZE_PROP, "7");
    try {
      Connection conn = getConnection();
      conn.setAutoCommit(true);
      conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
      Statement st = conn.createStatement();

      st.execute("create table isuspectabug(id int primary key, "
          + "name varchar(20)) partition by primary key");
      try {
        st.execute("insert into isuspectabug values(1, 'one'), (3, 'three'), "
            + "(3, 'three')");
        fail("expected a primary key constraint violation");
      } catch (SQLException sqle) {
        if (!"23505".equals(sqle.getSQLState())) {
          throw sqle;
        }
      }

      // all inserts should be transactional so there should have been no
      // successful inserts
      ResultSet rs = st.executeQuery("select * from isuspectabug");
      assertFalse(rs.next());
      rs = st.executeQuery("select count(*) from isuspectabug");
      assertTrue(rs.next());
      assertEquals(0, rs.getInt(1));
      assertFalse(rs.next());

      // also from another connection
      Connection conn2 = getConnection();
      Statement st2 = conn2.createStatement();
      rs = st2.executeQuery("select * from isuspectabug");
      assertFalse(rs.next());
      rs = st2.executeQuery("select count(*) from isuspectabug");
      assertTrue(rs.next());
      assertEquals(0, rs.getInt(1));
      assertFalse(rs.next());

      // also check with autocommit==false
      conn.setAutoCommit(false);
      st.execute("create table isuspectabug2(id int primary key, "
          + "name varchar(20)) partition by primary key");
      try {
        st.execute("insert into isuspectabug2 values(1, 'one'), (3, 'three'), "
            + "(3, 'three')");
        fail("expected a primary key constraint violation");
      } catch (SQLException sqle) {
        if (!"23505".equals(sqle.getSQLState())) {
          throw sqle;
        }
      }

      conn.rollback();

      // all inserts should be transactional so there should have been no
      // successful inserts
      rs = st.executeQuery("select * from isuspectabug2");
      assertFalse(rs.next());
      rs = st.executeQuery("select count(*) from isuspectabug2");
      assertTrue(rs.next());
      assertEquals(0, rs.getInt(1));
      assertFalse(rs.next());

      // also from another connection
      rs = st2.executeQuery("select * from isuspectabug2");
      assertFalse(rs.next());
      rs = st2.executeQuery("select count(*) from isuspectabug2");
      assertTrue(rs.next());
      assertEquals(0, rs.getInt(1));
      assertFalse(rs.next());
    } finally {
      System.clearProperty(GfxdConstants.DML_MAX_CHUNK_SIZE_PROP);
    }
  }

  public void testBug51463() throws Exception {
    Connection conn = getConnection();
    Statement st = conn.createStatement();

    try {
      st.execute("create table t1 (col1 int primary key, col2 varchar(10), col3 varchar(10), "
              + "constraint t1_uq unique (col2, col3)) partition by primary key");
      st.execute("put into t1 values (202, 'a0', 'lse')");
      st.execute("put into t1 values (303, 'a0', 'lse')");
      fail("Expect unique constraint violation");
    } catch (SQLException sqle) {
      if (sqle.getSQLState().compareTo("23505") != 0) {
        throw sqle;
      }
    }
  }
  
  public void testBug51230() throws Exception {
    Connection conn = getConnection();   
    Statement st = conn.createStatement();    
    st.execute("CREATE TABLE t1 (c1 VARCHAR(2048))");
    st.execute("CREATE TABLE t2 AS SELECT * FROM t1 WITH NO DATA");
    st.execute("ALTER TABLE t2 ADD COLUMN c2 VARCHAR(1)");    
    conn.close();
  }

  public void testBug51064() throws Exception {

    SelectQueryInfo.setTestFlagIgnoreSingleVMCriteria(true);
    Properties props = new Properties();
    Connection conn = getConnection(props);
    Statement st = conn.createStatement();
    ResultSet rs = null;

    st.execute("CREATE TABLE APP.PERSON ("
        + "CLNT_OBJ_ID VARCHAR(100) NOT NULL, "
        + "PERS_OBJ_ID VARCHAR(100) NOT NULL) "
        + "PARTITION BY COLUMN (CLNT_OBJ_ID, PERS_OBJ_ID) BUCKETS 163");

    st.execute("CREATE TABLE APP.EARN_ROLLUP_PERSON ("
        + "CLNT_OBJ_ID VARCHAR(100) NOT NULL,"
        + "PERS_OBJ_ID VARCHAR(100) NOT NULL," + "PAYRL_EARN_KY INT NOT NULL,"
        + "EARN_CD VARCHAR(200) NOT NULL," + "EARN_DSC VARCHAR(200) NOT NULL,"
        + "PAY_GRP_CD VARCHAR(200) NOT NULL,"
        + "WORK_LOC_SHRT_DSC VARCHAR(200) NOT NULL,"
        + "EARNING DECIMAL(20,5) NOT NULL," + "MONTH VARCHAR(100) NOT NULL,"
        + "QTR VARCHAR(100) NOT NULL," + "YEAR_NR INT NOT NULL) "
        + "PARTITION BY COLUMN (CLNT_OBJ_ID,PERS_OBJ_ID) "
        + "COLOCATE WITH (APP.PERSON) " + "BUCKETS 163");

    st.execute("CALL SYSCS_UTIL.IMPORT_TABLE_EX ('APP', 'PERSON', '"
        + getResourcesDir() + "/lib/useCase9/person_data.tbl', ',', "
        + "null, null, 0, 0 , 6 , 0 , null , null )");

    st.execute("CALL SYSCS_UTIL.IMPORT_TABLE_EX ('APP', 'EARN_ROLLUP_PERSON', '"
            + getResourcesDir()
            + "/lib/useCase9/earn_rollup_data.tbl', ',', "
            + "null, null, 0, 0 , 6 , 0 , null , null )");

    st.execute("SELECT  t1.YEAR_nr, "
            + "sum(t1.EARNING)/cast((count(DISTINCT t2.pers_obj_id)) as decimal) as avg_earnings ,"
            + "earn_cd ," + "earn_dsc "
            + "FROM app.EARN_ROLLUP_PERSON t1 ,app.person t2 "
            + "WHERE t1.clnt_obj_id = t2.clnt_obj_id AND "
            + "t1.pers_obj_id = t2.pers_obj_id AND "
            + "t1.CLNT_OBJ_ID = 'G3H02MPK5NQRXJ9N_0041' AND "
            + "work_loc_shrt_dsc in ('AZ') AND " + "pay_grp_cd = 'LXG' AND "
            + "YEAR_nr = 2012 " + "GROUP BY earn_cd, earn_dsc,YEAR_nr "
            + "ORDER BY year_nr,earn_cd, earn_dsc");
    
    rs = st.getResultSet();
    int count = 0;
    while (rs.next()) {
      count++;
    }
    assertEquals(13, count);
  }

  public void testBug50428() throws Exception {
    reduceLogLevelForTest("config");

     Properties props = new Properties();
     int mcastPort = AvailablePort.getRandomAvailablePort(AvailablePort.JGROUPS);
     props.put("mcast-port", String.valueOf(mcastPort));
     Connection conn = TestUtil.getConnection(props);    
    Statement st = conn.createStatement();
    ResultSet rs = null;
    
    st.execute("CREATE TABLE ORDERS  ( O_ORDERKEY INTEGER NOT NULL, "
        + "O_CUSTKEY INTEGER NOT NULL, " + "O_ORDERSTATUS CHAR(1) NOT NULL, "
        + "O_TOTALPRICE DECIMAL(15,2) NOT NULL, "
        + "O_ORDERDATE DATE NOT NULL, " + "O_ORDERPRIORITY CHAR(15) NOT NULL, "
        + "O_CLERK CHAR(15) NOT NULL, " + "O_SHIPPRIORITY INTEGER NOT NULL, "
        + "O_COMMENT VARCHAR(79) NOT NULL) "
        + "PARTITION BY COLUMN (O_ORDERKEY)");
    
    st.execute("ALTER TABLE ORDERS ADD PRIMARY KEY (O_ORDERKEY)");
        
    //Use more than one thread to see if null schema works
    st.execute("CALL SYSCS_UTIL.IMPORT_TABLE_EX (null, 'ORDERS', '" +
        getResourcesDir() + "/lib/tpch/orders.tbl" +
        "', '|', null, null, 0, 0, 2, 0, null, null)");
  }

  public void testOplogPreBlow() throws Exception {
    reduceLogLevelForTest("config");

    if (Platform.isLinux()) {
      this.deleteDirs = new String[2];
      Connection conn = TestUtil.getConnection();
      NativeCalls.TEST_CHK_FALLOC_DIRS = new HashSet<String>();
      Statement st = conn.createStatement();
      // Test local directory
      long currTime = System.nanoTime();
      String locDirName = "/tmp/" + System.getenv().get("USER") + "-"
          + currTime;
      File locDir = new File(locDirName);
      assertTrue(locDir.mkdir());
      this.deleteDirs[0] = locDir.getAbsolutePath();
      String remDirName;
      boolean hasExportDir;
      String userName = System.getenv("USER");
      String exportDir = "/srv/users/" + userName;
      File exportFile = new File(exportDir);
      if (exportFile.exists() && exportFile.isDirectory()) {
        hasExportDir = true;
        remDirName = exportDir + "/preBlow-" + currTime;
      } else {
        exportDir = "/export/shared/users/" + userName;
        exportFile = new File(exportDir);
        if (exportFile.mkdirs() ||
            (exportFile.exists() && exportFile.isDirectory())) {
          hasExportDir = true;
          remDirName = exportDir + "/preBlow-" + currTime;
        } else {
          hasExportDir = false;
          remDirName = "/home/" + System.getenv().get("USER") + "/preBlow-"
              + currTime;
        }
      }
      File remDir = new File(remDirName);
      getLogger().info("Using remote directory " + remDir.getAbsolutePath());
      assertTrue(remDir.mkdir());
      this.deleteDirs[1] = remDir.getAbsolutePath();
      st.execute("create diskstore teststore_loc ('" + locDirName + "') MAXLOGSIZE 2");
      StringBuilder str1k = new StringBuilder();
      for (int i = 0; i < 1024; i++) {
        str1k.append('a');
      }
      st.execute("create table emp(id int not null primary key, name varchar(20) not null, "
          + "addr varchar(2000) not null) persistent 'teststore_loc'");
      PreparedStatement ps = conn
          .prepareStatement("insert into emp values(?, ?, ?)");
      for (int i = 0; i < 5000; i++) {
        ps.setInt(1, i);
        ps.setString(2, "name" + i);
        ps.setString(3, str1k.toString());
        int j = ps.executeUpdate();
        assertEquals(1, j);
      }
      st.execute("select count(*) from emp");
      ResultSet rs = st.getResultSet();
      rs.next();
      assertEquals(5000, rs.getInt(1));

      HashSet<String> preBlowDoneDirs = new HashSet<>();
      preBlowDoneDirs.addAll(NativeCalls.TEST_CHK_FALLOC_DIRS);
      NativeCalls.TEST_CHK_FALLOC_DIRS.clear();
      // Test remote now
      NativeCalls.TEST_NO_FALLOC_DIRS = new HashSet<>();
      st.execute("create diskstore teststore_rem ('" + remDirName + "') MAXLOGSIZE 2");
      st.execute("create table emp2(id int not null primary key, name varchar(20) not null, "
          + "addr varchar(2000) not null) persistent 'teststore_rem'");
      ps = conn.prepareStatement("insert into emp2 values(?, ?, ?)");
      for (int i = 0; i < 5000; i++) {
        ps.setInt(1, i);
        ps.setString(2, "name" + i);
        ps.setString(3, str1k.toString());
        int j = ps.executeUpdate();
        assertEquals(1, j);
      }
      st.execute("select count(*) from emp2");
      rs = st.getResultSet();
      rs.next();
      assertEquals(5000, rs.getInt(1));
      HashSet<String> preBlowNotDoneDirs = new HashSet<>();
      preBlowNotDoneDirs.addAll(NativeCalls.TEST_NO_FALLOC_DIRS);
      if (hasExportDir) {
        assertTrue(NativeCalls.TEST_CHK_FALLOC_DIRS.isEmpty());
        assertEquals(preBlowDoneDirs.size(), preBlowNotDoneDirs.size());
      } else {
        assertFalse(NativeCalls.TEST_CHK_FALLOC_DIRS.isEmpty());
        assertEquals(0, preBlowNotDoneDirs.size());
      }
      NativeCalls.TEST_CHK_FALLOC_DIRS = null;
      NativeCalls.TEST_NO_FALLOC_DIRS.clear();
      NativeCalls.TEST_NO_FALLOC_DIRS = null;
      assertTrue(preBlowDoneDirs.size() > 0);
    }
  }
  
  public void testBug50100() throws Exception {
    Connection conn = TestUtil.getConnection();
    Statement st = conn.createStatement();

    String sql = "CREATE TABLE app.test "
        + "( id bigint not null generated by default as identity (start with 1, increment by 1), "
        + "batch_id bigint, constraint app_test_pk primary key (id) ) PARTITION BY PRIMARY KEY";
    st.execute(sql);
    st.execute("CREATE UNIQUE INDEX idx_app_test_id ON app.test ( id )");
    st.execute("insert into app.test(batch_id) values( null )");
    st.execute("insert into app.test(batch_id) values( null )");
    st.execute("insert into app.test(batch_id) values( null )");
    st.execute("insert into app.test(batch_id) values( null )");
    st.execute("insert into app.test(batch_id) values( null )");
    
    st.execute("select * from app.test where id in (1,2,3,4,5) or batch_id < 4");
    ResultSet rs = st.getResultSet();
    int cnt = 0;
    while(rs.next()) cnt++;
    
    assertEquals(5, cnt);
    
    st.execute("CREATE INDEX idx_app_test_batch_id ON app.test ( batch_id )");
    st.execute("insert into app.test(batch_id) values( null )");
    st.execute("insert into app.test(batch_id) values( null )");
    st.execute("insert into app.test(batch_id) values( null )");
    st.execute("insert into app.test(batch_id) values( null )");
    st.execute("insert into app.test(batch_id) values( null )");
    
    st.execute("select * from app.test where id in (6,7,8,9,10) or batch_id < 4");
    rs = st.getResultSet();
    cnt = 0;
    while(rs.next()) cnt++;
    
    assertEquals(5, cnt);
  }
  
  public void testBug50100_1() throws Exception {
    Properties props1 = new Properties();
    int mport = AvailablePort.getRandomAvailablePort(AvailablePort.JGROUPS);
    DMLQueryInfo.setTestFlagIgnoreSingleVMCriteria(true);
    props1.put("mcast-port", String.valueOf(mport));
    setupConnection(props1);
    Connection conn = TestUtil.getConnection(props1);
    conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
    Statement st = conn.createStatement();

    String sql = "CREATE table trade.customers (cid int not null, cust_name varchar(100), "
        + "since date, addr varchar(100), tid int, primary key (cid))  "
        + "partition by range (since) (VALUES BETWEEN CAST('1998-01-01'  AS DATE) AND CAST('2000-08-11' AS DATE),  "
        + "VALUES BETWEEN CAST('2003-09-01' AS DATE) AND  CAST('2007-12-31' AS DATE) )";
    st.execute(sql);
    st.execute("create  index index_2 on trade.customers ( SINCE desc  )");
    st.execute("create  index index_96 on trade.customers ( SINCE )");
    st.execute("create  index index_16 on trade.customers ( CUST_NAME   )");
    st.execute("insert into trade.customers values (1, 'name1', '1998-04-18', 'a', 1)");
    st.execute("insert into trade.customers values (2, 'name2', '2006-05-25', 'a', 1), " +
    		                                  "(3, 'name3', '2007-06-12', 'a', 1), " +
    		                                  "(4, 'name4', '2003-06-12', 'a', 1)");
    conn.commit();
    
    st.execute("select cid, since, cust_name from trade.customers where cust_name = 'name2' or since = '2003-06-12'");
    ResultSet rs = st.getResultSet();
    int cnt = 0;
    while(rs.next()) {
      cnt++;
    }
    assertEquals(2, cnt);
    
    st.execute("select cid, since, cust_name from trade.customers where cust_name = 'name2' or since in ('2003-06-12', '2007-06-12', '2005-01-02')");
    rs = st.getResultSet();
    cnt = 0;
    while(rs.next()) {
      cnt++;
    }
    assertEquals(3, cnt);
    
    st.execute("select cid, since, cust_name from trade.customers where since in ('2003-06-12', '2007-06-12', '2005-01-02') or cust_name = 'name2'");
    
    rs = st.getResultSet();
    cnt = 0;
    while(rs.next()) {
      cnt++;
    }
    assertEquals(3, cnt);
  }
  
  //enable it after ensuring data files are available
  public void testBug46851() throws Exception {

    // Bug #51839
    if (isTransactional) {
      return;
    }

    reduceLogLevelForTest("config");

    try {
    File file = new File("perf.txt");
    //PrintWriter bw =new PrintWriter(new OutputStreamWriter(new FileOutputStream(file)));
    PrintStream bw = System.out;

    System.setProperty("gemfire.OFF_HEAP_TOTAL_SIZE", "500m");
    System.setProperty("gemfire."+DistributionConfig.OFF_HEAP_MEMORY_SIZE_NAME, "500m");
    //SelectQueryInfo.setTestFlagIgnoreSingleVMCriteria(true);
    Properties props = new Properties();
    props.setProperty("log-level", "config");
    props.setProperty("table-default-partitioned", "false");
    Connection conn = getConnection(props);

    Statement st = conn.createStatement();

    // create the schema
    String resourcesDir = getResourcesDir();

    String schemaScript = resourcesDir
        + "/lib/tpch/create_tpch_tables_no_constraints.sql";
    String alterTableScript = resourcesDir
        + "/lib/tpch/alter_table_add_constraints.sql";

    String indexScript = resourcesDir + "/lib/tpch/create_indexes.sql";

    GemFireXDUtils.executeSQLScripts(conn, new String[] {
            schemaScript,alterTableScript,indexScript }, false,
        getLogger(), null, null, false);
    st.executeUpdate("SET SCHEMA TPCHGFXD");

    st.execute("CALL SYSCS_UTIL.IMPORT_TABLE_EX ('TPCHGFXD', 'REGION', '"+
    resourcesDir + "/lib/tpch/region.tbl', '|', null, null, 0, 0, 4, 0, null, null)");
    st.execute("CALL SYSCS_UTIL.IMPORT_TABLE_EX ('TPCHGFXD', 'NATION', '"+
    resourcesDir + "/lib/tpch/nation.tbl', '|', null, null, 0, 0, 4, 0, null, null)");
    st.execute("CALL SYSCS_UTIL.IMPORT_TABLE_EX ('TPCHGFXD', 'PART', '" +
    resourcesDir + "/lib/tpch/part.tbl', '|', null, null, 0, 0, 4, 0, null, null)");
    st.execute("CALL SYSCS_UTIL.IMPORT_TABLE_EX ('TPCHGFXD', 'SUPPLIER', '" +
    resourcesDir + "/lib/tpch/supplier.tbl', '|', null, null, 0, 0, 4, 0, null, null)");
    st.execute("CALL SYSCS_UTIL.IMPORT_TABLE_EX ('TPCHGFXD', 'PARTSUPP', '" +
    resourcesDir + "/lib/tpch/partsupp.tbl', '|', null, null, 0, 0, 4, 0, null, null)");
    st.execute("CALL SYSCS_UTIL.IMPORT_TABLE_EX ('TPCHGFXD', 'CUSTOMER', '" +
    resourcesDir + "/lib/tpch/customer.tbl', '|', null, null, 0, 0, 4, 0, null, null)");
    st.execute("CALL SYSCS_UTIL.IMPORT_TABLE_EX ('TPCHGFXD', 'ORDERS', '" +
    resourcesDir + "/lib/tpch/orders.tbl', '|', null, null, 0, 0, 4, 0, null, null)");
    st.execute("CALL SYSCS_UTIL.IMPORT_TABLE_EX ('TPCHGFXD', 'LINEITEM', '" +
    resourcesDir + "/lib/tpch/lineitem.tbl', '|', null, null, 0, 0, 4, 0, null, null)");
    
   String query9 = "select nation, o_year, sum(amount) as sum_profit " +
   		" from (  select n_name as nation, year(o_orderdate) as o_year, " +
   		" l_extendedprice * (1 - l_discount) - ps_supplycost * l_quantity as amount" +
   		"  from    part, supplier " +
   	//	"-- GEMFIREXD-PROPERTIES joinStrategy=HASH \n" +
   		",lineitem, partsupp, orders, nation  where " +
   		" s_suppkey = l_suppkey and ps_suppkey = l_suppkey and " +
   		" ps_partkey = l_partkey and p_partkey = l_partkey and o_orderkey = l_orderkey" +
   		"   and s_nationkey = n_nationkey and p_name like '%green%'  ) as profit" +
   		" group by  nation, o_year order by   nation, o_year desc";
   long start = System.currentTimeMillis();
   ResultSet rs = st.executeQuery(query9);
   
   while(rs.next()) {
     rs.getObject(1);
   }
   long end = System.currentTimeMillis();
   bw.println("query 9 time="+ (end -start) + "milliseconds");
   
   String query5 = "select n_name, sum(l_extendedprice * (1 - l_discount)) as revenue " +
   		"from   customer, orders" +
   		//"  -- GEMFIREXD-PROPERTIES joinStrategy=HASH \n"+
   		"  , lineitem, supplier" +
   		//"  -- GEMFIREXD-PROPERTIES joinStrategy=HASH \n" +
   		"  , nation, region where  c_custkey = o_custkey and l_orderkey = o_orderkey " +
   		" and l_suppkey = s_suppkey and c_nationkey = s_nationkey" +
   		"   and s_nationkey = n_nationkey and n_regionkey = r_regionkey" +
   		" and r_name = 'ASIA'   and o_orderdate >= '1994-01-01' " +
   		"  and o_orderdate <" +
   		" cast({fn timestampadd(SQL_TSI_YEAR, 1, timestamp('1994-01-01 23:59:59'))} as DATE)" +
   		" group by   n_name order by   revenue desc";
   start = System.currentTimeMillis();
   rs = st.executeQuery(query5);
   
   while(rs.next()) {
     rs.getObject(1);
   }
   end = System.currentTimeMillis();
   bw.println("query 5 time="+ (end -start) + "milliseconds");
   
   st.executeUpdate("drop table lineitem");
   st.executeUpdate("drop table  orders");
   st.executeUpdate("drop table partsupp");
   st.executeUpdate("drop table supplier");
   st.executeUpdate("drop table part");
   
   /*
   String queryX = "select ss_customer_sk ,sum(act_sales) sumsales " +
   		" from (select ss_item_sk ,ss_ticket_number ,ss_customer_sk ," +
   		" case when sr_return_quantity is not null " +
   		" then (ss_quantity-sr_return_quantity)*ss_sales_price" +
   		"    else (ss_quantity*ss_sales_price) end act_sales  from store_sales" +
   		" left outer join store_returns " +
   		"--SQLFIRE-PROPERTIES joinStrategy=hash \n" +
   		" on (sr_item_sk = ss_item_sk  " +
   		" and sr_ticket_number = ss_ticket_number) ,reason " +
   		"where sr_reason_sk = r_reason_sk   and r_reason_desc = 'reason 28') t" +
   		"   group by ss_customer_sk   order by sumsales, ss_customer_sk";
   
   start = System.currentTimeMillis();
   rs = st.executeQuery(queryX);
   
   while(rs.next()) {
     rs.getObject(1);
   }
   end = System.currentTimeMillis();
   bw.println("query X time="+ (end -start) + "milliseconds");*/
   bw.flush();
   bw.close();
    }finally {
      System.clearProperty("gemfire.OFF_HEAP_TOTAL_SIZE");
      System.clearProperty("gemfire."+DistributionConfig.OFF_HEAP_MEMORY_SIZE_NAME);
      SelectQueryInfo.setTestFlagIgnoreSingleVMCriteria(false);
    }
   
  }
  
  public void testBug50729() throws Exception {
    reduceLogLevelForTest("config");

    try {
    System.setProperty("gemfire.OFF_HEAP_TOTAL_SIZE", "500m");
    System.setProperty("gemfire."+DistributionConfig.OFF_HEAP_MEMORY_SIZE_NAME, "500m");
    SelectQueryInfo.setTestFlagIgnoreSingleVMCriteria(true);
    Properties props = new Properties();
    props.setProperty("log-level", "config");
    Connection conn = getConnection(props);
    
    Statement st = conn.createStatement();
    st.execute("create table networthv1 (cid bigint not null, " +
        "cash decimal (30, 1), securities decimal (30, 1), loanlimit int, " +
        "availloan decimal (30, 1),  tid int," +
        " constraint cash_ch_v1 check (cash>=0), constraint sec_ch_v1 check (securities >=0) " +
        ", constraint availloan_ck_v1 check (loanlimit>=availloan and availloan >=0)"+
        ")  offheap ");
    String query ="update networthv1 set cash=cash-?, round = ?  " +
    		"where cid in (select min(cid) from networthv1 " +
    		"where (securities>? and cash > ? and cid >=?)and round < ?)";
    //;pvs=;value=46.8,type=0;value=1,type=0;value=205796.1,type=0;value=2,type=0;value=266,type=0;value=1,type=0
    PreparedStatement insert = conn.prepareStatement("insert into networthv1 values(?,?,?,?,?,?)");
    String[] data = {"struct(CID:92,CASH:null,SECURITIES:null,LOANLIMIT:10000,AVAILLOAN:10000.0,TID:13,ROUND:0,C_CID:92)",
        "struct(CID:431,CASH:null,SECURITIES:null,LOANLIMIT:1000,AVAILLOAN:1000.0,TID:5,ROUND:0,C_CID:431)"
     };
   
    for( String line:data) {
    
     line = line.substring(7,line.length()-1);
     StringTokenizer stz = new StringTokenizer(line,":,");
     stz.nextToken();
     int cid = Integer.parseInt(stz.nextToken());
     insert.setInt(1, cid);
     stz.nextToken();
     String cashStr = stz.nextToken();
     if(cashStr.equalsIgnoreCase("null")) {
       insert.setNull(2, Types.DECIMAL);
     }else {
       insert.setFloat(2, Float.parseFloat(cashStr));
     }
     
     stz.nextToken();
     String secStr = stz.nextToken();
     if(secStr.equalsIgnoreCase("null")) {
       insert.setNull(3, Types.DECIMAL);
     }else {
       insert.setFloat(3, Float.parseFloat(secStr));
     }
     
     stz.nextToken();
     String llStr = stz.nextToken();
     if(llStr.equalsIgnoreCase("null")) {
       insert.setNull(4, Types.INTEGER);
     }else {
       insert.setInt(4, Integer.parseInt(llStr));
     }
     
     stz.nextToken();
     String avlStr = stz.nextToken();
     if(avlStr.equalsIgnoreCase("null")) {
       insert.setNull(5, Types.FLOAT);
     }else {
       insert.setFloat(5, Float.parseFloat(avlStr));
     }
     
     stz.nextToken();
     String tidStr = stz.nextToken();
     if(tidStr.equalsIgnoreCase("null")) {
       insert.setNull(6, Types.INTEGER);
     }else {
       insert.setInt(6, Integer.parseInt(tidStr));
     }
     /*
     stz.nextToken();
     String roundStr = stz.nextToken();
     if(roundStr.equalsIgnoreCase("null")) {
       insert.setNull(7, Types.INTEGER);
     }else {
       insert.setInt(7, Integer.parseInt(roundStr));
     }
     
     stz.nextToken();
     String ccidStr = stz.nextToken();
     if(ccidStr.equalsIgnoreCase("null")) {
       insert.setNull(8, Types.BIGINT);
     }else {
       insert.setLong(8, Integer.parseInt(ccidStr));
     }*/
     
     insert.executeUpdate();

    }
    
    st.execute("alter table networthv1 add column round int  DEFAULT 0");
    st.execute("alter table networthv1 add column c_cid bigint DEFAULT 1");
    st.execute("update networthv1 set c_cid = cid"); 
    PreparedStatement psQuery = conn.prepareStatement(query);
    
    psQuery.setFloat(1,46.8f);
    psQuery.setInt(2,1);
    psQuery.setFloat(3,205796.1f);
    
    psQuery.setInt(4,2);
    psQuery.setInt(5,266);
    
    psQuery.setInt(6,1);
    
    psQuery.executeUpdate();
    }finally {
      System.clearProperty("gemfire.OFF_HEAP_TOTAL_SIZE");
      System.clearProperty("gemfire."+DistributionConfig.OFF_HEAP_MEMORY_SIZE_NAME);
      SelectQueryInfo.setTestFlagIgnoreSingleVMCriteria(false);
    }
   
  }
  
  public void testFlavourOf50729_1() throws Exception{
     // Create a schema
      Connection conn = getConnection();
      PreparedStatement prepStmt = conn.prepareStatement("create schema trade");
      prepStmt.execute();
      Statement stmt = conn.createStatement();
      stmt.execute("create table trade.customers "
          + "(cust_name varchar(100), tid int)");
      stmt.execute("alter table trade.customers add column cid int not null default 1");
      stmt.execute("alter table trade.customers "
        + "add constraint cust_pk primary key (cid)");
      
      stmt.executeUpdate("insert into trade.customers (cid, cust_name, tid) values(1,'name1',1)");
      int n = stmt.executeUpdate("delete from trade.customers where cid = 1");
      assertEquals(1,n);
    
  }
  
  public void testFlavourOf50729_2() throws Exception{
    // Create a schema
     Connection conn = getConnection();
     PreparedStatement prepStmt = conn.prepareStatement("create schema trade");
     prepStmt.execute();
     Statement stmt = conn.createStatement();
     stmt.execute("create table trade.customers "
         + "(cid int not null default 1,cust_name varchar(100), tid int)");
     stmt.execute("alter table trade.customers "
       + "add constraint cust_pk primary key (cid)");
     stmt.execute("create table trade.portfolio "
     + "(cid int not null, qty int not null, "
     + " tid int, "
     + "constraint portf_pk primary key (cid))");
     stmt.execute("alter table trade.portfolio "
        + "add constraint cust_fk foreign key (cid) references "
        + "trade.customers (cid) on delete restrict");
     stmt.executeUpdate("insert into trade.customers (cid, cust_name, tid) values(1,'name1',1)");
     stmt.executeUpdate("insert into trade.portfolio (cid, qty, tid) values(1,1,1)"); 
 }
  
  public void testBug50756() throws Exception {
    reduceLogLevelForTest("config");

    try {
      System.setProperty("gemfire.OFF_HEAP_TOTAL_SIZE", "500m");
      System.setProperty("gemfire."
          + DistributionConfig.OFF_HEAP_MEMORY_SIZE_NAME, "500m");
      SelectQueryInfo.setTestFlagIgnoreSingleVMCriteria(true);
      Properties props = new Properties();
      props.setProperty("log-level", "config");
      Connection conn = getConnection(props);

      Statement st = conn.createStatement();
      st.execute("create table customersv1 (cid bigint not null, cust_name varchar(100), "
          + "since date, addr varchar(100), tid int, primary key (cid))  "
          + "partition by column (cust_name)   offheap ");
      st.execute("create index indexcustomerv1tid on customersv1 (tid)");
      PreparedStatement insertCustomer = conn
          .prepareStatement("insert into customersv1 " + "values(?,?,?,?,?)");
      
      String dataFile = getResourcesDir() + "/lib/bug50756/customers.dat";
      BufferedReader br = new BufferedReader(new InputStreamReader(
          new FileInputStream(dataFile)));
      String line;
      while ((line = br.readLine()) != null && !line.trim().equals("")) {
        line = line.trim();
        line = line.substring(7, line.length() - 1);
        StringTokenizer stz = new StringTokenizer(line, ":,");
        stz.nextToken();
        long cid = Long.parseLong(stz.nextToken());
        insertCustomer.setLong(1, cid);
        stz.nextToken();
        String cust_nameStr = stz.nextToken();
        if (cust_nameStr.equalsIgnoreCase("null")) {
          insertCustomer.setNull(2, Types.VARCHAR);
        } else {
          insertCustomer.setString(2, cust_nameStr);
        }

        stz.nextToken();
        String sinceStr = stz.nextToken();
        if (sinceStr.equalsIgnoreCase("null")) {
          insertCustomer.setNull(3, Types.DATE);
        } else {
          insertCustomer.setDate(3, java.sql.Date.valueOf(sinceStr));
        }

        stz.nextToken();
        String addStr = stz.nextToken();
        if (addStr.equalsIgnoreCase("null")) {
          insertCustomer.setNull(4, Types.VARCHAR);
        } else {
          insertCustomer.setString(4, addStr);
        }

        stz.nextToken();
        String tidStr = stz.nextToken();
        if (tidStr.equalsIgnoreCase("null")) {
          insertCustomer.setNull(5, Types.INTEGER);
        } else {
          insertCustomer.setInt(5, Integer.parseInt(tidStr));
        }
        insertCustomer.executeUpdate();
      }

      st.execute("alter table customersv1 add column round int DEFAULT 0");
      st.execute("create table networthv1 (cid bigint not null, cash decimal (30, 1), "
          + "securities decimal (30, 1), loanlimit int, availloan decimal (30, 1),  "
          + "tid int, constraint netw_pk_v1 primary key (cid), "
          + "constraint cust_newt_fk_v1 foreign key (cid) references customersv1 (cid) on delete restrict,"
          + " constraint cash_ch_v1 check (cash>=0), constraint sec_ch_v1 check (securities >=0), "
          + "constraint availloan_ck_v1 check (loanlimit>=availloan and availloan >=0)) "
          + " partition by range (cid) ( VALUES BETWEEN 0 AND 699, VALUES BETWEEN 699 AND 1102,"
          + " VALUES BETWEEN 1102 AND 1251, VALUES BETWEEN 1251 AND 1577,"
          + " VALUES BETWEEN 1577 AND 1800, VALUES BETWEEN 1800 AND 100000)   offheap ");

      st.execute("alter table networthv1 drop CHECK availloan_ck_v1");
      PreparedStatement insert = conn
          .prepareStatement("insert into networthv1 values(?,?,?,?,?,?)");
      dataFile = getResourcesDir() + "/lib/bug50756/networth.dat";
      br.close();
      br = new BufferedReader(new InputStreamReader(new FileInputStream(
          dataFile)));

      while ((line = br.readLine()) != null && !line.trim().equals("")) {
        line = line.trim();
        line = line.substring(7, line.length() - 1);
        StringTokenizer stz = new StringTokenizer(line, ":,");
        stz.nextToken();
        long cid = Long.parseLong(stz.nextToken());
        insert.setLong(1, cid);
        stz.nextToken();
        String cashStr = stz.nextToken();
        if (cashStr.equalsIgnoreCase("null")) {
          insert.setNull(2, Types.DECIMAL);
        } else {
          insert.setFloat(2, Float.parseFloat(cashStr));
        }

        stz.nextToken();
        String secStr = stz.nextToken();
        if (secStr.equalsIgnoreCase("null")) {
          insert.setNull(3, Types.DECIMAL);
        } else {
          insert.setFloat(3, Float.parseFloat(secStr));
        }

        stz.nextToken();
        String llStr = stz.nextToken();
        if (llStr.equalsIgnoreCase("null")) {
          insert.setNull(4, Types.INTEGER);
        } else {
          insert.setInt(4, Integer.parseInt(llStr));
        }

        stz.nextToken();
        String avlStr = stz.nextToken();
        if (avlStr.equalsIgnoreCase("null")) {
          insert.setNull(5, Types.FLOAT);
        } else {
          insert.setFloat(5, Float.parseFloat(avlStr));
        }

        stz.nextToken();
        String tidStr = stz.nextToken();
        if (tidStr.equalsIgnoreCase("null")) {
          insert.setNull(6, Types.INTEGER);
        } else {
          insert.setInt(6, Integer.parseInt(tidStr));
        }

        insert.executeUpdate();

      }
      st.execute("alter table networthv1 add column round int DEFAULT 0");
      st.execute("alter table networthv1 add column c_cid bigint with DEFAULT 1");
      st.executeUpdate("update networthv1 set c_cid = cid");
      st.execute("alter table networthv1 add constraint cust_newt_fk_v1_2 FOREIGN KEY (c_cid) "
          + "references customersv1 (cid) on delete restrict");
      st.execute("alter table networthv1 drop constraint cust_newt_fk_v1");
      st.execute("alter table customersv1 ALTER COLUMN cid SET GENERATED ALWAYS AS "
          + "IDENTITY");
      // update networthv1
      PreparedStatement updtNtw = conn
          .prepareStatement("update networthv1 set cash=cash-?, "
              + "round = ?  where cid in (select min(cid) from networthv1 "
              + "where (securities>? and cash > ? and cid >=?)and round < ?)");
      updtNtw.setFloat(1, 505.2f);
      updtNtw.setInt(2, 1);
      updtNtw.setFloat(3, 144574.8f);
      updtNtw.setFloat(4, 9);
      updtNtw.setLong(5, 61);
      updtNtw.setInt(6, 1);
      updtNtw.executeUpdate();
      // update networthv1
      updtNtw.setFloat(1, 39.7f);
      updtNtw.setInt(2, 1);
      updtNtw.setFloat(3, 17494.6f);
      updtNtw.setFloat(4, 9);
      updtNtw.setLong(5, 59);
      updtNtw.setInt(6, 1);
      updtNtw.executeUpdate();

      // update customersv1
      PreparedStatement updtCust = conn
          .prepareStatement(" update customersv1 set addr = ?, "
              + "round = ? where (cust_name=? or since = ? ) and round < ?");
      updtCust.setString(1, "address is name16");
      updtCust.setInt(2, 1);
      updtCust.setString(3, "name16");
      updtCust.setDate(4, java.sql.Date.valueOf("2005-09-14"));
      updtCust.setInt(5, 1);
      updtCust.executeUpdate();

      // update networthv1
      updtNtw.setFloat(1, 505.2f);
      updtNtw.setInt(2, 1);
      updtNtw.setFloat(3, 144574.8f);
      updtNtw.setFloat(4, 9);
      updtNtw.setLong(5, 61);
      updtNtw.setInt(6, 1);
      updtNtw.executeUpdate();
      //
      ResultSet rs = st
          .executeQuery("select count(*) from networthv1 where c_cid = 45 or c_cid=44");
      assertTrue(rs.next());
      assertEquals(2, rs.getInt(1));
      // delete from customers
      PreparedStatement deleteCust = conn
          .prepareStatement(" delete from customersv1 where cid in (? , ?)");
      deleteCust.setLong(1, 45);
      deleteCust.setLong(2, 44);
      try {
        deleteCust.executeUpdate();
        fail("delete should fail due to FK constraint violation");
      } catch (SQLException sqle) {
        if (sqle.getSQLState().indexOf("23503") == -1) {
          throw sqle;
        }

      }
    } finally {
      System.clearProperty("gemfire.OFF_HEAP_TOTAL_SIZE");
      System.clearProperty("gemfire."
          + DistributionConfig.OFF_HEAP_MEMORY_SIZE_NAME);
      SelectQueryInfo.setTestFlagIgnoreSingleVMCriteria(false);
    }

  }

  public void testBug49995() throws Exception {
    try {
      System.setProperty(GfxdConstants.GFXD_DISABLE_STATEMENT_MATCHING, "true");
      Properties props1 = new Properties();
      int mport = AvailablePort.getRandomAvailablePort(AvailablePort.JGROUPS);
      props1.put("mcast-port", String.valueOf(mport));
      setupConnection(props1);
      Connection conn = TestUtil.getConnection(props1);
      Properties props = new Properties();
      props.setProperty("single-hop-enabled", "true");
      props.setProperty("single-hop-max-connections", "5");
      Connection connClient = startNetserverAndGetLocalNetConnection(props);
      Statement st = conn.createStatement();
      st.execute("drop table if exists history");
      st.execute("create table history(house_id integer, household_id integer, "
          + "plug_id integer, time_slice smallint, load_total float(23), "
          + "load_count integer) partition by column (house_id)");
      st.execute("create index history_idx on history (house_id, household_id, plug_id, time_slice)");
      st.execute("insert into history (house_id, household_id, plug_id, time_slice, load_total, load_count) "
          + "values(0, 8, 9, 190, 44.868, 1), (0, 8, 9, 191, 44.868, 1), (0, 8, 9, 192, 44.868, 1), "
          + "(0, 8, 9, 193, 44.868, 1), (0, 8, 9, 194, 44.868, 1)");
      Statement stclient = connClient.createStatement();
      stclient
          .execute("select * from history where house_id = 0 and household_id = 8 and plug_id = 9 and time_slice = 193");
      stclient
          .execute("explain select * from history where house_id = 0 and household_id = 8 and plug_id = 9");
      stclient
          .execute("select * from history where house_id = 0 and household_id = 8 and plug_id = 9  and time_slice = 193");
    } finally {
      System
          .setProperty(GfxdConstants.GFXD_DISABLE_STATEMENT_MATCHING, "false");
    }
  }
  
  public void testBug48976() throws Exception {
    Properties props = new Properties();
    int mcastPort = AvailablePort.getRandomAvailablePort(AvailablePort.JGROUPS);
    props.put("mcast-port", String.valueOf(mcastPort));
    Connection conn = TestUtil.getConnection(props);
    Statement st = conn.createStatement();
    st.execute("create table trade.portfolio (cid int not null, sid int not null, "
        + "qty int not null, availQty int not null, subTotal decimal(30,20), "
        + "tid int, constraint portf_pk primary key (cid, sid), "
        + "constraint qty_ck check (qty>=0), constraint avail_ch check (availQty>=0 and availQty<=qty)) "
        + " partition by list (tid) (VALUES (0, 1, 2, 3, 4, 5), VALUES (6, 7, 8, 9, 10, 11), "
        + "VALUES (12, 13, 14, 15, 16, 17))  REDUNDANCY 2 PERSISTENT SYNCHRONOUS");
    
    st.execute("insert into trade.portfolio values(100, 100, 100, 100, 10.2, 100)");
    st.execute("create table trade.sellorders "
        + "(oid int not null constraint orders_pk primary key, "
        + "cid int, sid int, qty int, ask decimal (30, 20), order_time timestamp, status varchar(10), "
        + "tid int, constraint portf_fk foreign key (cid, sid) references trade.portfolio (cid, sid) on delete restrict, "
        + "constraint status_ch check (status in ('cancelled', 'open', 'filled')))  "
        + "partition by list (tid) (VALUES (0, 1, 2, 3, 4, 5), VALUES (6, 7, 8, 9, 10, 11), "
        + "VALUES (12, 13, 14, 15, 16, 17))  REDUNDANCY 2 PERSISTENT SYNCHRONOUS");
    st.execute("insert into trade.sellorders values(100, 100, 100, 100, 10.2, '2013-12-13 10:10:10', 'open', 100)");
    st.execute("select * from TRADE.SELLORDERS where OID >= 10  or CID >= 100");
    ResultSet rs = st.getResultSet();
    assertTrue(rs.next());
    assertEquals(100, rs.getInt(1));
    assertFalse(rs.next());
  }
  
  public void testBug47329_more() throws Exception {

    Properties props = new Properties();

    int mcastPort = AvailablePort.getRandomAvailablePort(AvailablePort.JGROUPS);

    props.put("mcast-port", String.valueOf(mcastPort));

    Connection conn = TestUtil.getConnection(props);

    // Connection conn = TestUtil.getConnection();

    Statement st = conn.createStatement();

    ResultSet rs = null;

    st.execute("create table t1 (c1 int primary key, c2 long varchar, c3 int)");
    st.execute("create index idx on t1(c2)");
    // st.execute("create index idx on t1(c2)");

    st.executeUpdate("insert into t1 values(0,'',3)");
    st.executeUpdate("insert into t1 values(1,' ',3)");
    st.executeUpdate("insert into t1 values(2,'aaaa',4)");
    st.executeUpdate("insert into t1 values(3,'aa aa',5)");
    st.executeUpdate("insert into t1 values(4,'aa  aa',6)");
    st.executeUpdate("insert into t1 values(5,'aa  ab',7)");
    st.executeUpdate("insert into t1 values(6,'aa  bb',8)");
    st.executeUpdate("insert into t1 values(7,'aa ab',9)");
    st.executeUpdate("insert into t1 values(8,'aa a~',9)");
    st.executeUpdate("insert into t1 values(9,'`a a@',9)");
    st.executeUpdate("insert into t1 values(10,'  aa  ',9)");
    int totalRows = 11;

    st.executeQuery("select * from t1 where c2 like '%'");
    rs = st.getResultSet();
    assertSize(rs, totalRows);

    st.executeQuery("select * from t1 where c2 like '%%'");
    rs = st.getResultSet();
    assertSize(rs, totalRows);

    PreparedStatement ps = conn.prepareStatement("select * from t1 where c2 like ?");
    ps.setString(1, "%a%");
    rs = ps.executeQuery();
    assertSize(rs, totalRows - 2);
    
    st.executeQuery("select * from t1 where c2 like '%a%'");
    rs = st.getResultSet();
    assertSize(rs, totalRows - 2);

    st.executeQuery("select * from t1 where c2 like '%aa%'");
    rs = st.getResultSet();
    assertSize(rs, totalRows - 3);
    
    st.executeQuery("select * from t1 where c2 like '%a a%'");
    rs = st.getResultSet();
    assertSize(rs, 4);

    st.executeQuery("select * from t1 where c2 like '%a  a%'");
    rs = st.getResultSet();
    assertSize(rs, 2);

    st.executeQuery("select * from t1 where c2 like '% %'");
    rs = st.getResultSet();
    assertSize(rs, 9);

    st.executeQuery("select * from t1 where c2 like '%  %'");
    rs = st.getResultSet();
    assertSize(rs, 4);

    st.executeQuery("select * from t1 where c2 like '  aa  '");
    rs = st.getResultSet();
    assertSize(rs, 1);

    st.executeQuery("select * from t1 where c2 like ' '");
    rs = st.getResultSet();
    assertSize(rs, 1);

    st.executeQuery("select * from t1 where c2 like '%  aa  '");
    rs = st.getResultSet();
    assertSize(rs, 1);
  }

  public void assertSize(ResultSet resultSet, int size) throws SQLException{
    int count = 0;
    for (;resultSet.next(); count++);
    assertEquals("ResultSet size mismatch", size, count);
  }



  public void _testBug46792() throws Exception {
    Properties props1 = new Properties();
    int mport = AvailablePort.getRandomAvailablePort(AvailablePort.JGROUPS);
    props1.put("mcast-port", String.valueOf(mport));
    setupConnection(props1);
    Connection conn = TestUtil.getConnection(props1);
    Statement s = conn.createStatement();
    s.execute("create table t1 (c1 int, c2 int) partition by column(c1)");
    s.execute("create table empty (c1 int, c2 int) partition by column(c1)");
    s.execute("insert into t1 values (null,null),(1,1),(null,null),(2,1),(3,1),(10,10)");
    s.execute("select max((select c1 from empty)) from t1");
  }
  
  public void testBug48533() throws Exception {
    Connection conn = TestUtil.getConnection();
    Statement st = conn.createStatement();

    st.execute("create schema emp");
    st.execute("create table emp.EMPLOYEE(lastname varchar(30) primary key, depId int) "
        + "partition by (depId) redundancy 0");
    GemFireXDQueryObserverAdapter observer = new GemFireXDQueryObserverAdapter() {
      @Override
      public boolean throwPutAllPartialException() {
        return true;
      }
    };
    GemFireXDQueryObserverHolder.setInstance(observer);
    PreparedStatement pstmnt = conn
        .prepareStatement("INSERT INTO emp.employee VALUES (?, ?)");
    for (int i = 0; i < 10; i++) {
      pstmnt.setString(1, "Jones"+i);
      pstmnt.setInt(2, i);
      pstmnt.addBatch();
    }
    try {
      pstmnt.executeBatch();
      fail("Test should not reach here");
    } catch (SQLException se) {
      System.out.println("state is: " + se.getSQLState());
      assertTrue("X0Z09".equals(se.getSQLState()));
    } finally {
      GemFireXDQueryObserverHolder.clearInstance();
    }
  }
  
  public void testDeleteInPersistentRegion() throws Exception {
    Properties props = new Properties();
    int mcastPort = AvailablePort.getRandomAvailablePort(AvailablePort.JGROUPS);
    props.put("mcast-port", String.valueOf(mcastPort));
    Connection conn = TestUtil.getConnection(props);
    Statement st = conn.createStatement();
    st.execute("create table trade.portfolio "
        + "(cid int not null, sid int not null, qty int not null, "
        + "availQty int not null, subTotal decimal(30,20), tid int not null unique, constraint portf_pk primary key (cid, sid), "
        + "constraint qty_ck check (qty>=0), constraint avail_ch check (availQty>=0 and availQty<=qty))"
        + " PERSISTENT SYNCHRONOUS");
    st.execute("insert into trade.portfolio values(938, 329, 756, 756, 49956.48000000000000000000, 1)");
    st.execute("delete from trade.portfolio where cid = 938 and sid = 329 and tid = 1");
    st.execute("insert into trade.portfolio values(938, 329, 756, 756, 49956.48000000000000000000, 1)");
  }
  
  public void testBug47329() throws Exception {
    Connection conn = TestUtil.getConnection();
    Statement st = conn.createStatement();
    ResultSet rs = null;

    st.execute("create table t1 (c1 int primary key, c2  varchar(10))");
    st.execute("create index idx on  t1(c2)");
    
    PreparedStatement pstmt = conn.prepareStatement("insert into t1 values(?,?)");
    pstmt.setInt(1, 111);
    pstmt.setString(2, "aaaaa");
    pstmt.executeUpdate();
    
    pstmt.setInt(1, 222);
    pstmt.setString(2, "");
    pstmt.executeUpdate();

    st.execute("select c1 from t1 where c2 like '%a%'");
    rs = st.getResultSet();
    System.out.println("rs=" + rs);
    assertEquals(true, rs.next());
    assertEquals(111, rs.getInt(1));
  }

  public void testBug46979() throws Exception {
    Connection conn = TestUtil.getConnection();
    Statement st = conn.createStatement();

    st.execute("create table app.customers (ccid int) replicate");
    st.execute("create table app.networth (ncid int) partition by column (ncid)");

    st.execute("insert into app.customers values (11)");
    st.execute("insert into app.customers values (22)");
    st.execute("insert into app.customers values (33)");
    st.execute("insert into app.customers values (44)");
    st.execute("insert into app.customers values (55)");

    st.execute("insert into app.networth values (11)");
    st.execute("insert into app.networth values (22)");
    st.execute("insert into app.networth values (44)");
    st.execute("insert into app.networth values (55)");

    try {
      st.execute("select * from app.customers c left outer join "
          + "app.networth n on c.ccid = n.ncid where n.ncid is null");
      fail("Left outer join with RR and PR and IS NULL is not supported. "
          + "Expect exception 0A000.");
    } catch (SQLException sqle) {
      if (sqle instanceof DerbySQLException) {
        if (!((DerbySQLException)sqle).getMessageId().equals("0A000.S")) {
          throw sqle;
        }
      }
      else if (!"0A000".equals(sqle.getSQLState())) {
        throw sqle;
      }
    }
  }
  
  public void testBug47464_NPE() throws Exception {
    Properties props = new Properties();
    int mcastPort = AvailablePort.getRandomAvailablePort(AvailablePort.JGROUPS);
    props.put("mcast-port", String.valueOf(mcastPort));    
    Connection conn = TestUtil.getConnection(props);
    Statement st = conn.createStatement();
    
    st.execute("create table t1 (col1 int, col2 clob)");
    st.execute("insert into t1 values (123, cast('abc' as clob))");
    st.execute("create index idx on t1(col1)");
    st.execute("update t1 set col1 = 789 where col1 = 123");
  }
  
  public void test48074_TSMC() throws Exception {
    Properties props = new Properties();
    int mcastPort = AvailablePort.getRandomAvailablePort(AvailablePort.JGROUPS);
    props.put("mcast-port", String.valueOf(mcastPort));
    Connection conn = TestUtil.getConnection(props);
    conn.createStatement().execute(
        "CREATE TABLE COMSPC.COM_SPC_SYS_MGMT_HIST" + "  ("
        + "   SYS_NAME VARCHAR(12 ) NOT NULL,"
        + "   OPER_TIME DATE DEFAULT CURRENT_DATE,"
        + "   FAB_NAME VARCHAR(12 ),"
        + "  PRIMARY KEY (SYS_NAME,OPER_TIME)"
        + ")PARTITION BY (cast( MONTH(OPER_TIME) AS CHAR(3))||SYS_NAME)"
        + "  REDUNDANCY 1" + "  PERSISTENT ASYNCHRONOUS");

    conn.createStatement()
      .execute(
          "insert into COMSPC.COM_SPC_SYS_MGMT_HIST (SYS_NAME, FAB_NAME) values ('1', '1')");
    conn.createStatement()
      .execute(
          "insert into COMSPC.COM_SPC_SYS_MGMT_HIST (SYS_NAME, FAB_NAME) values ('2', '2'), ('3', '3'), ('4', '4') ");

    ResultSet rs = conn
      .createStatement()
      .executeQuery(
          "select * from COMSPC.COM_SPC_SYS_MGMT_HIST where ( cast(MONTH(OPER_TIME) as char(3)) || SYS_NAME ) = (cast(MONTH(CURRENT_DATE) as char(3)) || '3') ");
    while (rs.next()) {
      assertEquals("3", rs.getString(1));
      assertEquals("3", rs.getString(3));
    }
    conn.close();
  }

  public void testVMRestart_Char() throws Exception {
    Connection conn = TestUtil.getConnection();
    Statement st = conn.createStatement();
    st.execute("create table chartab (col1 char(5) primary key) persistent");
    st.execute("insert into chartab values ('one ')");
    shutDown();
    conn = TestUtil.getConnection();
    st = conn.createStatement();
    st.execute("select * from chartab where col1 = 'one'");
    ResultSet rs = st.getResultSet();
    assertTrue(rs.next());
    assertEquals("one  ", rs.getString(1));
  }

  public void testVMRestart_Varchar() throws Exception {    
    Connection conn = TestUtil.getConnection();
    Statement st = conn.createStatement();
    st.execute("create table varchartab (col1 varchar(5) primary key) persistent");
    st.execute("insert into varchartab values ('one ')");
    shutDown();
    conn = TestUtil.getConnection();
    st = conn.createStatement();
    st.execute("select * from varchartab where col1 = 'one'");
    ResultSet rs = st.getResultSet();
    assertTrue(rs.next());
    assertEquals("one ", rs.getString(1));
    rs.close();
    st.execute("select * from varchartab where col1 = 'one '");
    rs = st.getResultSet();
    assertTrue(rs.next());
    assertEquals("one ", rs.getString(1));
  }

  public void test48278_51000() throws Exception {
    reduceLogLevelForTest("config");

    Properties props = new Properties();
    props.setProperty("mcast-port", String.valueOf(AvailablePort
        .getRandomAvailablePort(AvailablePort.JGROUPS)));
    Connection conn = getConnection(props);
    Statement st = conn.createStatement();
    st.execute("create table t1 (col1 bigint)");
    final int numRows = 500001;
    PreparedStatement ps = conn.prepareStatement("insert into t1 values(?)");
    for (int col1 = 0; col1 < numRows; col1++) {
      ps.setLong(1, col1);
      ps.addBatch();
      if (col1 % 1000 == 0) {
        ps.executeBatch();
        conn.commit();
      }
    }
    SanityManager.DEBUG_PRINT(GfxdConstants.TRACE_INDEX, "Creating index idx");
    st.execute("create index idx on t1(col1)");
    SanityManager.DEBUG_PRINT(GfxdConstants.TRACE_INDEX, "Created index idx");
    ResultSet rs = st.executeQuery("select count(*) from t1 where col1 > 1");
    assertTrue(rs.next());
    assertEquals(numRows - 2, rs.getInt(1));
    assertFalse(rs.next());

    // check the index
    PreparedStatement pstmt = conn
        .prepareStatement("select col1 from t1 where col1=?");
    for (int col1 = 0; col1 < numRows; col1++) {
      pstmt.setLong(1, col1);
      rs = pstmt.executeQuery();
      assertTrue(rs.next());
      assertEquals(col1, rs.getLong(1));
      assertFalse(rs.next());
      rs.close();
    }
  }

  public void testBug47671() throws Exception {
    Connection conn = TestUtil.getConnection();
    Statement st = conn.createStatement();
    try {
      st.execute("create table customers (id varchar(10) primary key, name char(40))");
      st.execute("insert into customers values ('', 'abc')");
      st.execute("insert into customers values ('', 'def')");
      fail("java.sql.SQLException(23505): primary key constraint violation is expected.");
    } catch (SQLException sqle) {
      if (!sqle.getSQLState().equals("23505")) {
        throw sqle;
      }
    }
  }
  
  public void testBug46933() throws Exception {
    //System.setProperty("gemfirexd.debug.true", "QueryDistribution");
    Connection conn = TestUtil.getConnection();
    Statement st = conn.createStatement();
    ResultSet rs = null;

    st.execute("create table customers (id int primary key, name char(40))");
    st.execute("insert into customers values (123, 'abc')");
    st.execute("update customers set name = 'def' where id = 123");

    st.execute("select name from customers where id = 123");

    rs = st.getResultSet();
    while (rs.next()) {
      assertEquals(40, rs.getString(1).length());
    }
    
    PreparedStatement ps = conn.prepareStatement("update customers set name = ? where id = 123");
    ps.setString(1, null);
    ps.executeUpdate();
    st.execute("select name from customers where id = 123");
    rs = st.getResultSet();
    assertTrue(rs.next());
    assertNull(rs.getString(1));
  }
  
  public void testBug47148() throws Exception {   
    setupConnection();
    Connection conn = TestUtil.jdbcConn;
    Connection conn2 = startNetserverAndGetLocalNetConnection();

    Statement stmt = conn.createStatement();
    ResultSet rs = null;

    stmt.execute("Create Table TEST_TABLE(idx numeric(12),"
        + "AccountID varchar(10)," + "OrderNo varchar(20),"
        + "primary key(idx)" + ")" + "PARTITION BY COLUMN ( AccountID )");

    stmt.execute("CREATE INDEX idx_AccountID ON test_Table (AccountID ASC)");
    stmt.execute("insert into test_table values(9, '8', '8')");

    String query = "select accountid from test_table where accountid like '8'";
    
    // check with client connection first
    Statement stmt2 = conn2.createStatement();
    rs = stmt2.executeQuery(query);
    assertTrue(rs.next());
    assertEquals("8", rs.getString(1));
    assertFalse(rs.next());

    // and with embedded driver
    rs = stmt.executeQuery(query);
    assertTrue(rs.next());
    assertEquals("8", rs.getString(1));
    assertFalse(rs.next());

    rs.close();
    stmt.close();
    stmt2.close();
    conn.close();
    conn2.close();
  }
  
  public void testBug49193_1() throws Exception {
    setupConnection();
    Connection conn = TestUtil.jdbcConn;
    Statement stmt = conn.createStatement();
    try {
      stmt.execute("create table customers (cid int not null, "
          + "cust_name varchar(100), col1 int , col2 int not null unique ,"
          + "tid int, primary key (cid)) " + " partition by range(tid)"
          + "   ( values between 0  and 10"
          + "    ,values between 10  and 100)");

      stmt.execute("create index i1 on customers(col1)");
      PreparedStatement psInsert = conn
          .prepareStatement("insert into customers values (?,?,?,?,?)");
      for (int i = 1; i < 20; ++i) {
        psInsert.setInt(1, i);
        psInsert.setString(2, "name" + i);
        psInsert.setInt(3, i % 4);
        psInsert.setInt(4, i);
        psInsert.setInt(5, 1);
        psInsert.executeUpdate();
      }

      conn = TestUtil.getConnection();
      GemFireXDQueryObserverHolder
          .setInstance(new GemFireXDQueryObserverAdapter() {
            @Override
            public void beforeGlobalIndexDelete() {
              throw new PartitionOfflineException(null, "test ignore");
            }

            @Override
            public double overrideDerbyOptimizerIndexUsageCostForSortedIndexScan(
                OpenMemIndex memIndex, double optimizerEvalutatedCost) {
              return Double.MAX_VALUE;
            }

            @Override
            public double overrideDerbyOptimizerCostForMemHeapScan(
                GemFireContainer gfContainer, double optimizerEvalutatedCost) {
              return Double.MIN_VALUE;
            }

          });

      addExpectedException(PartitionOfflineException.class);
      // Test bulk operations
      try {
        stmt.executeUpdate("delete from customers where cid > 0");
        fail("Test should fail due to problem in global index maintenance");
      } catch (Exception ignore) {
        removeExpectedException(PartitionOfflineException.class);
      }

      GemFireXDQueryObserverHolder.clearInstance();
      GemFireXDQueryObserverHolder
          .setInstance(new GemFireXDQueryObserverAdapter() {

            @Override
            public double overrideDerbyOptimizerIndexUsageCostForSortedIndexScan(
                OpenMemIndex memIndex, double optimizerEvalutatedCost) {
              return Double.MAX_VALUE;
            }

            @Override
            public double overrideDerbyOptimizerCostForMemHeapScan(
                GemFireContainer gfContainer, double optimizerEvalutatedCost) {
              return Double.MIN_VALUE;
            }

          });
      stmt.executeUpdate("delete from customers where cid > 0");

    } finally {
      GemFireXDQueryObserverHolder.clearInstance();
    }

  }
}
